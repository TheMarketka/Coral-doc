%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Type Definitions}

\minitoc

\newpage

\section{Type Definitions}
\label{sec:type-decls-aliases}

\syntax\begin{lstlisting}
Def              ::= Type_Definition
Type_Definition  ::= 'type' Typedef {'and' Typedef} 'end' ['type']
Typedef          ::= id [Type_Param_Clause] [Type_Information]
Type_Information ::= [ Type_Equation 
                     | Type_Abstract 
                     | Type_Representation] {semi Type_Constraint}
Type_Equation    ::= Is ['alias'] Type
Type_Abstract    ::= ['>:' Type] ['<:' Type]
Type_Constraint  ::= 'constraint' Stable_Id '=' Type
Is               ::= 'is' [nl] | ':=' [nl]
\end{lstlisting}

A {\em type declaration} \lstinline!type $t$[$\tps$] >: $L$ <: $U$! declares $t$ to be an abstract type with lower bound type $L$ and upper bound type $U$. If the type parameter clause \lstinline@[$\tps$]@ is omitted, $t$ abstracts over a first-order type, otherwise $t$ stands for a type constructor that accepts type arguments as described by the type parameter clause. 

If a type declaration appears as a member declaration of a type, implementations of the type may implement $t$ with any type $T$, for which $L \conforms T \conforms U$. It is an error if $L$ does not conform to $U$. Either or both bounds may be omitted. If the lower bound $L$ is omitted, the bottom type \code{Nothing} is implied. If the upper bound $U$ is omitted, the top type \code{Object} is implied. 

A type constructor declaration declaration imposes additional restriction on the concrete types for which $t$ may stand. Besides the bounds $L$ and $U$, the type parameter clause, indexing parameter clause and units of measure parameter clause may impose higher-order bounds and variances, as governed by the conformance of type constructors (\sref{sec:conformance}).

The scope of a type parameter extends over the bounds ~\lstinline!>: $L$ <: $U$!~ and the type parameter clause $\tps$ itself. A higher-order type parameter clause (of an abstract type constructor $tc$) has the same kind of scope, restricted to the declaration of the type parameter $tc$. 

To illustrate nested scoping, these declarations are all equivalent: 
\begin{itemize}
  \item[] ~\lstinline!type t[m[x] <: Bound[x], Bound[x]] end! 

  \item[] ~\lstinline!type t[m[x] <: Bound[x], Bound[y]] end!

  \item[] ~\lstinline!type t[m[x] <: Bound[x], Bound[_]] end!,
\end{itemize} 
as the scope of, e.g., the type parameter of $m$ is limited to the declaration of $m$. In all of them, $t$ is an abstract type member that abstracts over two type constructors: $m$ stands for a type constructor that takes one type parameter and that must be a subtype of \code{Bound}, $t$'s second type constructor parameter. However, the first example should be avoided, as the last ~\lstinline!x!~ is unrelated to the first two occurrences, but may confuse the reader. 

A {\em type alias} \lstinline@type $t$ := $T$@ defines $t$ to be an alias name for the type $T$. Since---for type safety and consistence reasons---types are constant and can not be replaced by another type when bound to a constant name, type aliases are permanent. A type remembers the first given constant name, no alias can change that. The left hand side of a type alias may have a type parameter clause, e.g. \lstinline@type $t$[$\tps$] := $T$@. The scope of a type parameter extends over to the right hand side $T$ and the type parameter clause $\tps$ itself. 

It is an error if a type alias refers recursively to the defined type constructor itself. 

\example The following are legal type declarations and aliases:
\begin{lstlisting}
type Integer_List := List[Integer] end
type T <: Comparable[T] end
type Two[A] := Tuple_2[A, A] end
type My_Collection[+X] <: Iterable[X] end
\end{lstlisting}
The following are illegal:
\begin{lstlisting}
type Abs := Comparable[Abs] end (* recursive type alias *)

type S <: T end  (* S, T are bounded by themselves *)
type T <: S end

type T >: Comparable[T.That] end (* can't select from T
                                    T is a type, not a value *)
type My_Collection <: Iterable end
  (* type constructor members must explicitly state
     their type parameters *)
\end{lstlisting}





\section{Aspect Definitions}
\label{sec:aspects}

\syntax\begin{lstlisting}
Aspect_Definition ::= 'aspect' [Aspect_Clause] Aspect_Def
Aspect_Def        ::= id ['extends' Class_Parents] Aspect_Tmpl_Env
Aspect_Tmpl_Env   ::= '{' Aspect_Body '}'
                    | 'begin' Aspect_Body 'end' ['aspect']
Aspect_Body       ::= Aspect_Stat {semi Aspect_Stat}
Aspect_Stat       ::= Advice_Def
                    | Pointcut_Def
                    | Template_Stat
Pointcut_Def      ::= 'pointcut' id
                      ['(' [id [':' Type]] {',' [id [':' Type]]} ')']
                      'is' Pointcut_Type 'end' ['pointcut']
Pointcut_Type     ::= 'invoke' (id | regular_expression_literal)
                    | 'get' (id | regular_expression_literal)
                    | 'set' (id | regular_expression_literal)
                    | 'handler' Type
                    | 'returning' [id [':' Type] | Type]
                    | 'throwing' [id [':' Type] | Type]
                    | 'raising' [id [':' Type] | Type]
                    | 'yielding' [id [':' Type] | Type]
                    | 'advice-execution' 
                      [(id | regular_expression_literal)]
                    | 'self' (id | Type)
                    | 'target' (id | Type)
                    | 'arguments' '(' id [':' Type] | Type 
                      {',' (id [':' Type] | Type)} ')'
                    | 'if' (Infix_Expr | '(' Infix_Expr ')')
                    | 'not' Pointcut_Ref
                    | Pointcut_Ref 'and' Pointcut_Ref
                    | Pointcut_Ref 'or' Pointcut_Ref
                    | '(' Pointcut_Ref ')'
                    | 'retain' [id [':' Type] | Type]
                    | 'release' [id [':' Type] | Type]
Pointcut_Ref      ::= id ['(' id {',' id} ')'] | Pointcut_Type
Advice_Def        ::= 'advice' 
                      Advice_Spec (Pointcut_Ref | Pointcut_Type)
                      Block_Expr
Advice_Spec       ::= 'before' 
                    | 'after' [('returning' | 'throwing' | 'raising'
                              | 'yielding') [id [':' Type] | Type]]
                    | 'around'
Aspect_Clause     ::= 'per-self' [Pointcut_Ref] 
                    | 'per-target' [Pointcut_Ref] 
\end{lstlisting}

Only for \code{Block_Expr} inside of \code{Advice_Def}:
\begin{lstlisting}
Simple_Expr1    ::= 'joinpoint' ['.' Selection]
\end{lstlisting}

% https://eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html
% https://eclipse.org/aspectj/doc/released/progguide/quick.html (better)
% important term: published join point context data (args, target, caller etc.)
% also important: http://en.wikipedia.org/wiki/Cross-cutting_concern#Examples - see memory management (possible join points: allocation, deallocation, retain, release)







\section{Enumeration Type Definitions}
\label{sec:enums}

\syntax\begin{lstlisting}
Type_Representation ::= Is ['bitfield'] 
                        'enum' ('{' Enum_Field {semi Enum_Field} '}'
                        | Enum_Field {semi Enum_Field})
                        [Record_Extensions]
Enum_Field          ::= id ':=' scalar_literal
                      | id 'of' Named_Exprs
                      | id
\end{lstlisting}

Enums (short for Enumerations) are types that contain constants. Bitfield enums may be combined to still produce a single enum value. Every enum constant is a singleton instance of the enum class. 

An enum constant can be enhanced with custom parameters, which are then passed to the appropriate custom constructor. Enum definitions should only appear in four forms: 
\begin{itemize}
  \item Initialized with a scalar literal. Each enum constant then have a method \code{value}, which corresponds to the passed literal. Each literal passed has to be of the same type and numeric literals get an auto-incremented value for every following enum constant definition that omits its explicit value. At least the first enum constant has to be initialized with a scalar literal. The comparison operators (e.g. ``\code{<}'') are automatically added and their implementations reflect the order in which the enum constants appear. The signature of the enum must extend a scalar type, and is the only one that allows for the \code{bitfield} keyword to be used with it.
  \item Initialized with nothing, then each enum constant is by itself the ordering, no implicit literal value is added. The comparison operators are automatically added and their implementations reflect the order in which the enum constants appear. 
  \item Initialized with custom expression. The argument expression can be extracted with pattern matching as a contained single value, or if the argument expression is a tuple, as a tuple. It is highly recommended for every enum constant to be immutable, but it is not mandatory. This form can't extend any parent class and has the same implicit ordering as the previous form. 
\end{itemize}

Unlike variant types (\sref{sec:variant-types}), enumeration types do not represent classes of values, but instead enumerate a limited set of concrete values. 





\section{Variant Type Definitions}
\label{sec:variant-types}

\syntax\begin{lstlisting}
Type_Representation ::= Is 'variant' [nl]
                        (Variant1 | Variant2)
                        [Record_Extensions]
Variant1            ::= Variant_Field {semi Variant_Field}
Variant2            ::= '{' Variant_Field {semi Variant_Field} '}'
Variant_Field       ::= Type_Constr_Dcl
Type_Constr_Dcl     ::= id ['of' Types]
\end{lstlisting}

Variant types are similar to a simplified form for a series of case classes (\sref{sec:case-classes}) and case objects (\sref{sec:case-objects}), with shared interface and a common ancestor. Pattern matching is possible on variant types, as it would be done on case classes and case objects. 

Variant type is the algebraic sum type. Unlike unions (\sref{sec:unions}), variant type is a disjoint union -- its values are pairwise disjoint. The contained values however need not be pairwise disjoint. 

Unlike enumerations (\sref{sec:enums}), variant types are not just constants, they instead define classes of values. 

The form ~\lstinline!$\id$ of $T$! is called {\em non-constant variant constructors}. The objects that represent non-constant variant constructors can be memoized by the runtime, so that there is at most one singleton object per every arguments combination, but the runtime does not need to guarantee that such an object will be physically identical at different times. The contained values can be extracted with pattern matching, similar to enumerations, using tuple patterns (\sref{sec:tuple-patterns}). 

\paragraph{Note}
Non-constant variant constructors are internally type-parameterized with the same type parameters as the variant type. 

The form ~\lstinline!$\id$! is called {\em constant variant constructors}. The objects that represent constant variant constructors are singletons. Unlike with regular union types in Gear, constant variant constructors are not pre-existing types, but rather new types. 

Variant types may be parameterized, therefore polymorphic. Overloading on type parameters is possible. 

Record extension members, if given, are added to the type object, unless they are specified with \code{member} keyword, then they are added to the type instances. Implementations and declarations of interfaces are automatically added to the type instances. 

\example An example of a variant type. 
\begin{lstlisting}
type B-tree[T] is case enum 
{
  Empty
  Node of T * B-tree[T] * B-tree[T]
}
with def is_member? (x, b-tree) :=
  match b-tree
  when Empty then no
  when Node(y, left, right) then
    if x = y then yes
    elsif x < y then is_member? x, left
    else is_member? x, right
    end if
  end match
and def insert (x, b-tree) := 
  match b-tree
  when Empty then Node x, Empty, Empty
  when Node(y, left, right) then
    if x <= y then Node y, (insert x, left), right
    else Node y, left, (insert x, right)
    end if
  end match
end type
\end{lstlisting}

Unlike enumeration types (\sref{sec:enums}), variant types do not enumerate a limited set of values, but instead represent classes of values with non-constant variant constructors and enumerate a limited set of singleton values with constant variant constructors\footnote{Thus a variant type that has only constant variant constructors is identical to an enumeration type, which is a situation to be avoided.}. 





\subsection{Generalized Algebraic Datatype Definitions}
\label{sec:gadt-types}

\syntax\begin{lstlisting}
Type_Representation ::= Is 'variant' [nl]
                        (Gadt1 | Gadt2)
                        [Record_Extensions]
Gadt1               ::= Gadt_Field {semi Gadt_Field}
Gadt2               ::= '{' Gadt_Field {semi Gadt_Field} '}'
Gadt_Field          ::= id [Type_Param_Clause] ':' [Type '->'] Type
\end{lstlisting}





\subsection{Extensible Variant Types}
\label{sec:extensible-variant-types}

\syntax\begin{lstlisting}
Type_Representation ::= Is 'open' 'variant' [nl]
                        (Variant1 | Variant2)
                        [Record_Extensions]
Struct_Spec         ::= 'type' id [Type_Param_Clause] 
                        '+=' Type_Constr_Dcl
Struct_Def          ::= 'type' id [Type_Param_Clause] 
                        '+=' Type_Constr_Def
Type_Constr_Def     ::= Type_Constr_Dcl 
                      | id ':=' Stable_Id
\end{lstlisting}






\section{Record Type Definitions}
\label{sec:record-types}

\syntax\begin{lstlisting}
Type_Representation ::= Is 'record' (Record1 | Record2)
Record1             ::= Record_Components [Record_Extensions]
Record2             ::= '{' Record_Components '}' [Record_Extensions]
Record_Components   ::= Record_Component {semi Record_Component}
Record_Component    ::= ['val' | 'var'] id ':' (Type | id)
                      | 'case' id Record_Cases
                        {'when' id 
                        ('then' | nl) 
                        Record_Components} 'end' ['case']
Record_Cases        ::= semi Record_Case {semi Record_Case} 'end' ['case']
                      | '{' Record_Case {semi Record_Case} '}'
Record_Case         ::= 'when' ['.'] Stable_Id ['(' [Extractions] ')']
                        ('then' | semi) Record_Components
Record_Extensions   ::= [nl] 'with' Record_Extension {'and' Record_Extension}
Record_Extension    ::= Tmpl_Member
                      | Tmpl_Ifc_Impl
                      | Tmpl_Ifc_Dcl
\end{lstlisting}

Record extension members, if given, are added to the type object, unless they are specified with \code{member} keyword, then they are added to the type instances. Implementations and declarations of interfaces are automatically added to the type instances. 





\section{Structure, Signature \& Functor Type Definitions}
\label{sec:struct-types}

% TBD: finish
% TBD: replace Dcl and Def by something more sensible, also (in) Tmpl_things, sync with top-level definitions, separate interfaces from implementations
\syntax\begin{lstlisting}
Dcl               ::= Struct_Spec
Struct_Type       ::= Struct_Type_Path
                    | 'sig' [Struct_Spec {semi Struct_Spec}] 'end'
                    | 'functor' 
                      '(' [id ':' Struct_Type {',' id ':' Struct_Type}] ')' 
                      '->' Struct_Type
                    | Struct_Type 'with' Struct_Constraint 
                      {'and' Struct_Constraint}
                    | '(' Struct_Type ')'
                    | 'signature' 'of' Struct_Expr
Struct_Spec       ::= 'val' id ':' Type
                    | Type_Definition
                    | 'throwable' Type_Constr_Dcl 'end' ['throwable']
                    | 'raiseable' Type_Constr_Dcl 'end' ['raiseable']
                    | Interface_Definition
                    | Protocol_Definition
                    | 'structure' id ':' Struct_Type 'end' ['structure']
                    | 'signature' id [Is Struct_Type] 'end' ['signature']
                    | 'open' Struct_Path
                    | 'open!' Struct_Path
                    | 'include' Struct_Type
                    | Use
                    | {Annotation} Struct_Spec
Def               ::= Struct_Def
Struct_Expr       ::= Struct_Path
                    | 'struct' [Struct_Items] 'end' ['struct']
                    | 'struct' '{' [Struct_Items] '}'
                    | 'functor' '(' [id ':' Struct_Type] ')' '->' Struct_Expr
                    | Struct_Expr '(' Struct_Expr ')'
                    | '(' Struct_Expr ')'
                    | '(' Struct_Expr 'as' Struct_Type ')'
                    | '(' 'val' Expr ['as' Pkg_Type] ')'
Struct_Items      ::= Struct_Item {semi Struct_Item} 
Struct_Item       ::= Struct_Def | Expr
Struct_Def        ::= Val_Def
                    | Type_Definition
                    | 'throwable' Type_Constr_Dcl 'end' ['throwable']
                    | 'throwable' id Is Stable_Id
                    | 'raiseable' Type_Constr_Dcl 'end' ['raiseable']
                    | 'raiseable' id Is Stable_Id
                    | Class_Definition
                    | Object_Definition
                    | Trait_Definition
                    | Refinement_Definition
                    | Protocol_Definition
                    | 'structure' id 
                      [Struct_Ascription Struct_Type] 
                      Is Struct_Expr
                    | 'open' Struct_Path
                    | 'open!' Struct_Path
                    | 'include' Struct_Expr
                    | Use
                    | {Annotation} Struct_Def
Struct_Ascription ::= ':' | ':>'
Struct_Constraint ::= 'type' id [Type_Param_Clause] Type_Equation
                    | 'type' id [Type_Param_Clause] ':=' Type
                    | 'struct' Struct_Path '=' Extended_Struct_Path
                    | 'struct' Struct_Path ':=' Extended_Struct_Path
Type              ::= 'structure' Pkg_Type
Pkg_Type          ::= Type_Path 
                      ['with' Pkg_Constraint {'and' Pkg_Constraint}]
Pkg_Constraint    ::= 'type' Type_Path Type_Equation 

Struct_Path          ::= Module_Path
Extended_Struct_Path ::= Extended_Struct_Name {'.' Extended_Struct_Name}
Extended_Struct_Name ::= id {'(' Extended_Struct_Path {',' Extended_Struct_Path} ')'}
Type_Path            ::= [Extended_Struct_Path '.'] id
\end{lstlisting}





\section{Range, Floating \& Fixed Point Subtype Definitions}
\label{sec:fl-fi-subtypes}

\syntax\begin{lstlisting}
Type_Representation ::= Is FP_Type_Def 
                      | Is FP_Subtype_Def 
                      | Is FP_Range_Def
FP_Type_Def         ::= (FiP_Type_Def | FlP_Type_Def) 
FP_Subtype_Def      ::= Type (FiP_Subtype_Def | FlP_Subtype_Def) 
FP_Range_Def        ::= FP_Range
FlP_Type_Def        ::= FP_Digits [FP_Range]
FlP_Subtype_Def     ::= FP_Digits [FP_Range]
                      | FP_Range
FiP_Type_Def        ::= FP_Delta [FP_Range] 
                      | FP_Delta FP_Digits [FP_Range]
FiP_Subtype_Def     ::= FP_Delta [FP_Digits] [FP_Range]
                      | FP_Digits [FP_Range]
                      | FP_Range
FP_Digits           ::= 'digits' Infix_Expr
FP_Delta            ::= 'delta' Infix_Expr
FP_Range            ::= 'range' Infix_Expr 
                        ('..' | '...' | '..<') Infix_Expr
                      | 'range' Type
\end{lstlisting}

The described syntaxes are for definitions of 4 special types of values:
\begin{enumerate}
  \item Range subtypes.
  \item Floating point types. 
  \item Ordinary fixed point types. 
  \item Decimal fixed point types. 
\end{enumerate}

\paragraph{Range subtypes}
A range subtype (the \code{FP_Range_Def} syntax category) is a type defined by a lower and upper bounds. The expected type of both bounds is \code{Magnitude}. Such a range type may be used in combination with the following subtypes to constrain them, or standalone as a regular range value. The lower bound must be lower than or equal to the upper bound. The lower bound may be negative infinity, the upper bound may be positive infinity. The range subtype itself is a subtype of \code{Magnitude}, or more precisely, a subtype of the least upper bound of types of the bounds, selecting a range of its values. For floating and fixed point types, it has to be a range of \code{Real} values. 

\paragraph{Floating point types} ~\\
A floating point type (the \code{FlP_Type_Def} syntax category) is a way to define an appropriate representation of a floating point number, based on the required accuracy instead. 
\begin{itemize}
  \item[] The {\em requested decimal precision}, which is the minimum number of significant decimal digits required for the floating point type, is specified by the value of the expression given after the keyword \code{digits}. Such expression is expected to be of \code{Integer} type. 
  \item[] The bounds of the range specification are expected to be \code{Real} type; the types do not need to be the same.\footnote{E.g., one bound can be an integer, the other a real number.}
  \item[] The requested decimal precision shall be positive and not greater than an implementation-defined precision limit in \code{Number.Max_Base_Digits}. If the range specification is omitted, the requested decimal precision shall be not greater than \code{Number.Max_Digits}. 
  \item[] A floating point type definition is illegal if the implementation does not support a floating point type that satisfies the requested decimal precision and range. 
  \item[] A subtype of a floating point type is compatible to the parent type if the digits of the subtype are not greater than the digits of the parent type, and its range fits to the range of the parent type. 
\end{itemize}

\example Examples of floating point types and subtypes:
\begin{lstlisting}
type Coefficient is digits 10 range -1.0 ..< 1.0 
end type

type Mass is digits 7 range 0.0 ..< 1.0e+35 
end type

(* a subtype with a smaller range *)
type Probability is Real range 0.0 ... 1.0
end type
\end{lstlisting}

\paragraph{Fixed point types}
An ordinary fixed point type (the first branch of the \code{FiP_Type_Def} syntax category) is a way to define a decimal type, based on the given delta. 
A decimal fixed point type (the second branch of the \code{FiP_Type_Def} syntax category) is a way to define a decimal type, based on the given delta and number of needed digits.  
\begin{itemize}
  \item[] The error bound of a fixed point type is specified as an absolute value, called the {\em delta} of the fixed point type. 
  \item[] For a type defined by the fixed point type definition, the delta of the type is specified by the value of the expression given after the keyword \code{delta}; this expression is expected to be of a \code{Real} type. For a type defined by the decimal fixed point definition, the number of significant decimal digits is specified by the expression given after the keyword \code{digits}; this expression is expected to be of \code{Integer} type. 
  \item[] The expressions given after the reserved keywords \code{delta} and \code{digits} shall result in positive values. 
  \item[] The set of values of a fixed point type comprise the integral multiples of a number called the {\em small} of the type. 
  \item[] For ordinary fixed point type, the small is an implementation-defined power of 2 not greater than the delta, unless annotation ~\lstinline!@[fixed_point_small $s$]! is applied to the type, defining the small to be $s$, where $s$ is not greater than the delta. 
  \item[] For decimal fixed point type, the small equals the delta; the delta shall be a power of 10. If a range specification is given, both bounds of the range shall be in the range $-(10^{\digits}-1)*\fpdelta$ \code{...} $(10^{\digits}-1)*\fpdelta$. 
  \item[] A fixed point type definition is illegal if the implementation does not support a fixed point type with the given small and specified range or digits. 
  \item[] An ordinary fixed point type definition defines an ordinary fixed point type, whose base range includes at least all multiples of the small that are between the bounds defined by the range specification, if it is given, or between negative infinity to positive infinity\footnote{Using the \code{Decimal} types.}, if the range specification is not given.
  \item[] A decimal fixed point type definition defined a decimal fixed point type, whose base range includes at least the range $-(10^{\digits}-1)*\fpdelta$ \code{...} $(10^{\digits}-1)*\fpdelta$. 
  \item[] If a decimal fixed point type definition does is not given a range specification, then an implicit range $-(10^{\digits}-1)*\fpdelta$ \code{...} $(10^{\digits}-1)*\fpdelta$ is specified for it. 
  \item[] A subtype of a decimal fixed point type is compatible to the parent type if the digits of the subtype are not greater than the digits of the parent type, and its range fits to the range of the parent type. 
\end{itemize}

\example Examples of fixed point types and subtypes:
\begin{lstlisting}
type Volt is delta 0.125 range 0.0 ..< 255.0 
end type

type Fraction is delta Number.Fine_Delta range -1.0 ..< 1.0 
end type

type Money is delta 0.01 digits 15 
end type

type Salary is Money digits 10 
end type
\end{lstlisting}





