%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\section*{Preface}

Gear is a Ruby-like programming language which enhances advanced object-oriented programming with elements of functional programming. Everything is an object, in this sense it's a pure object-oriented language. Object blueprints are described by classes. Classes can be composed in multiple ways – classic inheritance and/or trait composition, along with prototype-oriented inheritance.

Gear is also a functional language in the sense that every function is also an object, and generally, everything is a value. Therefore, function definitions can be nested and higher-order functions are supported out-of-the-box. Gear also has support for pattern matching, which can emulate the algebraic types used in other functional languages.

Gear has been developed since 2012 in a home environment out of pure enthusiasm for programming and out of a desire for a truly versatile language. This document is a work in progress and will stay that way forever. It acts as a reference for the language definition and some core library classes.

Some of the languages that had major influence on the development of Gear, including syntax and behavior patterns, are Ruby, Ada, Scala, Java, C\#, F\#, Clojure and ATS. Gear tries to inherit their good parts and put them together in its own way.

The vast majority of Gear's syntax is inspired by \emph{Ruby}. Gear uses keyword program parentheses in Ruby fashion. There is \lstinline@class $\ldots$ end@, \lstinline@def $\ldots$ end@, \lstinline@do $\ldots$ end@, \lstinline@loop $\ldots$ end@. Ruby itself is inspired by other languages, so this relation is transitive and Gear is inspired by those languages as well (for example, Ada). 

Gear is inspired by \emph{Ada} in the way that user identifiers are formatted: \lstinline@Some_Constant_Name@ and — unlike in Ada, but quite similar to it — \lstinline@some_method_name@. Also, some control structures are inspired by Ada, such as loops, named loops, return expressions and record types. Pretty much like in Ada, Gear's control structures can be usually ended the same way: \lstinline@class $\ldots$ end class@, etc. 

\emph{Scala} influenced the type system in Gear. Syntax for existential types comes almost directly from it. Also, along with other C-like languages, Scala influenced Gear to allow to choose between Ada-style program parentheses (e.g. \lstinline@begin $\ldots$ end@) and C-style parentheses (i.e. \lstinline@{ $\ldots$ }@) in many places throughout the syntax. Moreover, the structure of this mere specification is inspired by Scala's specification. 

From \emph{F\#}, Gear borrows some functional syntax (like function composition) and F\# also inspired the feature of Units of Measure (\sref{sec:unitsofmeasuresyntax} \& \sref{sec:units-of-measure}). 

\emph{Clojure} inspired Gear in the way functions can get their names. Gear realizes that turning function names into sentences does not always work, so it is possible to use dashes, plus signs and slashes inside of function names. Therefore, \lstinline@call/cc@ is a legit function identifier. Indeed, binary operators are required to be properly surrounded by whitespace or other non-identifier characters.






\section*{Status of This GFR}

This GFR is active and mandatory for every proper Gear implementation, without exceptions. The status of this GFR is not likely to change. 






