%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Types}

\minitoc

\newpage

\syntax\begin{lstlisting}
Type                ::= Function_Type
                      | Infix_Type [Existential_Clauses]
Function_Type       ::= Function_Args {'->' Function_Args} 
                        '->' Type
Function_Args       ::= Infix_Type
                      | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg        ::= ['*' | '**' | '&' | ['~'] id ':'] Param_Type
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
                      | 'var' Var_Dcl
Compound_Type       ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                        ['with' ['refinement'] Refine_Stats]
                      | ['refinement'] Refine_Stats
Postfix_Type        ::= Compound_Type 
                        ['with' 'constraint' Constraint_Block]
Infix_Type          ::= Postfix_Type {op_id [nl] Postfix_Type}
Annot_Type          ::= {Annotation} Simple_Type [Nullable_Mod]
Simple_Type         ::= Simple_Type [Type_Args]
                      | Simple_Type '#' id
                      | Stable_Id
                      | Path '.' 'type'
                      | Literal ['.' 'type']
                      | '(' [Types] ')'
                      | Foreign_Type
Types               ::= Named_Subtype {',' Named_Subtype}
Named_Subtype       ::= [['~'] id ':'] Type
Type_Equation       ::= '=' Type
\end{lstlisting}

When we say \textit{type} in the context of Gear, we are talking about a blueprint of an entity, while the type itself is an entity. Every type in Gear is backed by a \textit{class}, which is an instance of the type \lstinline@Class@. 

We distinguish a few different properties of types in Gear. There are first-order types and type constructors, which take type parameters and yield new types. A subset of first-order types called \textit{value types} represents set of first-class values. Value types are either \textit{concrete} or \textit{abstract}. 

Concrete value types can be either a \textit{class type} (e.g. referenced with a type designator, referencing a class or maybe a trait), or a \textit{compound type} representing an intersection of types, possibly with a refinement that further constrains the types of its members. Both class types and compound types may be bound to a constant, but only class types referencing a concrete class can be blueprints of values -- \textit{objects}. Compound types can only constrain bindings to a subset of other types. 

Non-value types capture properties of identifiers that are not values. For instance, a type constructor does not directly specify a type of values, but a type constructor, when applied to the correct type arguments, yields a first-order type, which may be a value type. Non-value types are expressed indirectly in Gear. In example, a method type is described by writing down a method signature, which is not a real type itself, but it creates a corresponding method type. 






\section{About Gear's Type System}

There are two main streams of typing systems out there -- statically typed and dynamically typed. Static typing in a language usually means that the language is compiled into an executable with a definite set of types and every operation is type checked. Dynamic typing means that these checks are deferred until needed, in runtime. 

Let's talk about Java. Java uses static typing -- but, in a very limited and unfriendly way, you may use class loaders and a lot of type casts to dynamically load a new class. And then possibly endure a lot of pain using it. 

Let's talk about Ruby. Ruby uses dynamic typing -- but, using types blindly can possibly lead to some confusion. Ruby is amazing though, because you can write programs with it really fast and enjoy the process at the same time. But when it comes to type safety, you need to be careful. 

And now, move on to Gear. Gear uses hybrid typing. In its core, it uses static typing. But, it allows to opt-in for dynamic typing using a special type \code{Dynamic}. Unlike in Ruby, you can overload methods (not just override!). You can constrain variables, constants, properties, arguments and result types to particular types. But you don't have to. Types in Gear were heavily inspired by Scala's and Ruby's type systems, but modified for this hybrid environment that Gear provides. Unlike in Ruby, you can have pure interfaces (called protocols\footnote{Interfaces in Gear are used to extract the {\em public interface} of classes in modules, so that only a small amount of code may be distributed along with the module to allow binding to it.}), or interfaces with default method implementations (similar to Java 8). Unlike in Java, you can have traits, union types, record types and much more. Unlike in Java, you may easily modify classes, even from other modules ({\em pimp my library!} and {\em open-class principle}). You may even easily add more classes if needed, and possibly shadow existing ones. Implicit conversions are also made available dynamically at runtime, not just during compilation. 

While Gear is so dynamic, it also needs to maintain stability and performance. Therefore, it ``caches'' its bindings and tracks versions of each type\footnote{Versions are simply integers that are incremented with each significant change to the type and distributed among its subtypes.}. If a {\em cached binding} would change, it is ok -- as long as the new binding would be compatible with the old one. Practically, the code that executes first initiates the binding -- first to come, first to bind. Bindings are also cached, so that the Gear interpreter does not need to traverse types all the time -- it only does so if the needed binding does not exist (initial state with dynamic typing), or if the cached version does not match the current version of the bound type. This mechanism is also used for caching methods, not only types.

Types in Gear are represented by objects that are members of the \code{Type} type. Instances of value types are represented by objects that are members of the \code{Class} type. 






\section{Paths}
\label{sec:type-paths}

\syntax\begin{lstlisting}
Path             ::= Stable_Id
                   | [id '.'] 'self'
                   | 'self' '[' ('cloned' | 'origin') ']'
                   | 'outer' Class_Qualifier
Stable_Id        ::= [Path '.'] id
                   | [id '.'] 'super' [Class_Qualifier] '.' id
                   | 'outer' Class_Qualifier '.' id
                   | Module_Path '.' Stable_Id
                   | ''' id
Class_Qualifier  ::= '[' (id | Simple_Type) ']'
Module_Path      ::= [Root] Module_Selector {'.' id}
Module_Selector  ::= [Vendor] id
Root             ::= '@Root' '.'
Vendor           ::= id '/'
\end{lstlisting}

Paths are not types themselves, but they can be a part of named types and in that function form a role in Gear's type system. 

A path is one of the following:

\begin{itemize}
  \item The empty path $\epsilon$ (which can not be written explicitly in user programs). 

  \item \code{this}, which references the directly enclosing class. 

  \item \lstinline@$C$.self@, where $C$ references a class or a trait. The path \code{self} is taken as a shorthand for \lstinline@$C$.self@, where $C$ is the name of the class directly enclosing the reference. A special path ~\lstinline!Function.self!, where \code{Function} is defined by Gear's \code{Language} module (not imported to be anything else), is a reference to the directly enclosing function object and is available only within functions (or methods, anonymous functions, and even blocks).

  \item \lstinline@self[cloned]@, which references the directly enclosing class of a clone (a cloned instance, see \sref{sec:clone-def}). 

  \item \lstinline@self[origin]@, which references the directly enclosing class of an original object (an instance being cloned, see \sref{sec:clone-def}). 

  \item \lstinline@$p$.$x$@, where $p$ is a path and $x$ is a member of $p$.. 

  \item \lstinline@$C$.super.$x$@ or \lstinline@$C$.super[$M$].$x$@, where $C$ references a class or a trait and $x$ references a member of the superclass or designated parent class $M$ of $C$. The prefix \code{super} is taken as a shorthand for \lstinline@$C$#super@, where $C$ is the name of the class directly enclosing the reference, and \lstinline@super[$M$]@ as a shorthand for \lstinline@$C$.super[$M$]@, where $C$ is yet again the name of the class directly enclosing the reference. 

  \item \lstinline!'$x$!, where $x$ is a type variable name.\footnote{Not quite the same as type parameter nor type argument.}
\end{itemize}

Paths introduce also {\em path dependent types}, if the referenced member is a type. 






\section{Value Types}

Every value in Gear has a type which is of one of the following forms. 






\subsection{Singleton Type}
\label{sec:singleton-types}

\syntax\begin{lstlisting}
Simple_Type ::= Path '.' 'type'
\end{lstlisting}

A singleton type is of the form ~\lstinline@$p$.type@, where $p$ is a path pointing to a value. The type denotes the set of values consisting of solely the value denoted by $p$.

A {\em stable type} is either a singleton type or a type which is declared to be a subtype of a trait \code{Singleton_Type}. 





\subsection{Cloned Type}
\label{sec:cloned-types}

\syntax\begin{lstlisting}
Simple_Type ::= Path '.' 'cloned' '.' 'type'
\end{lstlisting}

A cloned type is of the form ~\lstinline!$p$.cloned.type!, where $p$ is a path pointing to a value. The type denotes the set of values consisting of the value denoted by $p$ and every value that is cloned from the value denoted by $p$. 

A {\em stable type} is either a cloned type or a type which is declared to be a subtype of a trait \code{Cloned_Type}. Singleton in this view appears to be a special case (more concrete to be precise) of a cloned type, excluding the cloned values. 





\subsection{Literal-Based Singleton Type}
\label{sec:literal-based-singleton-type}

\syntax\begin{lstlisting}
Simple_Type ::= Literal ['.' 'type']
\end{lstlisting}

A singleton type based on a literal is of the form \lstinline@$l$.type@, where $l$ is a literal. The type denotes the set of values consisting of every literal value that is equal to $l$. 

A {\em stable type} is either a literal-based singleton type or a type which is declared to be a subtype of a trait \code{Literal_Singleton_Type}. 

In contexts where a type is expected\footnote{Most notably type arguments or type annotations of variables or function result types.}, the ``\code{.type}'' part of the type can be omitted. 





\subsection{Type Projection}
\label{sec:type-projection}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type '#' id
\end{lstlisting}

A type projection \lstinline@$T$#$x$@ references type member named $x$ of type $T$. This is useful i.e. with nested classes that belong to the class instances, not the class object. 

% example based on: http://stackoverflow.com/a/9444487/473180
\example A sample code that shows off what type projections are good for:
\begin{lstlisting}
class A {
  class B {}
  def f (b: B): Unit   := Console.print_line "Got my B."
  def g (b: A#B): Unit := Console.print_line "Got a B."
}

val a1 := A.new
val a2 := A.new
a2.f a1.B.new     (* type mismatch, found a1.B, required a2.B *)
a2.g a1.B.new     (* prints "Got a B." to stdout *)
a2.f a2.B.new     (* prints "Got my B." to stdout *)
\end{lstlisting}
This is due to the fact that the \code{class B} is defined as a class instance member of \code{class A}, not as a class object member (either via object definition (\sref{sec:object-definitions}) or some form of metaclass access (\sref{sec:metaclasses})). Therefore, \code{a1.B} refers to type member \code{B} of the instance \code{a1}, but not of \code{a2}. Moreover, \code{A.B} is not defined here. 

% TBD: add example with graphs from http://www.scala-lang.org/old/node/115, as Gear does the same thing






\subsection{Type Designators}
\label{sec:type-designators}

\syntax\begin{lstlisting}
Simple_Type ::= Stable_Id
\end{lstlisting}

A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections. 

Specifically, the unqualified type name $t$ where $t$ is bound in some class $C$ is taken as a shorthand for ~\lstinline@$C$.self.type#$t$@. If $t$ is bound in some object\footnote{Also in class object methods.} or module $C$, it is taken as a shorthand for ~\lstinline@$C$.type#$t$@. If $t$ is not bound in a class, object or module, then $t$ is taken as a shorthand for ~\lstinline@$\epsilon$.type#$t$@. 

A qualified type designator has the form ~\lstinline@$p$.$t$@, where $p$ is a path (\sref{sec:type-paths}) and $t$ is a type name. Such a type designator is equivalent to the type projection ~\lstinline@$p$.type#$t$@. 

\example Some type designators and their expansions are listed below, the type designator being on the left and the expansion on the right of ``\code{=}''. 
\begin{lstlisting}
t = $\epsilon$.type#t (* "global space" *)
(* predefined import of Gear/Language *)
Number = Gear/Language.type#Number 

object An_Object {
  type t
  t = An_Object.type#t (* bound by object *)
}

class A_Class {
  type t
  def a_method := {
    t = A_Class.self.type#t (* bound by class *)
  }
  class << self
    type u
    u = A_Class.type#u (* bound by (class) object *)
  end
  t = A_Class.self.type#t (* bound by class *)
  self.u = A_Class.type#u (* bound by (class) object *)
}
\end{lstlisting}






\subsection{Parameterized Types}
\label{sec:parameterized-types}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type [Type_Args]
Type_Args   ::= '[' Types ']'
Types       ::= Type_Arg {',' Type_Arg}
Type_Arg    ::= [['~'] id ':'] Type 
              | '<' uom_expr '>'
              | ['*'] '_'
\end{lstlisting}

A parameterized type $T[T_1 \commadots T_n]$ consists of a type designator $T$ and type parameters $T_1 \commadots T_n$, where $n \geq 1$. $T$ must refer to a type constructor which takes exactly $n$ type parameters $a_1 \commadots a_n$. 

Say the type parameters have lower bounds $L_1 \commadots L_n$ and upper bounds $U_1 \commadots U_n$. The parameterized type is well-formed if each actual type parameter {\em conforms to its bounds}, so that $\sigma L_i <: T_i <: \sigma U_i$, where $\sigma$ is the substitution $[a_1 := T_1 \commadots a_n := T_n]$\footnote{The substitution works by replacing occurrences of $a_i$ in the argument by $T_i$, so that, e.g. ~\lstinline!$A$ <: Comparable[$A$]!~ is substituted into ~\lstinline!$C$ <: Comparable[$C$]!.}. Also, $U_i$ must never be a subtype of $L_i$, since no other type ever would be able to fulfill the bounds ($U_i$ and $L_i$ may be the exact same type though, but in that case the type parameter would be invariant and the whole point of having a parameterized type would be useless). 

Each type parameter may be given a name $n$, which is done by prepending it with an id immediately followed by a colon, which itself may be prepended with a tilde ``\lstinline!~!''. The first case is a shorthand for adding an annotation ~\lstinline!@[named :$n$]!, the second is a shorthand for adding the previous annotation and also ~\lstinline!@[purely_named]!. 

\example
\label{example:parameterized-types}
Given the generic type definitions: 

\begin{lstlisting}
class Tree_Map[A <: Comparable[A], B] $\ldots$ end
class List[A] $\ldots$ end
class I extends Comparable[I]; $\ldots$ end

class F[M[_], X] $\ldots$ end
class S[K <: String] $\ldots$ end
class G[M[Z <: I], I] $\ldots$ end

trait Function_1[T, R]; end
\end{lstlisting}

the following parameterized types are well-formed: 

\begin{lstlisting}
Tree_Map[I, String]
List[I]
List[List[Boolean]]

F[List, Number]
G[S, String]

Function_1[named: List[String], String]
\end{lstlisting}

\example
\label{example:parameterized-types-mal}

Given the type definitions of the previous example, the following types are malformed: 

\begin{lstlisting}
Tree_Map[I]               (* wrong number of parameters *)
Tree_Map[List[I], Number] (* type parameter List not within bound *)

F[Number, Boolean]        (* Number is not a type constructor
F[Tree_Map, Number]       (* Tree_Map takes two parameters, 
                             F expects a type constructor taking one *)

G[S, Number]              (* type S constrains its parameter to
                             conform to String, 
                             G expects type constructor with a parameter
                             that conforms to Number *)
\end{lstlisting}





\subsection{Tuple Types}
\label{sec:tuple-types}

\syntax\begin{lstlisting}
Simple_Type ::= '(' Types ')'
Infix_Type  ::= Named_Subtype {'*' Named_Subtype}
\end{lstlisting}

A tuple type ($T_1 \commadots T_n$) is an alias for the class \lstinline@Tuple_$n$[$T_1 \commadots T_n$]@, where $n \geq 2$. 

A tuple type $T_1 * \ldots * T_n$ is an infix type (\sref{sec:infix-types}) representing the exact same tuple type as ($T_1 \commadots T_n$).

Tuple classes are available as patterns for pattern matching. The properties can be accessed as methods ~\lstinline!1$ \commadots n$!. 

Tuple classes are generated lazily by the runtime as needed, so that the language does not constrain users to tuples of only limited sizes, but allows any size. 

If any of the tuple's type parameters $T_i$ is annotated to be named $n$ (see \sref{sec:parameterized-types}, then an additional method named $n$ is added, returning the same value as ~\lstinline!$i$!, of the type $T_i$. If that type parameter is furthermore annotated with ~\lstinline!@[purely_named]!, then the ~\lstinline!$i$!~ is removed. 






\subsection{Annotated Types}

\syntax\begin{lstlisting}
Annot_Type ::= {Annotation} Simple_Type
\end{lstlisting}

An annotated type $a_1 \ldots a_n T$ attaches annotations (\sref{sec:annotations}) $a_1 \commadots a_n$ to the type $T$. 






\subsection{Compound Types}
\label{sec:compound-types}

\syntax\begin{lstlisting}
Compound_Type ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                  ['with' ['refinement'] Refine_Stats]
                | ['refinement'] Refine_Stats
Refine_Stats  ::= '{' Refine_Stat {semi Refine_Stat} '}'
Refine_Stat   ::= Dcl
                | Type_Definition
                | Constraint_Dcl
                | Struct_Constraint
                | ()
\end{lstlisting}

A compound type \lstinline@$T_1$ with $\ldots$ with $T_n$ with refinement {$R$}@ represents values with members as given in the component types $T_1 \commadots T_n$ and the refinement \lstinline@{$R$}@. A refinement \lstinline@{$R$}@ contains declarations and definitions (\sref{sec:refinements}). 

If no refinement is given, the type is implicitly equivalent to the same type having an empty refinement. 

A compound type may also consist of just a refinement \lstinline@{$R$}@ with no preceding component types -- such a type has an implicit component type \code{Object} and describes the member values as ``any value, as long as it has what the refinement requires'', thus it works like an anonymous protocol. 

If a compound type does not contain a concrete class type, then \code{Object} is implied in case the type is used as a concrete class\footnote{Meaning that the compound type is used as an ad-hoc (possibly anonymous) class, e.g. to create new instances of it.}.

The keyword \code{refinement} instructs that the following tokens will be a part of a refinement, and the construct ~\lstinline!refinement {$R$}!~ is called an {\em anonymous refinement}, being equivalent to ~\lstinline!Object with refinement {$R$}!, although when the refinement is a part of a compound type with more elements than just the refinement itself, the \code{Object} type is replaced with the class type appearing in the compound type, if any. 

The \code{refinement} keyword can be omitted from a compound type that consists of more elements than just the refinement. Constructs ~\lstinline!Object with {$R$}!~ and ~\lstinline!refinement {$R$}!~ are then equal. 

The \code{refinement} keyword may also be omitted from a compound type that consists of just the refinement, but only in contexts in which a type is expected, i.e.: parameter type declaration, value or variable type declaration, result type declaration, type argument application or type parameter declaration; but never stand-alone. If used as such, the constructs ~\lstinline!refinement {$R$}!~ and ~\lstinline!{$R$}!~ are then equal. 






\subsection{Infix Types}
\label{sec:infix-types}

\syntax\begin{lstlisting}
Infix_Type ::= Postfix_Type {op_id [nl] Postfix_Type}
\end{lstlisting}

An infix type $T_1\ \op\ T_2$ consists of an infix operator $\op$, which gets applied to two type operands $T_1$ and $T_2$. The type is equivalent to the type application ~\lstinline!$\op$[$T_1$, $T_2$]!. The infix operator $\op$ may be an arbitrary identifier, and is expected to represent a type constructor. 

Infix type may also result from an infix expression (\sref{sec:prefix-infix-ops}), if such operator name is not found on the result type of the expression that it is applied to. In any case, precedence and associativity rules of operators apply here as well. 






\subsection{Function Types}
\label{sec:function-types}

\syntax\begin{lstlisting}
Type          ::= Function_Args {'->' Function_Args}
                  '->' Type
Function_Args ::= Infix_Type
                | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg  ::= ['*' | '**' | '&' | ['~'] id ':'] Param_Type
\end{lstlisting}

The type \lstinline@($T_1 \commadots T_n$) -> $R$@ represents the set of function values that take arguments of types $T_1 \commadots T_n$ and yield results of type $R$. In the case of exactly one argument, type \lstinline@$T$ -> $R$@ is a shorthand for \lstinline@($T$) -> $R$@. 

Function argument types may be annotated with some extra properties. In that case, these map to annotations of their types, defined as follows:
\begin{itemize}
\item ``\code{out}'' maps to \lstinline[deletekeywords={out}]!@[out]!. 
\item ``\code{in}'' maps to no annotation, as it is implied, and if the parameter is \code{out}-only, the function is still applicable. 
\item ``\code{*}'' maps to \code{@[variadic]}. 
\item ``\code{**}'' maps to \code{@[capturing_named]}. 
\item ``\code{&}'' maps to \code{@[captured_block]}. 
\item ``\code{$\id$}'' maps to \code{@[named :$\id$]}. 
\item ``\lstinline!~$\id$!'' maps to ~\lstinline!@[named :$\id$] @[purely_named]!. 
\end{itemize}

Function types associate to the right, e.g. \lstinline@($S$) -> ($T$) -> $R$@ is the same as \lstinline@($S$) -> (($T$) -> $R$)@. 

Function types are shorthands for class types that conform to the \lstinline@Function_$i$@ protocol -- i.e. having an \code{apply} function or simply {\em being} a function. The $n$-ary function type \lstinline@($T_1 \commadots T_n$) -> $R$@ is a shorthand for the protocol \lstinline@Function_$n$[$T_1 \commadots T_n,R$]@. Such protocols are defined in the Gear library for any $n \ge 0$:

\begin{lstlisting}
protocol Function_$n$[-$T_1 \commadots\,$-$T_n$, +$R$]
  message apply ($x_1$: $T_1 \commadots x_n$: $T_n$): $R$
  $\ldots$
end protocol
\end{lstlisting}

Function types are covariant in their result type and contravariant in their argument types (\sref{sec:variance-of-type-parameters}).

A function that returns ``nothing'' may be declared as returning the type \code{Unit}, which is similar to \lstinline[language=C]!void! in C-related languages. Such a type is then written as ~\lstinline!($S$) -> Unit!. 

Function arguments may be optionally annotated with more requirements: 
\begin{itemize}
\item
Parameter prefixed with ``\lstinline!*!'' is a requirement of a repeated parameter. 

\item 
Parameter prefixed with ``\lstinline!$\id$!'' is a requirement of a parameter named $\id$.

\item 
Parameter prefixed with ``\lstinline!~$\id$!'' is a requirement of a parameter purely named $\id$.

\item 
Parameter prefixed with ``\lstinline!**!'' is a requirement of a captured named parameters. 

\item
Parameter prefixed with ``\lstinline!&!'' is a requirement for the passed block. It does not tell whether the function must capture the passed block, it only restricts the requirements for the particular block, if any. The actual passed block may have more or even less positional or named parameters (extra ones on the block side are given \code{undefined}, unless the type is not nullable (\sref{sec:nullable-types}) -- that is an error; and extra ones on the type side are simply discarded), but the result type of the passed block must conform (\sref{sec:conformance}).
\end{itemize}

\paragraph{Note}
Although the function type alone allows to attach the extra annotations to types of arguments in a \code{1:1} manner (and therefore types of parameters), due to how conformance is defined for function types, it is not always desirable to use them. The only argument extra that might be of any use is the captured block argument, so that a requirement of a passed block is marked (not caring about the actual style of the block passing). 

\example The following definition of functions \code{g} and \code{h} conform to a definition of a function \code{f}, and there are many more such functions that conform to \code{f}. And vice versa, \code{f} conforms to both \code{g} and \code{h}, although the latter two are more specific than the first one (\sref{sec:overloading-resolution}). 
\begin{lstlisting}
def f (*x: Integer) end
def g (x: Integer, y: Integer) end
def h (x: Integer, y: Integer, z: Integer) end
\end{lstlisting}






\subsection{Existential Types}
\label{sec:existential-types}

\syntax\begin{lstlisting}[escapechar=@]
Type                ::= Infix_Type Existential_Clauses
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
\end{lstlisting}

An existential type has the form ~\lstinline@$T$ for-some { $Q$ }@, where $Q$ is a sequence of type declarations (\sref{sec:type-decls-aliases}). Let ~\lstinline@$t_1$[$\tps_1$] >: $L_1$ <: $U_1\ \commadots\ t_n$[$\tps_n$] >: $L_n$ <: $U_n$@~ be the types declared in $Q$ (any of the type parameter sections ~\lstinline![$\tps_i$]!~ might be missing). The scope of each type $t_i$ includes the type $T$ and the existential clause $Q$. The type variables $t_i$ (occurring in the sequence $Q$) are said to be {\em bound} in the type ~\lstinline!$T$ for-some { $Q$ }!. Type variables that occur in a type $T$, but which are not bound in $T$, are said to be {\em free} in $T$. 

A {\em type instance} of ~\lstinline@$T$ for-some { $Q$ }@~ is a type $\sigma T$, where $\sigma$ is a substitution over $t_1 \commadots t_n$, such that for each $i$, $\sigma L_i \conforms \sigma t_i \conforms \sigma U_i$. The set of values denoted by the existential type \lstinline@$T$ for-some { $Q$ }@ is the union of the set of values of all its type instances. In other words, a type instance of an existential type is a type application (\sref{sec:type-applications}) of the type ~\lstinline@$T$ for-some { $Q$ }@, where the applied type arguments conform to the bounds, or are free in ~\lstinline@$T$ for-some { $Q$ }@. 

A {\em skolemization} of ~\lstinline@$T$ for-some { $Q$ }@~ is a type instance $\sigma T$, where $\sigma$ is the substitution $[t_1 := t'_1 \commadots t_n := t'_n]$ and each $t'_i$ is a fresh abstract virtual type with lower bound $\sigma L_i$ and upper bound $\sigma U_i$\footnote{This virtual type $t'_i$ denotes the set of all types, for which $\sigma L_i \conforms \sigma t'_i \conforms \sigma U_i$.}. Such type instance is inaccessible to user programs, but is essential to type equality and conformance checks, as it describes the set of values denoted by the existential type without an actual existential type, but with a universal type. 



\paragraph{Simplification rules}
Existential types obey the following equivalences:
\begin{enumerate}
\item
Multiple \code{for-some} clauses in an existential type can be merged. E.g., ~\lstinline@$T$ for-some { $Q$ } for-some { $Q'$ }@~ is equivalent to ~\lstinline@$T$ for-some { $Q$; $Q'$ }@. 

\item
Unused quantifications can be dropped. E.g., ~\lstinline@$T$ for-some { $Q$; $Q'$ }@, where none of the types defined in $Q'$ are referred to by $T$ or $Q$, is equivalent to ~\lstinline@$T$ for-some { $Q$ }@. 

\item
An empty quantification can be dropped. E.g., ~\lstinline@$T$ for-some { }@~ is equivalent to $T$. 

\item
An existential type ~\lstinline@$T$ for-some { $Q$ }@, where $Q$ contains a clause ~\lstinline!type $t$[$\tps$] >: $L$ <: $U$!~ is equivalent to the type ~\lstinline@$T'$ for-some { $Q$ }@, where $T'$ results from $T$ by replacing every covariant occurrence (\sref{sec:variance-of-type-parameters}) of $t$ in $T$ by $U$ and by replacing every contravariant occurrence of $t$ in $T$ by $L$. 
\end{enumerate}



\paragraph{Existential quantification over values}
As a syntactic convenience, the bindings clause in an existential type may also contain value declarations ~\lstinline!val $x$: $T$!. An existential type ~\lstinline@$T$ for-some { $Q$; val $x$: $S$; $Q'$ }@~ is treated as a shorthand for the type ~\lstinline@$T'$ for-some { $Q$; type $t$ <: $S$ with Singleton_Type; $Q'$ }@, where $t$ is a fresh type name and $T'$ results from $T$ by replacing every occurrence of ~\lstinline!$x$.type!~ with $t$. 



\paragraph{Placeholder syntax for existential types}
Gear supports a placeholder syntax for existential types. A {\em wildcard type} is of the form ~\lstinline!_ >: $L$ <: $U$!. Both bound clauses may be omitted. If a lower bound clause ~\lstinline!_ >: $L$!~ is omitted, ~\lstinline!_ >: Nothing!~ is assumed. If an upper bound clause ~\lstinline!_ <: $U$!~ is omitted, ~\lstinline!_ >: Object!~ is assumed. A wildcard type is a shorthand for an existentially quantified type variable, where the existential quantification is implicit. 

A wildcard type must appear as a type argument of a parameterized type. Let ~\lstinline!$T$ := $p$.$c$[$\targs$, $T$, $\targs'$]!~ be a parameterized type, where $\targs$, $\targs'$ may be empty and $T$ is a wildcard type ~\lstinline!_ >: $L$ <: $U$!. Then $T$ is equivalent to the existential type
\begin{lstlisting}
$p$.$c$[$\targs$, $t$, $\targs'$] for-some { type $t$ >: $L$ <: $U$ }
\end{lstlisting}
where $t$ is a fresh type variable. Wildcard types may also appear as parts of compound types (\sref{sec:compound-types}), function types (\sref{sec:function-types}) or tuple types (\sref{sec:tuple-types}). Their expansion is then the expansion in the equivalent parameterized type. 

\example Assume the class definitions
\begin{lstlisting}
class Ref[T] {}
abstract class Outer { type T }
\end{lstlisting}

Here are some examples of existential types:
\begin{lstlisting}
Ref[T] for-some { type T <: Number }
Ref[x.T] for-some { val x: Outer }
Ref[x_type#T] for-some { type x_type <: Outer with Singleton_Type }
\end{lstlisting}

The last two types in this list are equivalent. An alternative formulation of the first type above using wildcard syntax is:
\begin{lstlisting}
Ref[_ <: Number]
\end{lstlisting}

which is equivalent to Java's
\begin{lstlisting}[language=Java]
Ref<? super Number>
\end{lstlisting}

\lstinline!Ref[_ <: Number]!~ then represents any type constructed by the type\code{Ref} parameterized with a type that is \code{Number} or any type that conforms to \code{Number}. 

\lstinline!Ref[_ >: Number]!~ would then represents any type constructed by the type \code{Ref} parameterized with a type that is \code{Number} or any type that \code{Number} conforms to. 

\example The type ~\lstinline!List[List[_]]!~ is equivalent to the existential type
\begin{lstlisting}
List[List[T] for-some { type T }]  .
\end{lstlisting}

\example Assume a covariant type
\begin{lstlisting}
class List[+T] {}
\end{lstlisting}

The type 
\begin{lstlisting}
List[T] for-some { type T <: Number }
\end{lstlisting}

is equivalent (by simplification rule 4 above\footnote{As ~\lstinline!T!~ appears in covariant position in \code{List}, its upper bound can replace the type variable in \code{List}.}) to
\begin{lstlisting}
List[Number] for-some { type T <: Number }
\end{lstlisting}

which is in turn equivalent (by simplification rules 2 and 3 above\footnote{The type variable ~\lstinline!T!~ is unused, and after dropping it, the quantification is empty.}) to
\begin{lstlisting}
List[Number]  .
\end{lstlisting}

Since this \code{List} type is covariant in its type parameter, then e.g. ~\lstinline!List[Integer]!~ is still a subtype of ~\lstinline!List[Number]!. 





\subsection{Nullable Types}
\label{sec:nullable-types}

\syntax\begin{lstlisting}
Annot_Type    ::= {Annotation} Simple_Type Nullable_Mod
Nullable_Mod  ::= '?' | '!'
\end{lstlisting}

A nullable type has the form \lstinline!$T$?!, where ``\code{?}'' denotes a nullable type. Although \code{nil} as the singleton member of the \code{Nothing} type is a subtype of every type, Gear types are implicitly not-nullable, meaning that the language complains when the \code{nil} value is assigned to a variable whose type is not bound to be nullable. And it does so by issuing compile-time warnings and runtime warnings\footnote{In debug mode.} when the \code{nil} value is assigned to a type that is not nullable, including parameter assignment and result value assignment. This is due to the fact that the type \code{Nothing} conforms to any type that descends from \code{Any}, which is, well, any type. 

A block of code (or whole files or modules) may opt-in to behaviour that raises errors in runtime, instead of issuing warnings, using \code{pragma error_on_nil} inside the code block, file or module. 

If an implicit conversion from \code{Nothing} to $T$ is available, then nullability is not a problem. 

Nullable types in this form can appear everywhere where a type is expected. 

A nullable type may be seen as a syntax sugar for the following union type ~\code{Nullable[$T$]} (\sref{sec:unions}):
\begin{lstlisting}
type Nullable [T] is union of 
  T
  Nothing
end type
\end{lstlisting}

When a method is applied on a variable containing \code{nil}, the standard \code{Member_Not_Found} may occur, if the method is really not found in the class \code{Nothing} or in any of implicit conversions from \code{Nothing} (e.g., \code{Nothing} has an implicit conversion to the option type \code{None}). 

A strictly not-nullable type has the form ~\lstinline@$T$!@, where ``\code{!}'' denotes a not-nullable type. Gear types are implicitly not-nullable, but strictly not-nullable types have the extra property that \code{nil} and \code{undefined} do not cause a warning when assigned to a variable or value that is of a strictly not-nullable type, but raise a type error. In case the referenced value changes in runtime by other means than assignment (native access or maybe due to hot code load), the same error has to be raised. 

A compiler may decide to issue extra warnings when assignment of a \code{nil} or \code{undefined} can be detected. 

A strictly not-nullable may be seen as some implicitly wrapped-on-assignment / unwrapped-on-read box that checks for \code{value = nil} and raises an error when such condition is true. But Gear does not have any special methods for object dereference.\footnote{Yet, and probably never will.} 

When used in a compound type, use nullable modifier only on the first component. When used in a constrained type, use nullable modifier only on the component type of the constrained type. 





\subsection{Unions}
\label{sec:unions}

\syntax\begin{lstlisting}
Type_Representation ::= Is Union
Union               ::= 'union' 'of' Type {semi Type}
Infix_Type          ::= Type {'or' Type}
\end{lstlisting}

Union types represent multiple types, possibly unrelated. Union types are abstract by nature and can not be instantiated, only the types that they contain may, if these are instantiable. For type safety, bindings of union types should be matched for the actual type prior to usage. 

Unions are indeed virtually ``tagged'' with the actual type that they represent at the runtime moment, although when it comes to overloading resolution, the union type is used, as it is the expected type. 

The first syntax shows a named union type, while the second shows an anonymous union type (which may still be given a name later). If any of the types that are a part of a union type is a union type itself, the two types are merged. The syntax used for the anonymous version is correlating with infix type syntax, but this syntax gives it the meaning of a union type, which is preferred to infix type syntax. In fact, it might be implemented with an infix type that generates union types:

\begin{lstlisting}
type or [A, B] is Union[A, B]
\end{lstlisting}

Union types also employ the following set of rules, given some types \code{X}, \code{Y} and \code{Z}:
\begin{itemize}
  \item Commutativity: \code{X or Y} is equivalent to \code{Y or X}. 
  \item Associativity: \code{X or (Y or Z)} is equivalent to \code{(X or Y) or Z}, which is equivalent to \code{X or Y or Z}. 
  \item Simplification: if \code{X} conforms to \code{Y}, then \code{X or Y} is equivalent to \code{Y}. 
  \item Conformance: \code{X} conforms to \code{X or Y}. 
  \item Supertypes: if both \code{X} and \code{Y} conform to \code{Z}, then \code{X or Y} also conforms to \code{Z}. 
  
  \item \code{X or Nothing} is equivalent to \code{X} for any \code{X} except \code{Undefined}. 
  \item \code{X or Undefined} is equivalent to \code{X} for any \code{X}. 
  \item \code{X or Any} is equivalent to \code{Any} for any \code{X}. 
  
  \item If \code{X[T]} is covariant in the type parameter \code{T}, then \code{X[U] or X[V]} conforms to \code{X[U or V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
  \item If \code{X[T]} is contravariant in the type parameter \code{T}, then \code{X[U] or X[V]} conforms to \code{X[U with V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
\end{itemize}





\subsection{Intersection Types}
\label{sec:intersection-types}

\syntax\begin{lstlisting}
Type_Representation ::= Is 'intersection' 'of'
                        Type {semi Type}
Infix_Type          ::= Type {'and' Type}
\end{lstlisting}

An intersection type is a type that conforms to all types that it consists of. Any value that is an instance of all the types is also an instance of the intersection type. 

The difference between intersection types and compound types (\sref{sec:compound-types}) is that intersection types are commutative and associative -- independent on the order in which the member types appear. 


Intersection types also employ the following set of rules, given some types \code{X}, \code{Y} and \code{Z}:
\begin{itemize}
  \item Commutativity: \code{X and Y} is equivalent to \code{Y and X}. 
  \item Associativity: \code{X and (Y and Z)} is equivalent to \code{(X and Y) and Z}, which is equivalent to \code{X and Y and Z}. 
  \item Simplification: if \code{X} conforms to \code{Y}, then \code{X and Y} is equivalent to \code{X}. 
  \item Conformance: \code{X and Y} conforms to \code{X}. 
  \item Subtypes: if \code{Z} conforms to both type \code{X} and type \code{Y}, then \code{Z} also conforms to \code{X and Y}. 
  \item Distributivity over union: \code{X and (Y or Z)} is equivalent to \code{(X and Y) or (X and Z)}. 
  
  \item \code{X and Nothing} is equivalent to \code{Nothing} for any \code{X} except \code{Undefined}. 
  \item \code{X and Undefined} is equivalent to \code{Undefined} for any \code{X}. 
  \item \code{X and Any} is equivalent to \code{X} for any \code{X}. 
  
  \item If \code{X[T]} is covariant in the type parameter \code{T}, then \code{X[U and V]} conforms to \code{X[U] and X[V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
  \item If \code{X[T]} is contravariant in the type parameter \code{T}, then \code{X[U or V]} conforms to \code{X[U] and X[V]} for any types \code{U} and \code{V} that satisfy the type constraints of T. 
\end{itemize}








\subsection{Constrained Types}
\label{sec:constrained-types}

\syntax\begin{lstlisting}
Postfix_Type     ::= Compound_Type 
                     'with' 'constraint' Constraint_Block
Constraint_Block ::= '{' Block '}'
\end{lstlisting}

A constrained type constructs a subset of allowed members of its component type. Such a subset is defined as members for which the constraint block returns boolean \code{yes}. Constraints defined within the component type are implicitly available in such block as local variables. In case of concurrent changes in the member, the type may not match anymore -- a warning is issued when a constraint is applied to a member that is not frozen nor immutable. 

Constrained types, in face of overloading, trigger eager argument expression evaluation, so that the constrained type of a parameter can even be checked.\footnote{Therefore, constrained types are not really suitable candidates for parameters that are supposed to be lazy-evaluated, unless the early evaluation is intended.}

\paragraph{Note}
Constrained types are an implementation of {\em dependent types} in Gear. Dependent types are basically functions from values to types, where the value part is present in the defined constraint and/or the constraint block. 





\subsection{Mutable \& Immutable Types}
\label{sec:mutable-immutable-types}

Gear offers two annotations that can constrain a type to either {\em mutability} or {\em immutability}. Implicitly, types are not constrained in such a way, therefore a type could represent both mutable and immutable values at the same time. 

\paragraph{Mutable types}
A mutable type is expressed with the annotation \code{@[mutable]}, and is not transitive. It constrains a type to mutable values (i.e. not frozen), but not values referred to by the values it represents. 

\paragraph{Immutable types}
An immutable type is expressed with the annotation \code{@[immutable]}, and is transitive. It constrain a type to immutable values (i.e. frozen) and also requires that all values that are referred to by those immutable values to be also immutable, unless they are explicitly typed as mutable. 

\paragraph{Note}
See also section about storage of mutable and immutable values: (\sref{sec:mutable-immutable-storage}).

A \code{mutable} type can be seen as a constrained type, where the constraint is:
\begin{lstlisting}
$T$ with constraint { not self'is_frozen? }  ,
\end{lstlisting}
where \code{self} would be a constraint published by the type $T$, referring to the \code{self} of a value of the type $T$. 

An \code{immutable} type can be seen as a constrained type, where the constraint is:
\begin{lstlisting}
$T$ with constraint { self'is_frozen? }  ,
\end{lstlisting}
where \code{self} would be a constraint published by the type $T$, referring to the \code{self} of a value of the type $T$. 

If a mutable or immutable type is seen as a constrained type, but $T$ is already a constrained type, then the condition presented by the already constrained type $T$ can be seen without loss of generality as joined with the mutable/immutable constraint by \code{and}. 





\subsection{Foreign Types}
\label{sec:foreign-types}

\syntax\begin{lstlisting}
Simple_Type  ::= Foreign_Type
Foreign_Type ::= 'foreign' lang_name '{' 
                 printable_char_or_space {',' printable_char_or_space}
                 '}'
lang_name    ::= id
\end{lstlisting}

A {\em foreign type} is a tool that helps Gear programs integrate with other languages written for the same VM, the Gear VM. It is viewed as extending the type \code{Any}, can be given an alias name and be a part of a compound type with another foreign types or Gear types. 

\paragraph{Syntax note}
If an opening delimiter ``\lstinline!{!'' appears within the foreign language type name, then it is properly paired with the next ``\lstinline!}!'' by Gear and not treated as closing delimiter, but this is done without any knowledge of the foreign language, only presuming that these delimiters are paired. 

\paragraph{Parameterized foreign types}
If the foreign type is parameterized, it can be a part of a type application as well, but its type parameters are not declared neither defined on the Gear side. Also, the foreign language defines how the parameterization works -- e.g., Java does type erasure with its type parameters.

\example A foreign type aliases for a few foreign types:
\begin{lstlisting}
type Java_Object is foreign java {java.lang.Object} end type
type Java_int is foreign java {int} end type
type CS_Object is foreign `c#` {System.Object} end type
type Rb_Proc_Status is foreign ruby {Process::Status} end type
\end{lstlisting}







\section{Non-Value Types}

The types explained in the following paragraphs do not appear explicitly in programs, they are internal and do not represent any type of value directly. 






\subsection{Method Types}
\label{sec:method-types}

A method type is denoted internally as $(Ps) \mapsto R$, where $(Ps)$ is a sequence of types  $(p_1 : T_1 \commadots p_n : T_n)$ for some $n \geq 0$ and $R$ is a (value or method) type. This type represents named or anonymous methods that take arguments of types $T_1 \commadots T_n$ and return a result of type $R$. Types of parameters are possibly annotated with conformance restricting annotations (\sref{sec:annotations}). 

Method types associate to the right:\footnote{Like in Haskell or Scala.} \newline
$(Ps_1) \mapsto (Ps_2) \mapsto R$ is treated as $(Ps_1) \mapsto ((Ps_2) \mapsto R)$. 

A special case are types of methods without any parameters. They are written here as $() \mapsto R$. 

Another special case are types of methods without any result type. They are written here as $(Ps) \mapsto ()$. Methods that have this result type do not have an implicit return expressions and an attempt to return a value from it results in a compile-time error.\footnote{A compile-time error like this may happen during a runtime evaluation as well.}

Method types do not exist as types of values. If a method name is used as a value, its type is implicitly converted to a corresponding function type (\sref{sec:function-types}). 

Extra properties of parameters are as follows: a \lstinline@*@ for variadic parameters, \lstinline@**@ for any named parameters and \lstinline@&@ for a captured block parameter, or nothing for regular parameters. 

\example The declarations
\begin{lstlisting}
def a: -> Integer (* or def a () -> Integer *)
def b (x: Integer): Boolean
def c (x: Integer): (y : String, z : String) -> String
def d (~x: Integer): Integer
def e (*x: Integer): Integer
def f (x: Integer): Unit
def g (x: Integer)(y: Integer): Integer
def h (x: Integer): (y: Integer) -> Integer
\end{lstlisting}
produce the typings
\begin{lstlisting}
a : () $\mapsto$ Integer
b : (@[named :x] Integer) $\mapsto$ Boolean
c : (@[named :x] Integer) $\mapsto$ (y: String, z: String) $\mapsto$ String
d : (@[named :x] @[purely_named] Integer) $\mapsto$ Integer
e : (@[named :x] @[variadic] Integer) $\mapsto$ Integer
f : (@[named :x] Integer) $\mapsto$ Unit
g : (@[named :x] Integer) $\mapsto$ (@[named :y] Integer) $\mapsto$ Integer
h : (@[named :x] Integer) $\mapsto$ (@[named :y] Integer) $\mapsto$ Integer
\end{lstlisting}

The difference between the ``\code{g}'' and ``\code{h}'' functions is that using the chain of result types as in function ``\code{g}'', the function body is automatically curried to return a function that is of type \lstinline@(Integer) $\mapsto$ Integer@. With the function ``\code{h}'', currying has to be implemented manually. 






\subsection{Polymorphic Method Types}
\label{sec:polymorphic-method-types}

A polymorphic method type is the same as a regular method type, but enhanced with a type parameters section. It is denoted internally as \lstinline@[$\tps$]$ \mapsto T$@, where \lstinline@[$\tps$]@ is a type parameter section ~\lstinline@[$\pm a_1$ >: $L_1$ <: $U_1$ $\commadots$ $\pm a_n$ >: $L_n$ <: $U_n$]@ for some $n \geq 0$ and $T$ is a (value or method) type. This type represents (only\footnote{Not anonymous.}) named methods that take type arguments $S_1 \commadots S_n$, for which the lower bounds $L_1 \commadots L_n$ conform (\sref{sec:conformance}) to the type arguments and the type arguments conform and the upper bounds $U_1 \commadots U_n$ and that yield results of type $T$. No explicit lower bound implies \code{Nothing} to be the corresponding lower bound, no explicit upper bound implies \code{Object} to be the corresponding upper bound. As usual, lower bound must conform to the corresponding upper bound. 

\example The declarations
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
def empty[A]: List[A]
def union[A <: Comparable[A]] (x : Set[A], 
         xs : Set[A]): Set[A]
\end{lstlisting}
produce the typings
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
empty : [A >: Nothing <: Any] () $\mapsto$ List[A]
union : [A >: Nothing <: Comparable[A]] (Set[A], 
        Set[A]) $\mapsto$ Set[A]
\end{lstlisting}






\subsection{Type Constructors}
\label{sec:type-constructors}

A type constructor is in turn represented internally much like a polymorphic method type. \lstinline@[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto T$@ represents a type that is expected by a type constructor parameter. The difference is that the represented internal entity is not a method, but a type, creating higher-kinded types. 






\section{Base Types \& Member Definitions}
\label{sec:base-types}
\label{sec:member-definitions}

Types of class members depend on the way the members are referenced. Central here are these notions:
\begin{enumerate}
\item The notion of the set of base types of a type $T$.
\item The notion of a type $T$ in some class $C$ seen from some prefix type $S$.
\item The notion of the set of member bindings of some type $T$. 
\end{enumerate}

These notions are defined mutually recursively as follows. 

\begin{enumerate}

\item
The set of {\em base types} of a type is a set of class types, given as follows.
\begin{itemize}
\item The base types of a class type $C$ with parents $T_1 \commadots T_n$ are $C$ itself, as well as the base types of the compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$!. 

\item The base types of an aliased type are the base types of its alias. 

\item The base types of an abstract type\footnote{E.g. type members.} are the base types of its upper bound. 

\item The base types of a parameterized type ~\lstinline!$C$[$T_1 \commadots T_n$]!~ are the base types of type $C$, where every occurence of a type parameter $a_i$ of $C$ has been replaced by the corresponding parameter type $T_i$. 

\item The base types of a compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$ with { $R$ }!~ are set of base classes of all $T_i$'s. 

\item The base types of a type projection ~\lstinline!$S$#$T$!~ are determined as follows: If $T$ is an alias or an abstract type, the previous clauses apply. Otherwise, $T$ must be a (possibly parameterized) class type, which is defined in some class $B$. Then the base types of ~\lstinline!$S$#$T$!~ are the base types of $T$ in $B$ as seen from the prefix type $S$. 

\item The base types of an existential type ~\lstinline!$T$ for-some { $Q$ }!~ are all types ~\lstinline!$S$ for-some { $Q$ }!, where $S$ is a base type of $T$. 
\end{itemize}

\item
The notion of a type {\em $T$ in class $C$ seen from some prefix type $S$} makes sense only if the prefix type $S$ has a type instance of class $C$ as a base type, say ~\lstinline!$S'$#$C$[$T_1 \commadots T_n$]!. Then we define it as follows.
\begin{itemize}
\item If ~\lstinline!$S$ = $\epsilon$.type!, then $T$ in $C$ seen from $S$ is $T$ itself. 

\item Otherwise, if $S$ is an existential type ~\lstinline!$S'$ for-some { $Q$ }!, and $T$ in $C$ seen from $S'$ is $T'$, then $T$ in $C$ seen from $S$ is ~\lstinline!$T'$ for-some { $Q$ }!. 

\item Otherwise, if $T$ is the $i^{\superth}$ type parameter of some class $D$, then:
\begin{itemize}
\item If $S$ has a base type ~\lstinline!$D$[$U_1 \commadots U_n$]!, for some type parameters $U_1 \commadots U_n$, then $T$ in $C$ seen from $S$ is $U_i$. 
\item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
\item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
\end{itemize}

\item Otherwise, if $T$ is the singleton type ~\lstinline!$D$.self.type!~ for some class $D$, then:
\begin{itemize}
\item If $D$ is a subclass of $C$ and $S$ has a type instance of class $D$ among its base types, then $T$ in $C$ seen from $S$ is $S$. 
\item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
\item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
\end{itemize}

\item
If $T$ is some other type, then the described mapping is performed on all its type components. 

\end{itemize}

If $T$ is a possibly parameterized class type, where $T$'s class is defined in some other class $D$, and $S$ is some prefix type, then we use ``$T$ seen from $S$'' as a shorthand for ``$T$ in $D$ seen from $S$''. 

\item
The {\em member bindings} of a type $T$ are:
\begin{enumerate}
\item All bindings $d$, such that there exists a type instance of some class $C$ among the base types of $T$ and there exists a definition or declaration of $d'$ in $C$, such that $d$ results from $d'$ by replacing every type $T'$ in $d'$ with $T'$ in $C$ seen from $T$.
\item All bindings of the type's refinement (\sref{sec:compound-types}), if it has one. 
\end{enumerate}

The definition of a type projection ~\lstinline!$S$#$t$!~ is the member binding $d_t$ of the type $t$ in $S$. In that case, we also say that {\em ~\lstinline!$S$#$t$!~ is defined by $d_t$}. 

\end{enumerate}







\section{Any-Value Type}
\label{sec:any-value-type}

\syntax\begin{lstlisting}[morekeywords={Any}]
Simple_Type ::= 'Any'
(* also: *)
Simple_Type ::= 'Gear/Language.Any'
\end{lstlisting}

This type does not represent a single concrete value type, but any concrete type. It is used in places where the actual type does not matter, and could be even from other language running along Gear in the VM. 

With respect to overloading resolution (\sref{sec:value-conversions}), this type is always the least specific, as there is no other less specific type available. 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Any} is used as a class type (never a trait type).

The \code{Any} identifier is not reserved for the language as a keyword, instead, it gets usually automatically imported with the \code{Language} module, and therefore can be shadowed and aliased (e.g. to \code{Any_Object}). 

The \code{Any} virtual type is the actual root of the type system of Gear, although explicit inheritance is not allowed from it. Other languages that integrate with Gear on the same VM may have \code{Any} as their root type as well, disobeying the rule that is set only for Gear. This way, Gear preserves its unified type system. 





\section{Automatically Inferred Type}
\label{sec:auto-type}

\syntax\begin{lstlisting}[morekeywords={Auto}]
Simple_Type ::= 'Auto'
(* also: *)
Simple_Type ::= 'Gear/Language.Auto'
\end{lstlisting}

See ({\sref{sec:automatic-inference}}).

This type does represent a single concrete value type: a compound type with usually just the refinement part. However, it does not explicitly state what the refinement is. Instead, the refinement is inferred from the context in which it is used. The inference algorithm is very different from local type inference (\sref{sec:local-type-inference}). 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Auto} is used as a class type (never a trait type) and its parts of the inferred refinement are merged with any given refinement from the compound type. 

The \code{Auto} identifier is not reserved for the language as a keyword, instead, it gets usually automatically imported with the \code{Language} module, and therefore can be shadowed and aliased (e.g. to \code{Inferred}). 

If a type variable of the form ~\lstinline!'$x$! is not present in the type parameters list, then it is a placeholder for the \code{Auto} type with a name $x$, also generating type equality constraints, if used more than once across parameters or result type -- for every type parameter name $x_i$, an equivalent type has to be inferred for every occurrence of $x_i$. 

See (\sref{sec:automatic-inference}) for details on (non-local) automatic type inference. 

There is one important limitation: the \code{Auto} type must not cause circular references between functions. In that case, the type has to be specified in another way. This inference happens only during compilation, unlike local type inference, which takes place in runtime. 

This kind of type inference is useful when a method only cares about actually used capabilities of it's parameters. In that way, it is similar to protocols, but only includes those capabilities that are actually used. Note that in runtime, test of structural types (refinements) is somewhat slower than simple type test, depending on the amount of members present in the refinement of the resulting compound type. This is common to compound types, where the test needs to check all components and not just one. 

\example An automatically generalized swap function.
\begin{lstlisting}
def swap (x: Auto, y: Auto): Auto
  (y, x)
end
\end{lstlisting}
This is inferred and generalized into the following polymorphic function:
\begin{lstlisting}
def swap [A, B] (x: A, y: B): (B, A)
  (y, x)
end
\end{lstlisting}
This inference and generalization is possible, because no other requirements are imposed on the values \code{x} and \code{y} and the result type is unaffected either. 

\example An automatically inferred function.
\begin{lstlisting}
def print (x: Auto): Unit
  IO.console.print x.to_string
end
\end{lstlisting}
This is inferred into the following function:
\begin{lstlisting}
def print (x: { def to_string (): String end }): Unit
  IO.console.print x.to_string
end
\end{lstlisting}
This happens because the only requirement on \code{x} is that it has a method \code{to_string} that accepts no arguments (could be variadic either), which is a requirement from the function body, and that method returns a \code{String}, which is a known requirement of parameter type of the \code{IO.console.print} function. Note that the refinement type is equivalent to:
\begin{lstlisting}
Any with refinement { def to_string (): String end }
\end{lstlisting}

\example Another automatically inferred function.
\begin{lstlisting}
def print (x: Auto): Unit
  IO.console.print x
end
\end{lstlisting}
This is inferred into the following function:
\begin{lstlisting}
def print (x: String): Unit
  IO.console.print x
end
\end{lstlisting}
Here, the only requirement on the value \code{x} comes from a known requirement of parameter type of the \code{IO.console.print} function. In fact, if \code{IO.console.print} had several overloaded variants, then the type of \code{x} would be inferred to be a union type of all the overloaded variants' requirements on it. 

By default, when a type annotation is missing in a function declaration, then it is either inherited (based on overriding), or taken to be \code{Auto}. A pragma (\sref{sec:pragmas}) exists to modify this default behaviour: to use other type in place of missing type annotation, use ~\lstinline!pragma missing_type $T$!, where $T$ can be also \code{Any}, or any other type, like \code{Object} and even \code{Dynamic} (\sref{sec:dynamic-type}). 

Note that \code{Auto} type inference does not track requirements of values from their usage within other methods.






\section{Dynamic Type}
\label{sec:dynamic-type}

\syntax\begin{lstlisting}[morekeywords={Dynamic}]
Simple_Type ::= 'Dynamic'
(* also: *)
Simple_Type ::= 'Gear/Language.Dynamic'
\end{lstlisting}

This type does not represent a single concrete value type\footnote{This type is similar to what ~\lstinline[language={[Sharp]C}]!dynamic!~ is to C\#.}, but any concrete type, very much like \code{Any} or \code{Auto}. 

In runtime, this type is always dynamically replaced by the type of the actual referenced value -- e.g., if a variable is typed with \code{Dynamic} type, assigned a value, and used in a function application, the type of that value is used, not \code{Dynamic}, unless it would be typed with \code{Any} again (\sref{sec:typed-expressions}). Nonetheless, this does not imply that a value of another type can not be assigned to that same variable -- such variable is still bound to \code{Dynamic} and accepts \code{Any} type. 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Dynamic} is used as a trait type.\footnote{Thus, if \code{Dynamic} is used in a compound type, the compound type can contain a class type that is not \code{Dynamic}. This is different from \code{Any}, which can only appear as a class type.}

With respect to overloading resolution (\sref{sec:overloading-resolution}), this type is almost\footnote{The type annotation would have to 1:1 copy the runtime type to be the same specific, but no explicit type annotation can ever be more specific.} always the most specific, as it is replaced by the actual runtime type of the value it is assigned to. 

Typing an expression with this type triggers early evaluation, which is important to know if the expression is an argument expression and its corresponding parameter is lazily evaluated. 

If the \code{Dynamic} type is used as the type annotation of a parameter, it is translated to \code{Any} (plus additional structural constraints, if any present), and treated as \code{Dynamic} in the following code.

The \code{Dynamic} type is disallowed from use within type parameters, result types and conformance check expressions (\sref{sec:typed-expressions}). 

Using \code{Dynamic} type is one of possible ways to use multi-methods -- the type of arguments typed as \code{Dynamic} are bound at runtime, not during compilation. Moreover, the two approaches can be combined, as not every argument expression needs to be \code{Dynamic}.





\section{Variadic Arguments Type}
\label{sec:varargs-type}

\syntax\begin{lstlisting}[morekeywords={Dynamic}]
Simple_Type ::= 'Variadic_Arguments'
(* also: *)
Simple_Type ::= 'Gear/Language.Variadic_Arguments'
\end{lstlisting}

This type is recognized only as a parameter type (be it a function, constructor\ldots), and with a further constraint that it has to be applied to a solely parameter of a whole parameter list. Such parameter list must be the last parameter list of a definition or declaration, and there might be more parameter lists present preceding it. 

When applied to a parameter, the parameter then consumes a tuple of every consecutive argument list with all arguments in a tuple, possibly with named members, if the arguments were passed in as named arguments. If a block argument is also given, it is present in the last tuple element, under the last nested tuple element, named ``\,\lstinline!`&`!\,''. Any possible arguments combination is applicable to this type, it consumes virtually anything. The types of the tuples per each argument list are to be inspected at runtime dynamically. 

The parameter that receives this tuple of tuples is typed as if it was:
\begin{lstlisting}
(($T_1 \commadots T_j$), ($T_{j+1} \commadots T_k$)$\commadots$($T_l \commadots T_n$))  ,
\end{lstlisting}
where each $T$ has a type that is retrieved as a function type ~\lstinline!() -> $U$!, where $U$ is the type available at function application time. The runtime is however not required to absolutely convert all arguments into functions (that would not be very efficient), but it can (and should) presume that all arguments are passed by-name, and then the function can evaluate them as appropriate. The function notion is there mostly for user programs that do not have access to the native representation, so that it can decide which arguments to treat as by-name and which by-value, as there is no implicit ``function application'' of by-name parameters. 

This type does not represent by itself any concrete value type, instead, it represents a whole class of them (two-dimensional tuples of variable lengths, basically). 

If no arguments are passed to a function that accepts this parameter type, a \code{Unit} value (\lstinline!()!) is used. The \code{Unit} value is also used for matched arguments list that carry no argument expressions. As a special case, when only one argument list is matched, the type is \code{Tuple_1}, a type that is generally avoided throughout Gear (e.g., ~\lstinline!($e$ as $T$)!~ is not of type ~\lstinline!Tuple_1[$T$]!, but just $T$), as its contents can be implicitly unwrapped, but here it is needed to keep the semantics consistent. 

\paragraph{Note}
This type is used e.g. within the \code{Language.Object.new} method, so that it can select the appropriate constructor (and perhaps does so natively on each Gear VM). 







\section{Relations Between Types}

We define two relations between types. 
\begin{quote}\begin{tabular}{l@{\gap}l@{\gap}l}
\em Type equivalence & $T \equiv U$ & $T$ and $U$ are interchangeable
in all contexts.
\\
\em Conformance & $T \conforms U$ & Type $T$ conforms to type $U$.
\end{tabular}\end{quote}






\subsection{Type Equivalence}

Equivalence ($\equiv$) between types is the smallest congruence, such that the following statements are true:

\begin{itemize}
\item
If $t$ is defined by a type alias ~\lstinline@type t := T@, then $t$ is equivalent to $T$. 

\item
If a path $p$ has a singleton type ~\lstinline@$q$.type@, then \lstinline@$p$.type $\equiv\ q$.type@. 

\item
Two compound types (\sref{sec:compound-types}) are equivalent, if the sequences of their components are pairwise equivalent, occur in the same order and their refinements are equivalent.

\item
Two constrained types (\sref{sec:constrained-types}) are equivalent, if their base types are equivalent and their constraint blocks read the same. 

\item
Two refinements (\sref{sec:compound-types} \& \sref{sec:refinements}) are equivalent, if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements. 

\item
Two method types (\sref{sec:method-types}) are equivalent, if they are {\em override-equivalent} (\sref{sec:method-signature}).

\item
Two polymorphic method types (\sref{sec:polymorphic-method-types}) are equivalent, if they have the same number of type parameters, the result types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\item
Two existential types (\sref{sec:existential-types}) are equivalent, if they have the same number of quantifiers and the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent. 

\item
Two type constructors (\sref{sec:type-constructors}) are equivalent, if they have the same number of type parameters, the result types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\item 
Two unions (\sref{sec:unions}) are equivalent, if they have the same number of member types and those types are pairwise equivalent. 

\item 
Two intersection types (\sref{sec:intersection-types}) are equivalent, if they have the same number of member types and those types are pairwise equivalent. 

\end{itemize}






\subsection{Conformance}
\label{sec:conformance}

The conformance relation $(\conforms)$ is the smallest transitive relation that satisfies the following conditions:

\begin{itemize}

  \item Conformance includes equivalence, therefore if $T \equiv U$, then \lstinline@$T \conforms U$@. 

  \item For every value type $T$, \lstinline!Undefined $\conforms$ Nothing $\conforms T \conforms$ Object $\conforms$ Any!. 
 
  \item For every type constructor $T$ with any number of type parameters, \lstinline!Undefined $\conforms$ Nothing $\conforms T \conforms$ Object $\conforms$ Any!. 

  \item A type variable $t$ conforms to its upper bound and its lower bound conforms to $t$. 

  \item A class type or a parameterized type conforms to any of its base types. 

  \item A class type or a parameterized type conforms to a union type, iff it conforms to at least one of the union's component types. 

  \item  A singleton type ~\lstinline!$p$.type!~ conforms to the type of the path $p$.

  \item A type projection ~\lstinline!$T$#$t$!~ conforms to ~\lstinline!$U$#$t$!~ if $T$ conforms to $U$. 

  \item A unit of measure type $t$ conforms to another unit of measure type $u$ if and only if $t \equiv u$ or $t$ extends $u$, where $us$ is an abstract unit of measure type. 

  \item A parameterized type ~\lstinline!$T$[$T_1 \commadots T_n$]!~ conforms to ~\lstinline!$T$[$U_1 \commadots U_n$]!~ if the following conditions hold for $i = 1 \commadots n$.
    \begin{itemize}
      \item If the $i^{\superth}$ type parameter of $T$ is declared covariant, then $T_i \conforms U_i$.
      \item If the $i^{\superth}$ type parameter of $T$ is declared contravariant, then $U_i \conforms T_i$.
      \item If the $i^{\superth}$ type parameter of $T$ is declared invariant (neither covariant nor contravariant), then $U_i \equiv T_i$.
      \item If the $i^{\superth}$ type parameter of $T$ is declared with a conformance restricting annotation, then that annotation of $T_i$ must conform to the corresponding annotation of $U_i$. 
    \end{itemize}
    
  \item A constant constructor $T$ of a variant type $U$ (\sref{sec:variant-types}) conforms to $U$. If $U$ is a parameterized variant type, $T$ still conforms to $U$, even though it itself is not parameterized. 
  
  \item A non-constant constructor $T$ of a variant type $U$ (\sref{sec:variant-types}) conforms to $U$. If $U$ is a parameterized variant type, then $T$ conforms to $U$ if $T$ seen as a parameterized type conforms to parameterized $U$\footnote{Quite obviously.}. 

  \item A unit of type $N$ conforms to unit of type $U$ if $N$ extends $U$ or if $N \equiv U$. 

  \item A parameterized type ~\lstinline!$T$[<$N_1 \commadots N_n$>]!~ conforms to ~\lstinline!$T$[<$U_1 \commadots U_n$>]!~ if the following conditions hold for $i = 1 \commadots n$.
    \begin{itemize}
      \item For the $i^{\superth}$ type parameter of $T$, $N_i \conforms U_i$.
    \end{itemize}

  \item A compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$ with { $R$ }!~ conforms to each of its component types $T_i$.
  
  \item Conformance of intersection types is defined in (\sref{sec:intersection-types}).

  \item A constrained type ~\lstinline!$T$ with constraint $b$!~ conforms to $T$. A type ~\lstinline!$T$ with constraint $b_1$!~ conforms to ~\lstinline!$T$ with constraint $b_2$!, if any value $e$ that conforms ~\lstinline!$T$ with constraint $b_1$!~ by being a member of $T$ and passing the test presented by $b_1$, also conforms to ~\lstinline!$T$ with constraint $b_2$!~ by passing the test presented by $b_2$.\footnote{This conformance is only tested based on actual values being tested, not the types themselves.}

  \item If $T \conforms U_i$ for $i = 1 \commadots n$, and every binding $d$ of a type or value $x$ in $R$ exists a member binding of $x$ in $T$ which subsumes $d$, then $T$ conforms to the compound type ~\lstinline!$U_1$ with $\ldots$ with $U_n$ with { $R$ }!. 

  \item The existential type ~\lstinline!$T$ for-some { $Q$ }!~ conforms to $U$, if its skolemization (\sref{sec:existential-types}) conforms to $U$. This also means that the $t'_i$ type variables have to fall in between $U$'s type parameter bounds. 

  \item The type $T$ conforms to the existential type ~\lstinline!$U$ for-some { $Q$ }!~ if $T$ conforms to at least one of the type instances (\sref{sec:existential-types}) of ~\lstinline!$U$ for-some { $Q$ }!. 

  \item If $T_i \equiv T'_i$ for $i = 1 \commadots n$ and $R \conforms R'$, then the method type ~\lstinline!($p_1$: $T_1 \commadots p_n$: $T_n$) $\mapsto\ R$!~ conforms to ~\lstinline!($p'_1$: $T'_1 \commadots p'_n$: $T'_n$) $\mapsto\ R'$!. 

  \item The polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto\ T$
\end{lstlisting}
conforms to the polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L'_1$ <: $U'_1 \commadots \pm a_n$ >: $L'_n$ <: $U'_n$] $\mapsto\ T'$
\end{lstlisting}
if one has $T \conforms T'$, and $L_i \conforms L'_i$ and $U_i \conforms U'_i$ for $i = 1 \commadots n$. 

  \item Polymorphic types or type constructors $T$ and $T'$ must also fulfill the following. We characterize $T$ and $T'$ by their type parameter clauses ~\lstinline![$a_1 \commadots a_n$]!~ and ~\lstinline![$a'_1 \commadots a'_n$]!, where an $a_i$ or $a'_i$ may include a variance annotation, annotations, a higher-order type parameter clauses, and bounds. Then, $T$ conforms to $T'$ if any list ~\lstinline![$t_1 \commadots t_n$]!---with declared variances, annotations, bounds and higher-order type parameter clauses---of valid type arguments for $T'$ is also a valid list of type arguments for $T$ and ~\lstinline!$T$[$t_1 \commadots t_n$] <: $T'$[$t_1 \commadots t_n$]!. Note that this entails that:
  \begin{itemize}
    \item The bounds on $a_i$ must be the same or weaker than the corresponding bounds declared for $a'_i$. 
    \item The variance of $a_i$ must match the variance of $a'_i$, where covariance matches covariance, contravariance matches contravariance and any variance matches invariance. 
    \item If annotation of $a'_i$ restricts conformance (\sref{sec:annotations}), then the corresponding annotation of $a_i$ must conform to it. 
    \item Recursively, these restrictions apply to the corresponding higher-order type parameter clauses of $a_i$ and $a'_i$. 
  \end{itemize}

  \item A function type ~\lstinline!($T_1 \commadots T_n$) -> $R$!~ (name it $f$) conforms to a function type ~\lstinline!($T'_1 \commadots T'_m$) -> $R'$!~ (name it $f'$), if types of arguments that are applicable to $f'$ are also applicable to $f$ (\sref{sec:function-applications}), and if $R$ conforms to $R'$. This includes reordering of named arguments/parameters and handling of repeated/optional parameters, and also variances -- since although $f$ might be applied to whatever $f'$ might be applied to, $f'$ might not be applied to whatever $f$ might be applied to (and vice versa).

  \item Polymorphic function traits ~\lstinline!Function_$n$!~ and ~\lstinline!Partial_Function!~ follow the rules for conformance of function types, as defined above. The repeated parameter, optional parameters, named parameters and all capturing parameters are derived from their conformance restricting annotations (\sref{sec:annotations}). Note that optional parameters may not be expressed with function types in another than with an annotation. The rules may be inverted in the means of constructing a virtual methods $m$ and $m'$ that are reconstructed from the type arguments of the function types $f$ and $f'$ respectively, and applying the rules for function types on them.
 
  \item A union type (\sref{sec:unions}) $U_1$ conforms to $U_2$, if every member type that is present in $U_2$ has also an equivalent member type in $U_1$. $U_1$ may thus contain more member types than $U_2$, but must contain all of member types in $U_2$. See also: (\sref{sec:unions}).

  \item An overloaded type projection conforms to type of every overloaded alternative. 
\end{itemize}

A declaration or definition in some compound type of class type $C$ {\em subsumes} another declaration of the same name in some compound type or class type $C'$, if one of the following conditions holds. 
  \begin{itemize}
  \item A value declaration or definition that defines a name $x$ with type $T$ subsumes a value or method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
  \item A method declaration or definition that defines a name $x$ with type $T$ subsumes a method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
  \item A type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] := $T$!~ subsumes a type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] := $T'$!~ if $T \equiv T'$. 
  \item A type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!~ subsumes a type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L'$ <: $U'$!, if $L' \conforms L$ and $U \conforms U'$. 
  \item A type or class definition that binds a type name $t$ subsumes an abstract type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!, if $L \conforms t \conforms U$. 
  \end{itemize}

The ($\conforms$) relation forms partial order between types, i.e. it is transitive, antisymmetric and reflexive. The terms {\em least upper bound} and {\em greatest lower bound} of a set of types are understood to be relative to that order. 

\paragraph{Note}
The least upper bound or the greatest lower bound of a set of types does not always exist. Gear is free to reject a term which has a type specified as a least upper bound or a greatest lower bound, and that bound would be more complex than a preset limit, e.g. this could happen with infinite bounds sequence. 

The least upper bound or the greatest lower bound might also not be unique. If there are several such bounds, Gear is free to pick up any of them. 




\subsection{Least Upper Bound}
\label{sec:least-upper-bound}

The term {\em least upper bound} of a set of types (and the closely related term {\em weak least upper bound} of a set of types) have two possible representations. 

\begin{itemize}
  \item {\em Common supertype representation}. This approach selects one compound type that is a common supertype of all types in the set. 
  \item {\em Union type representation}. This approach simply makes a union type (\sref{sec:unions}) out of all types in the set. 
\end{itemize}

Gear implicitly uses the union type representation for least upper bounds. The union type already presents quite a few simplifications of itself. This behaviour can be changed per-scope, per-file or even per-module, using a pragma:
\begin{lstlisting}
pragma least-upper-bound(.Union)  (* implicit *)
pragma least-upper-bound(.Common) (* optionally *)
\end{lstlisting}
These pragmas are a part of Gear's \code{Language} module. % TBD: specify where these pragmas are exactly located




\subsection{Weak Conformance}
\label{sec:weak-conformance}

For now, {\em weak conformance} is a relation defined on members of the \code{Number} type as a relaxation of conformance, written as $S \conforms _w T$. The relation is simple: a type $t$ weakly conforms to another type $u$ when $u$'s size contains all values of $t$ (we say that $t$ can be converted to $u$ without precision loss). 

A {\em weak least upper bound} is a least upper bound with respect to weak conformance. 





\section{Reified Types}
\label{sec:reified-types}

Unlike in Java or Scala, {\em type erasure} does not exist in Gear. Instead, type arguments are {\em reified} -- meaning that they persist in runtime. This is achieved by generating a lightweight subtype of parameterized types, containing basically just a reference to the parameterized type and a tuple of type arguments. This also implies that each new combination of type arguments to the exact same parameterized type creates a new lightweight subtype.

Reified types have some major effects on programs in Gear:
\begin{itemize}

\item Type arguments are accessible in runtime. The actual type argument can be inspected via reflection. 

\item Type arguments do not go away after compilation. This means, for example, that mutable collections should have invariant type parameters, since a hypothetical \code{List[+T]} can have type instance \code{List[String]} assigned to a variable bound to be a \code{List[Object]}, but instances of other subclasses than those that conform to \code{String} will not be able to be added to the collection. This is in fact true even if Gear did have type erasure -- the difference is, with reified types, the addition of a new incompatible value will fail immediately, unlike with type erasure, where retrieving the added value would fail later. 
\end{itemize}





\section{Types Representing Emptiness}
\label{sec:emptiness}

In Gear, there are a few types and their values that represent emptiness of some sort. The following lists specifies their semantical purposes. 

\begin{enumerate}
  \item The \code{Nothing} type. It represents a missing object in places where an object is expected. 
  
  The type has just one inhabitant, and that is the frozen \code{nil} value. In a Gear VM, this type is usually an immediate value. 
  
  \item The \code{Undefined} type. It represents a missing object in places where an object is expected, but its source is not defined. This applies to non-defined instance variables, undefined variables, or undefined mappings in, e.g., \code{Map} implementations. 
  
  The type has just one inhabitant, and that is the frozen \code{undefined} value, which is equal to, but not identical to \code{nil}. In a Gear VM, this type is usually an immediate value.
  
  The semantical difference between a \code{nil} and \code{undefined} in context of, e.g., \code{Map} implementations is that \code{nil} is returned if the map contains the given key, but has \code{nil} assigned to it on purpose, whereas \code{undefined} means there was no mapping defined. 
  
  Gear forbids access to undefined local variables during compilation, unlike e.g. JavaScript. 
  
  \item The \code{None} case object. It is a subtype of \code{Option[$T$]} and represents the exact same thing as \code{Nothing}, but has the extra semantical meaning of ``being ready to handle missing values'', which non-nullable types do not represent -- those expect a value to be present and cause errors when it is not present. 
  
  The \code{None} case object is primarily designed to be used with pattern matching, and also plays an important internal part in Gear's implementation of pattern matching. 
  
  Implicit conversion (\sref{sec:implicit-conversions}) from \code{Nothing} and \code{Undefined} to \code{Option[$T$]} is defined in \code{Language.Predef}, and results in \code{None}. 
  
  \item The \code{Unit} type. It is basically a \code{Tuple_0} type. 
  
  It's semantical meaning is that no value is even expected. It is used for functions that should never return any value, and that are technically procedures, whose purpose lies in side-effects. 
  
  The type has just one inhabitant, the ``\code{()}'' value, also known as an empty tuple. In a Gear VM, this type is usually an immediate value.
  
  There are no implicit conversions from \code{Unit} to any other type defined by Gear. 
\end{enumerate}

The following lines show some common relations between empty values. 
\begin{lstlisting}
nil = undefined  (* yes *)
nil == undefined (* no *)
nil = None       (* no *)
undefined = None (* no *)
() = undefined   (* no *)
() = nil         (* no *)

Nothing === nil         (* yes *)
Nothing === undefined   (* yes *)
Nothing === ()          (* no *)
Undefined === nil       (* no *)
Undefined === undefined (* yes *)
Undefined === ()        (* no *)
Unit === nil            (* no *)
Unit === undefined      (* no *)
Unit === ()             (* yes *)

val nothing := nil
match nothing {
  when Some(x) then () (* does not match *)
  when None then ()    (* matches *)
}

val nothing := get_undefined (* a function that returns `undefined' *)
match nothing {
  when Some(x) then () (* does not match *)
  when None then ()    (* matches *)
}

val unit = ()
match unit {
  when Some(x) then () (* does not match, 
                          also compilation warning, because Unit 
                          is not compatible to Option[T] *)
  when None then ()    (* does not match, also not compatible *)
  when Unit then ()    (* matches *)
}
\end{lstlisting}







