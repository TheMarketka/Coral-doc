%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Expressions}

% TBD: update this chapter and the syntax gradually as the CLS evolves

\syntax\begin{lstlisting}
Expr        ::= Cond_Expr
              | Loop_Expr
              | Rescue_Expr
              | Raise_Expr
              | Throw_Expr
              | Catch_Expr
              | Return_Expr
              | Assign_Expr
              | Update_Expr
              | Yield_Expr
              | Infix_Expr
              | Simple_Expr
              | Match_Expr
              | Binding
              | Annot_Expr
              | Cast_Expr
              | Use_Expr
              | Jump_Expr
              | Anon_Fun
              | Anon_Class
              | Metaclass_Access
              | Workflow_Expr
Infix_Expr  ::= Prefix_Expr
              | Infix_Expr [op_id Infix_Expr]
Simple_Expr ::= Block_Expr
              | ['&'] Simple_Expr1
              | '&' '(' Simple_Expr1 ')'
Result_Expr ::= Anon_Params '->' Block 
              | ['memoize'] Expr
\end{lstlisting}

Expressions are composed of various keywords, operators and operands. Expression forms are discussed subsequently. 







\section{Expression Typing}

The typing of expressions is often relative to some {\em expected type} (which might be undefined). When we write ``expression $e$ is expected to conform to type $T$'', we mean:
\begin{enumerate}
\item The expected type of $e$ is $T$.
\item The type of expression $e$ must conform to $T$. 
\end{enumerate}

Usually, the type of the expression is defined by the last element of an execution branch, as discussed subsequently with each expression kind. 

What we call ``statement'', in context of Coral is in fact yet another kind of an expression, and those expressions themselves always have a type and a value. 





\section{Literals}

\syntax\begin{lstlisting}
Simple_Expr1 ::= literal
\end{lstlisting}

Typing of literals is as described in (\sref{sec:literals}); their evaluation is immediate, including non-scalar literals (collection literals). 






\subsection{The Nil Value}

\syntax\begin{lstlisting}
Simple_Expr1 ::= 'nil'
\end{lstlisting}

The \code{nil} value is of type \code{Nothing}, and is thus compatible with every type that is nullable (\sref{sec:nullability}), either preferably or explicitly.

The \code{nil} represents a ``no object'', and is itself represented by an object. This object overrides methods in \code{Object} as follows: 
\begin{itemize}
\item 
\lstinline!equals($x$)! and \lstinline!=($x$)! return \code{yes} if the argument $x$ is also the \code{nil} object. 

\item 
\lstinline@!=($x$)@ return \code{yes} if the argument $x$ is not the \code{nil} object.

\item
\lstinline[mathescape=false]!as_instance_of[$T]()! returns always \code{nil}. 

\item
\lstinline!hash_code()! returns \code{0}. 
\end{itemize}

A reference to any other member of the \code{nil} object causes \code{Method_Not_Found_Error} or \code{Member_Not_Found_Error} to be raised, unless the member in fact exists.\footnote{It is even possible to use a refinement to actually implement some methods of \code{nil} locally (preferred approach), or globally implement those methods (discouraged, causes warnings).} 






\section{Designators}
\label{sec:designators}

\syntax\begin{lstlisting}
Simple_Expr1 ::= Path
               | '(' Anon_Class ')' '.' Selection
               | Simple_Expr '.' Selection
Selection    ::= ['?'] (importable_id | variable_id)
\end{lstlisting}

A designator refers to a named term. It can be a {\em simple name} or a {\em selection}.

A simple name $x$ refers to a value as specified in (\sref{sec:identifiers-names-scopes}). If $x$ is bound by a definition or a declaration in an enclosing class or object $C$, it is taken to be equivalent (at the resolution time) to the selection ~\lstinline!$C$.self.$x$!, where $C$ is taken to refer to the class or object containing $x$, even if the type name $C$ is shadowed at the occurrence of $x$. 

If $r$ is a stable identifier (\sref{sec:type-paths}) of type $T$, the selection ~\lstinline!$r$.$x$!~ refers to a member $m$ of $r$ that is identified in $T$ by the name $x$. 

For other expressions $e$, ~\lstinline!$e$.$x$!~ is typed as if it was ~\lstinline!{ val $y$ := $e$; $y$.$x$ }!, for some fresh name $y$. 

The selection ~\lstinline!$e$.?$x$!~ is typed as if it was 
\begin{lstlisting}
{ val $y$ := $e$; if $y$ != nil then $y$.$x$ else nil }
\end{lstlisting}
for some fresh name $y$; also called {\em safe navigation} or {\em safe selection}. 

The expected type of a designator's prefix is undefined. The type of a designator is the type $T$ of the entity it refers to. 

The selection ~\lstinline!$e$.$x$!~ is evaluated by first evaluating the qualifier expression $e$, which yields an object $r$. The selection's result is then the member $m$ of $r$ that is either defined by $m$ or defined by a definition overriding $m$. 







\section{Self, This \& Super}
\label{sec:self-this-super}

\syntax\begin{lstlisting}
Simple_Expr1 ::= [Path '.'] 'self'
                 ['.' Selection]
               | [Path '.'] 'this'
                 ['.' Selection]
               | [Path '.'] 'super' 
                 [Class_Qualifier] 
                 ['.' Selection]
               | [Path '.'] 'self' '[' 'cloned' ']'
                 '.' (ivar_id | Selection)
               | [Path '.'] (ivar_id | cvar_id)
\end{lstlisting}

The expression \code{self} stands always for the current instance in the context (and in function resolution searches in the actual class of the instance) in the innermost template containing the reference (thus excluding blocks and anonymous functions). 

The expression \code{this} is the same as \code{self}, except that function resolution searches from the class that this expression appears in, possibly skipping overrides in subtypes of the actual class of \code{self}. The \code{this} expression is interchangeable with \code{self} in the following paragraphs, although use of \code{self} is preferred. 

The expression ~\lstinline!$C$.self!~ refers to the current instance in the context of the enclosing (or even directly enclosing) type $C$. It is an error if $C$ is not an enclosing type. The type of the expression is the same as ~\lstinline!$C$.self.type!. 

A reference ~\lstinline!super.$m$!~ refers to a method or type $m$ in the least proper supertype of the innermost template containing the reference. It evaluates to the member $m'$ in the actual supertype of that template, which is equal to $m$ or which overrides $m$. If $m$ refers to a method, then the method must be either concrete, or the template containing the reference must have a member $m'$, which overrides $m$ and which is labeled \code{abstract override}. 

A reference ~\lstinline!$C$.super.$m$!~ refers to a method or type $m$ in the least proper supertype of the innermost class or object definition named $C$, which encloses the reference. It evaluates to the member $m'$ in the actual supertype of that template, which is equal to $m$ or which overrides $m$. If $m$ refers to a method, then the method must be either concrete, or the template containing the reference must have a member $m'$, which overrides $m$ and which is labeled \code{abstract override}. 

The \code{super} prefix may be followed by a qualifier ~\lstinline![$T$]!, as in ~\lstinline!$C$.super[$T$].$m$!. In this case, the reference is to the type or method $m$ in the parent class or trait of $C$, whose simple name is $T$. The qualifier allows also paths, in case multiple supertypes had the same simple name, working as a suffix search -- the name $T$ then refers the parent class or trait of $C$, whose qualified name ends with $T$. It evaluates to the member $m'$ in the actual supertype of that template, which is equal to $m$ or which overrides $m$. If $m$ refers to a method, then the method must be either concrete, or the template containing the reference must have a member $m'$, which overrides $m$ and which is labeled \code{abstract override}. 






\section{Use Expressions}
\label{sec:use-expressions}

\syntax\begin{lstlisting}
Use_Expr    ::= Use_Expr_As | Use_Aspect
Use_Expr_As ::= 'use' Simple_Expr ('as' | 'as!')
                [variable_id ':'] Type [Block_Expr]
Use_Aspect  ::= 'use' 'aspect' Path [Block_Expr]
\end{lstlisting}

Use expressions of the form ~\lstinline!use $e$ as $a$: $T$!~ are similar to typed expressions (\sref{sec:typed-expressions}). Their intention is to rebind an expression to a specific type (changing its expected type), and then either have this type to be effective in the same scope from that point onward, or, if a \code{Block_Expr} is syntactically given, only in the scope of that block expression. If a block is given, then the return value of the block is the value of this expression, otherwise, the value retrieved by evaluation of \code{Simple_Expr} is the value of this expression. Conversions described in typed expressions (\sref{sec:typed-expressions}) apply in these expressions as well, including the differences between \code{as} and ~\lstinline@as!@. 

Use expressions of the form ~\lstinline!use aspect $T$!~ enable the specified aspect, either in the scope defined by the given block, or if no block is given, then from that point onward. If the expression is used as a template statement, then the aspect is enabled for the whole template anywhere, if it does not have the block part. 








\section{Function Applications}
\label{sec:function-applications}

\syntax\begin{lstlisting}
Simple_Expr1   ::= Simple_Expr1 Argument_Exprs 
Argument_Exprs ::= Parens_Args {Parens_Args} [Block_Expr] 
                 | Poetry_Args [Block_Expr2]
                 | Block_Expr
                 
Parens_Args ::= '(' Args_Expr ')'
Poetry_Args ::= Args_Expr
Args_Expr   ::= [[Arg_Exprs ','] '*' Expr ','] Arg_Exprs [',' '**' Expr]
              | [Arg_Exprs ','] '*' Expr [',' '**' Expr]
              | '**' Expr
Arg_Exprs   ::= Arg_Expr {',' Arg_Expr}
Arg_Expr    ::= [['out'] [variable_id ':'] | '&'] Expr
\end{lstlisting}

A function application ~\lstinline!$f$($a_1 \commadots a_n$) $b$!~ applies the function $f$ to the argument expressions $a_1 \commadots a_n$ and passes the block expression $b$ (\sref{sec:blocks}) into it. 






\subsection{Argument Evaluation Strategies}
\label{sec:arg-eval-strategies}

Coral defers evaluation of arguments up to the point of function application, and happens then as specified in parameter evaluation strategies (\sref{sec:param-eval-strategies}). The type that each argument is type-checked against the corresponding parameter type (defined as follows) is the expected type of the argument expression, i.e. not its actual concrete type, which is known only after its evaluation. If the expected type is undefined, then \code{Object} is assumed. Typed expressions (\sref{sec:typed-expressions}) may be used to give the argument expression a concrete expected type. When the argument expression is evaluated, it is evaluated as if it were in the scope of the function application (which it is), so that visibility rules from that scope apply. 






\subsection{Corresponding Parameters}

The argument expressions $a_1 \commadots a_n$ can be split up to 3 virtual sections: 
\begin{itemize}

\item[] {\em Positional parameters}. Let's refer to them as $p_{1,i,j}$. These are defined by any number of mandatory parameters (where $i = 1$), followed by any number of optional parameters (where $i = 2$), followed by at most one repeated parameter (where $i = 3$ and $j = 1$), ended by any number of post mandatory parameters (where $i = 4$). 

\item[] {\em Named parameters}. Let's refer to them as $p_{2,i}$, where $i$ is the position of the named parameter among the section of named parameters. 

\item[] {\em Block capturing parameter}. Let's refer to it as $p_{3,1}$

\end{itemize}
To pair argument expressions with corresponding parameters, the following steps are to be taken:
\begin{enumerate}

\item Say that a {\em positional argument} is of the form $a_i$. 

\item Say that a {\em named argument} is of the form ~\lstinline!$x_i$: $a'_i$!, where $x_i$ is one of the named parameter names from the named parameters section. 

\item Say that $n_1$ is the count of positional arguments. If the last argument is prefixed with ``\lstinline!&!'':
\begin{itemize} 
\item If the captured block parameter is defined and a block $b$ is given, count the last argument also as a positional argument. It is an error if there are named arguments before it. 
\item If the captured block parameter is defined and a block $b$ is not given, do not count the last argument as a positional argument. 
\item If the captured block parameter is not defined and a block $b$ is given, count the last argument also as a positional argument. It is an error if there are named arguments before it. 
\item If the captured block parameter is not defined and a block $b$ is not given, count the last argument also as a positional argument. It is an error if there are named arguments before it. 
\end{itemize}

\item Say that $m_1$ is the count of mandatory parameters. Pair each $a_i$ for $1 \leq i \leq m_1$ with $p_{1,1,i}$. 

\item Say that $m_2$ is the count of post mandatory parameters. Pair each $a_i$ for $(n_1 - m_2) \leq i \leq m_2$ with $p_{1,4,i}$.

\item Say that $m_3$ is the count of optional parameters. Pair each $a_i$ for $m_1 < i < m_2$ with $p_{1,2,i}$, if $p_{1,2,i}$ is an optional parameter. If $p_{1,2,i}$ is not an optional parameter, collect the arguments that don't have a corresponding optional parameter into a sequence and pair it as a single argument with $p_{1,3,1}$. This finishes the positional arguments section. 

\item Let $\sigma i$ be a substitution from the named argument name's position in the function application's named arguments section to its position in the named parameters section of the function parameters definition. If the named argument has a name that is not defined in the function parameters definition, then the position of the capturing named parameter is returned, if it exists. It is an error if the substitution does not return any position, in the sense that the function is not applicable to the given arguments, defined also as follows. 

\item Say that $n_2$ is the count of named arguments. Pair each $a_{\sigma i}$ for $1 \leq i \leq n_2$ with $p_{2,i}$. 

\item Say that $n_3$ is the count of arguments given after the section of named arguments. If $n_3 = 0$, then pair the given block $b$ with $p_{3,1}$, or pair \code{nil} with $p_{3,1}$, if no block $b$ is given. If $n_3 = 1$, then pair the last unpaired argument with $p_{3,1}$. If there is no unpaired argument left, then again pair \code{nil} with $p_{3,1}$. If $n_3 > 1$, it is an error, in the sense that the function is not applicable to the given arguments, defined also as follows. 
\end{enumerate}

The type of each argument expression $a_i$ is typed with the corresponding parameter type $T_i$ as expected type. 






\subsection{Applicable Function}

The function $f$ must be applicable to its arguments $a_1 \commadots a_n$ of types $S_1 \commadots S_n$. 

If $f$ has a method type ~\lstinline!($p_1$: $T_1 \commadots p_n$: $T_n$)$R$!, the function $f$ is applicable if all of the following conditions hold:
\begin{itemize}

\item For every named argument ~\lstinline!$x_i$: $a'_i$!, the type $S_i$ is compatible with the parameter type $T_j$, whose name $p_j$ matches $x_i$, or if $f$ defines a capturing named parameter and $x_i$ does not match name of any $p_j$, then the type $S_i$ is compatible with the parameter type $T_j$, whose name $p_j$ matches the name of the capturing named parameter. 

\item For every positional argument $a_i$, the type $S_i$ is compatible with its corresponding $T_i$. 

\item The given block or the last argument prefixed with ``\lstinline!&!'' is of a type compatible with the type of the captured block parameter, if such parameter is defined. 

\item If the expected type of the function application is defined, the result type $R$ is compatible to it. 

\item For every argument $p_i$, if the corresponding parameter is defined as \code{out}, the argument is prefixed with \code{out} as well and must be a local variable. If the corresponding parameter is defined as only \code{out} and not \code{in} at the same time, the argument is converted to \code{out} argument and any previous value of the argument variable is released. See (\sref{sec:io-arguments}) for details. 
\end{itemize}

If $f$ is a polymorphic method, it is applicable if local type inference (\sref{sec:local-type-inference}) can determine type arguments, so that the instantiated method is applicable. If $f$ is of a value type, it is applicable if it has a method member named \code{apply}, which is applicable. Note that if explicit type parameters are given to the polymorphic method, type application (\sref{sec:type-applications}) happens prior to function application. 

If a function application appears to be an argument to another function application (let's call it a nested function application), the expected type of the nested function application is used to determine, whether the outer function is applicable, but the nested function application is not evaluated until time specified by argument evaluation strategy (\sref{sec:arg-eval-strategies}) corresponding to the argument. Local type inference may indeed occur for the nested function application, if it involves a polymorphic method, but again, only using the available expected types. 

If an argument expression is prefixed with ``\lstinline!*!'' (let's call it a {\em sequence argument expression}, or {\em sequence-splat}, or just {\em splat}), it is expanded into multiple argument expressions, as its expected type is ~\lstinline!Sequence[$S$]! and $S$ is the expected (and usually actual) type of the arguments resulting from the expansion. The expansion uses methods of the \code{Sequence} type to determine the length of the sequence and its type, which are then inserted instead of the sequence argument (and the contents of the sequence have their evaluation deferred). The sequence should have a reasonable length, and must not be infinite. Such sequence arguments can appear in the function application multiple times (unlike the repeated parameter), but only in the section of positional arguments. 

If an argument expression is prefixed with ``\lstinline!**!'' (let's call it a {\em map argument expression}, or {\em map-splat}), it is expanded into multiple argument expressions, as its expected type is ~\lstinline!Map[Symbol, $S$]! and $S$ is the expected (and usually actual) type of the arguments resulting from the expansion. The expansion uses methods of the \code{Map} type to determine the length of the map and its type, which are then inserted instead of the map argument (and the contents of the map have their evaluation deferred). The map should have a reasonable length, and must not be infinite. Such map arguments can appear in the function application multiple times (unlike the repeated parameter), but only in the section of named arguments. 

\example Assume the following function, which computes the sum of variable number of arguments:
\begin{lstlisting}
def sum (*xs: Integer) := (O /: xs) ((x, y) -> { x + y })
\end{lstlisting}
Then 
\begin{lstlisting}
sum 1, 2, 3, 4
sum (1, 2, 3, 4)
sum *%[1, 2, 3, 4]
sum (*%[1, 2, 3, 4])
sum 1, 2, *%[3, 4]
sum (1, 2, *%[3, 4])
sum 1, *%[2, 3], 4
sum (1, *%[2, 3], 4)
\end{lstlisting}
all yield $10$ as result. On the other hand,
\begin{lstlisting}
sum %[1, 2, 3, 4]
\end{lstlisting}
would not be applicable. Moreover, (note the extra space before the sequence-splat operator),
\begin{lstlisting}
sum * %[1, 2, 3, 4]
\end{lstlisting}
would be interpreted as 
\begin{lstlisting}
sum.`*`(%[1, 2, 3, 4])
\end{lstlisting}
which is an infix expression rather than a function application. On the other hand, a space may appear between the function name and the arguments list.





\subsection{Tail-call optimization}

A function application usually allocates a new stack frame on the program's runtime stack for the current thread. However, if at least one of the following conditions holds and function calls itself as its last action, the application is executed using the stack frame of the caller, replacing arguments and rewinding stack pointer to the first instruction, called {\em tail-call optimization}:
\begin{itemize}
\item The function is local and not overloaded. 
\item The function is \code{final}. 
\item The function is \code{private} or ~\lstinline!private[self]!. 
\item The function is annotated so that tail-call optimization is explicitly allowed. 
\item A pragma allowing tail-call optimizations is effective in the scope of the tail call. 
\end{itemize}
The optimization will not happen if the application results in a different (possibly overloaded or overridden) variant of the caller function being applied, and a warning is issued if the tail-call optimization was explicitly expected (either via an annotation or a pragma). 





\subsection{Named \& Optional Arguments}
\label{sec:named-optional-arguments}

If an application uses named arguments ~\lstinline!$p_i$: $e_i$!~ or default arguments, the following conditions must hold:
\begin{itemize}
\item No named argument appears left of a positional argument in the argument list. 
\item No positional argument appears right of a named argument. A bit of an exception is the captured block argument, which appears to be positional, but is treated specially. 
\item The names $p_i$ of all named arguments are pairwise distinct. There is no way for named arguments to specify positional arguments -- this is also ensured by a similar requirement for the parameters lists. 
\item Every formal parameter ~\lstinline!$p_j$: $T_j$!, which is not specified by a positional argument, has a default argument. 
\item Every formal parameter ~\lstinline!^$p_j$: $T_j$!, which is not specified by a named argument, has a default argument. 
\item If there are more named arguments than named parameters (excluding the capturing named parameter), a capturing named parameter is defined. (If it is not, the function is not applicable.)
\end{itemize}

No transformation is applied to convert a function application into an application without named or default arguments -- the runtime handles the application itself. 






\subsection{By-Name, By-Need \& By-Future Arguments}
\label{sec:by-name-arguments}
\label{sec:by-need-arguments}
\label{sec:by-future-arguments}

None of these argument types require any syntactically special treatment. The user of a function that uses these types should however consider the implications of their types on their evaluation. 






\subsection{Input \& Output Arguments}
\label{sec:io-arguments}

Output arguments must be prefixed with the \code{out} keyword, so that the runtime can pass in a reference to the variable, and not to the value. The \code{in} modifier is implied and not used explicitly in the application. If the actual parameter is \code{out}-only, the original value of the variable is released upon being written to by the applied function, but not sooner. 

A variable that is defined with \code{val} is not useable as an \code{out} argument. A variable that is declared with \code{val} (but not defined) is useable as an \code{out} argument. 

When it comes to closures, variables in variable closures are implicitly also \code{out}, if the anonymous function contains an assignment to them. 

An assignment to an output parameter that was released is a no-op, and issues a warning. This can happen when the execution of an anonymous function or a block is delayed past the point where the original stack frame of the calling function is already released. 






\subsection{Curried Functions \& Partial Applications}
\label{sec:curried-functions}
\label{sec:partial-applications}

A curried function can appear in two distinct forms:
\begin{itemize}
\item[] {\em Implicitly curried form}, which is defined by using multiple parameters lists. 
\item[] {\em Explicitly curried form}, which is defined by using function types as return types of functions, or simply by returning a function from within a function. 
\end{itemize}

Each form has some implications on function applications. 

Let's define {\em consecutive function applications}. Such function applications are a continuous sequence of function applications, where each following function application is directly applied to the result of the previous function application, without storing the intermediate values anyhow. 

\example The following is an example of consecutive function applications:
\begin{lstlisting}
f(a, b)(c, d)
\end{lstlisting}
The following are not consecutive function applications:
\begin{lstlisting}
val e := f(a, b)
e(c, d)
\end{lstlisting}

An implicitly curried function requires a consecutive function application for all of its parameters lists, excluding the implicit parameters list. If the implicitly curried function is intended to be {\em partially applied} (not providing all the parameters lists with arguments lists), then a method value (\sref{sec:method-values}) can be used. This also applies to the implicit parameters list -- if providing it is to be deferred, a method value that encloses arguments lists up to the implicit parameters list can be used, but then the implicit arguments list has to be provided later in order to evaluate the curried function. 

On the other hand, explicitly curried functions do not care about consecutive function applications. 

The consecutive function applications meta-construct is also a solution to providing explicitly the implicit parameters list an arguments list. Without it, the function application would handle the implicits from it and the consecutive application would be applied to the result of the whole function. Therefore, if a consecutive function application is present, the evaluation of implicit parameters list is deferred to this consecutive function application, so that arguments for it can be specified. If there is no consecutive function application, then the implicit parameters list is evaluated as usual. 





\subsection{Function Compositions \& Pipelines}
\label{sec:function-compositions}
\label{sec:function-pipelines}

These expressions are not in fact syntax features, but rather an implementation on functions and their traits. 

A {\em function composition} is a way to compose two functions and return a function. A {\em function pipeline} is a way to pass a value to a function and return a value, which can be again passed to another function in a pipeline. 

Function composition is usually defined by operators such as ``\lstinline!|>>!'' for unary functions, ``\lstinline!||>>!'' for binary functions and so on, and ``\lstinline!<<|!'' for unary functions, ``\lstinline!<<||!'' for binary functions, in reverse order. 

Function pipeline is usually defined by operators such as ``\lstinline!|>!'' for unary functions, ``\lstinline!||>!'' for binary functions and so on, and ``\lstinline!<|!'' for unary functions, ``\lstinline!<||!'' for binary functions, in reverse order. 

These operators for unary functions can be defined as follows, e.g.:
\begin{lstlisting}[mathescape=false]
trait Function_1 [-$T, +$R]
begin

  // right-associative
  operator |>> [-$T1] (g: $T1 -> $T): $T1 -> $R := 
    (a: $T1) -> { self(g(a)) }

  // left-associative
  operator <<| [-$T1] (g: $T1 -> $T): $T1 -> $R :=
    (a: $T1) -> { self(g(a)) }

  // right-associative
  operator |> (a: $T): $R :=
    self(a)

  // left-associative
  operator <| (a: $T): $R := 
    self(a)
    
end trait
\end{lstlisting}

Function composition and pipelining makes more sense with the use of positional parameters rather than with named parameters, although with some more verbose syntax, it can be achieved as well, e.g. by assuming that the composed functions or pipelines share the same names of their named parameters. 





\subsection{Memoization}
\label{sec:memoization}

How to memoize a function's result is described in (\sref{sec:return-expressions}).

A memoized function's body is not evaluated, if it was once called with the same arguments (based on equality, not identity), and if that result value is still memoized. If so, the memoized result value is immediately returned without evaluation of the function's body, which can speed up execution of some functions significantly. Such functions should however be referentially transparent in best-case scenario (\sref{sec:function-decls-defs} \& \sref{sec:statements}) or at least tolerant to being memoized. 

Memoization is better with small parameter numbers, so that searching the result values cache would not actually take longer than evaluation of the function's body. Functions that are defined with the \code{function} keyword (\sref{sec:function-decls-defs}) may opt-in to implicit memoization\footnote{E.g., based on the computed complexity of the function. If the function is decided to be simple, then memoization could actually worsen performance.}, as well as functions declared as \code{transparent} (\sref{sec:statements}). Functions declared as \code{opaque} (\sref{sec:statements}) should not be memoized. 

Parameters of memoization\footnote{Parameters include things like: cache policy, ttl, cache size and so on.} may be controlled, even on per-function basis, with use of specialized annotations and pragmas. 





\section{Type Applications}
\label{sec:type-applications}

\syntax\begin{lstlisting}
Simple_Expr1 ::= Simple_Expr Type_Args
\end{lstlisting}

A type application ~\lstinline!$e$[$T_1 \commadots T_n$]!~ instantiates a polymorphic value $e$ of type ~\lstinline![$a_1$ >: $L_1$ <: $U_1$ $\commadots$ $a_n$ >: $L_n$ <: $U_n$] $\mapsto\ S$!~ with argument types $T_1 \commadots T_n$. Every argument type $T_i$ must obey the corresponding bounds $L_i$ and $U_i$. That is, for each $i = 1 \commadots n$, we must have $\sigma L_i <: T_i <: \sigma U_i$, where $\sigma$ is the substitution $[a_1 := T_1 \commadots a_n := T_n]$. The type of the application is $\sigma S$. 

If the function part $e$ is of some value type, the type application is taken to be equivalent to ~\lstinline!$e$.apply[$T_1 \commadots T_n$]!, i.e. the application of an \code{apply} method defined by $e$. 

Type applications can be omitted if local type inference (\sref{sec:local-type-inference}) can infer best type arguments for a polymorphic function from the types of the actual function arguments and the expected result type. 





\section{Tuples}
\label{sec:tuples}

\syntax\begin{lstlisting}
Simple_Expr ::= '(' [Exprs] ')'
\end{lstlisting}

A tuple expression ~\lstinline!($e_1 \commadots e_n$)!~ is an alias for the class instance creation ~\lstinline!Tuple_$n$($e_1 \commadots e_n$)!, where $n \geq 2$. The empty tuple ~\lstinline!()!~ is the unique value of type \code{Unit}. A tuple with only one value is only the value itself, without being wrapped in a tuple. 






\section{Instance Creation Expressions}
\label{sec:instance-creation-exprs}

Unlike languages like Java, Scala, C\# and similar, Coral does not have dedicated language construct for creating new instances of classes. Instead, all such attempts are made through the ~\lstinline!Class#new!~ method (not to be confused with ~\lstinline@Class.new@), which in the end\footnote{Because constructor currying can happen, the constructor is invoked by a native implementation from outside of the \code{new} method, by the curried function, which is a mechanism inaccessible to users otherwise than via the constructor definition.} has all arguments for a constructor, which gets invoked by a native implementation. 






\section{Blocks}
\label{sec:blocks}

\syntax\begin{lstlisting}
Block_Expr      ::= Block_Expr1 | Block_Expr2
Block_Expr1     ::= '{' [Block_Args semi] Block '}'
Block_Expr2     ::= 'do' [Block_Args semi] Block 'end'
Block_Args      ::= '|' [Params] [Block_Shadowing] '|' [':' Type]
Block_Shadowing ::= ';' [Shad_Val_Dcl {',' Shad_Val_Dcl}]
Shad_Val_Dcl    ::= 'val' Val_Dcl
                  | 'var' Var_Dcl
                  | 'def' Def_Dcl
Block           ::= {Block_Stat semi} [Result_Expr]
\end{lstlisting}






\section{Yield Expressions}

\syntax\begin{lstlisting}
Yield_Expr ::= 'yield' '(' [Arg_Exprs] ')'
             | '(' [Arg_Exprs ','] '*' Expr ')'
             | '(' [Arg_Exprs ','] ['*' Expr ','] '**' Expr ')'
             | [Arg_Exprs]
             | [Arg_Exprs ','] '*' Expr
             | [Arg_Exprs ','] ['*' Expr ','] '**' Expr
\end{lstlisting}







\section{Prefix \& Infix Operations}
\label{sec:prefix-infix-ops}

\syntax\begin{lstlisting}
Infix_Expr  ::= Prefix_Expr
              | Infix_Expr [op_id Infix_expr]
Prefix_Expr ::= [op_id] Simple_Expr
\end{lstlisting}

Expressions can be constructed from operands and operators. 





\subsection{Prefix Operations}

A prefix operation $\op\ e$ consists of a prefix operator $\op$, which may be any operator identifier, unlike in Scala, but must not be followed by any whitespace, only identifiers or parentheses. The expression $\op\ e$ is equivalent to the method application ~\lstinline!$e$.$\op$()!. 





\subsection{Postfix Operations}

Apart from standard function applications (\sref{sec:function-applications}) that may be viewed as postfix, Coral does not include support for postfix operations. 





\subsection{Infix Operations}
\label{sec:infix-operations}

An infix operator can be an arbitrary operator identifier. Infix operators have static precedence and associativity borrowed from Scala, and defined as follows:

The {\em precedence} of an infix operator is determined by the operator's first character. Characters are listed below in increasing order of precedence, with characters on the same line having the same precedence.

\begin{lstlisting}
|
^
&
< > ~
= !
:
$\mbox{\rm\sl(all other special characters)}$
+ -
* / %
\end{lstlisting}

That is, operators starting with ``\lstinline!|!'' have the lowest precedence, followed by operators starting with ``\lstinline!^!'', etc. 

There's one exception to this rule, which concerns {\em assignment operators} (\sref{sec:assignment-operations}). The precedence of an assignment operator is the same as the one of simple assignment (\lstinline!=!). That is, it is lower than the precedence of any other operator. 

The {\em associativity} of an operator is determined by the operator's last character. Operators ending in a colon ``\lstinline!:!'' are right-associative, and operators ending in a greater-than sign ``\lstinline!>!'' are right-associative, if they consist of more than one operator character. All other operators are left-associative. 

Precedence and associativity of operators determine the grouping of parts of an expression as follows.

\begin{itemize}
\item If there are several infix operations in an expression, then operators with higher precedence bind more closely than operators with lower precedence. 

\item If there are consecutive infix operations $e_0\ \op_1\ e_1\ \op_2 \ldots \op_n\ e_n$ with operators $\op_1 \ldots \op_n$ of the same precedence, then all those operators must have the same associativity (i.e. it is an error if they don't). If all operators are left-associative, then the sequence is interpreted as ~\lstinline!(($e_0\ \op_1\ e_1$) $\op_2 \ldots$) $\op_n\ e_n$!. Otherwise, if all operators are right-associative, the sequence is interpreted as ~\lstinline!$e_0\ \op_1$ ($e_1\ \op_2$ ($\ldots \op_n\ e_n$))!.

\item A left-associative binary operation $e_1\ \op\ e_2$ is interpreted as ~\lstinline!$e_1$.`$\op$`($e_2$)!. If $\op$ is right-associative, the same operation is interpreted as ~\lstinline!{ val x := $e_1$; $e_2$.`$\op$`($x$) }!, where $x$ is a fresh name. 

\item The right-hand operand of a left-associative operator may consist of several arguments enclosed in parentheses, e.g. ~\lstinline!$e\ \op$ ($e_1 \commadots e_n$)!. This expression is then interpreted as ~\lstinline!$e$.`$\op$`($e_1 \commadots e_n$)!. 

\item The left-hand operand of a right-associative operator may consist of several arguments enclosed in parentheses, e.g. ~\lstinline!($e_1 \commadots e_n$) $\op\ e$!. This expression is then interpreted as ~\lstinline!$e$.`$\op$`($e_1 \commadots e_n$)!. 
\end{itemize}






\subsection{Assignment Operations}
\label{sec:assignment-operations}

An assignment operator is an operator symbol that ends in an ``equals'' character ``\lstinline!=!'', with the exception of operators for which one of the following conditions holds: 
\begin{enumerate}
\item the operator also starts with an equals character and has more than one character, or
\item the operator is one of ``\lstinline!<=!'', ``\lstinline!>=!'' or ``\lstinline@!=@''.
\end{enumerate}

Assignment operators are treated specially in that they can be expanded to assingments if no other interpretation is valid, as previously defined. Assignment operators can't be defined as members of any type. 

Let's consider an assignment operator, such as ``\lstinline!+=!'', in an infix operation ~\lstinline!$l$ += $r$!, where $l$ \& $r$ are expressions. This operation can be re-interpreted as an assignment
\begin{lstlisting}
$l$ := $l$ + $r$
\end{lstlisting}
except that the operations's left-hand-side $l$ is evaluated only once. 

The re-interpretation is correct always, since, unlike in Scala,
\begin{enumerate}
\item The left hand side can never have a member named ``\lstinline!+=!'', as specified in this section. 
\item The assignment ~\lstinline!$l$ := $l$ + $r$! is only expected to be type-correct, not enforced. If it is not type correct, a runtime error will be raised. 
\end{enumerate}





\section{Typed Expressions}
\label{sec:typed-expressions}

\syntax\begin{lstlisting}
Cast_Expr  ::= Infix_Expr ('as' | 'as!') Type
Infix_Expr ::= Infix_Expr ('is' | 'is!') Type
\end{lstlisting}

The typed expression ~\lstinline!$e$ as $T$!~ has type $T$. The type of expression $e$ is expected to conform to $T$. The result of the expression is the value of $e$ converted to type $T$. The conversion can take these forms, preferred in the following order:
\begin{enumerate}
\item No conversion, if $e$ conforms to $T$ directly. 
\item If an implicit conversion $c$ from expression type $E$ of method type ~\lstinline!($E$) $\mapsto\ T$!~ exists in the scope, then the conversion is of the form ~\lstinline!$c$($e$)!. 
\item Otherwise, the conversion is of the form ~\lstinline!$e$.as_instance_of[$T$]()!. 
\end{enumerate}

The conformance check expression ~\lstinline!$e$ is $T$!~ has type \code{Boolean} and tests whether $e$ conforms to $T$, basically by asking a question ``Can $e$ be of type $T$?'', answering either ``It can be'' or ``It can't be''. The expression $e$ conforms to type $T$ if at least one of the following conditions hold:
\begin{enumerate}
\item Type of $e$ is a subtype of $T$. 
\item An implicit conversion $c$ from expression type $E$ of method type ~\lstinline!($E$) $\mapsto\ T$!~ exists in the scope. 
\item As a last resort, type of $e$ overrides the method ~\lstinline!is_instance_of[$T$]()!~ and evaluating it results in \code{yes} value. 
\end{enumerate}

Note: the conformance check expression as defined here is not used in resolution of function applications (\sref{sec:function-applications}).

The typed expression ~\lstinline@$e$ as! $T$@~ works like ~\lstinline!$e$ as $T$!, but only uses the first form. Similarly, the conformance check expression ~\lstinline@$e$ is! $T$@~ works like ~\lstinline!$e$ is $T$!, but it uses only the first condition. The bang character ``\lstinline@!@'' signalizes that the operation is more dangerous, in means of that its easier for the expression $e$ to not successfully convert to the target type or conform to it. 






\section{Annotated Expressions}
\label{sec:annotated-exprs}

\syntax\begin{lstlisting}
Annot_Expr ::= Annotation {Annotation} Infix_Expr
\end{lstlisting}

An annotated expression $a_1\ \ldots\ a_n\ e$ attaches annotations $a_1\ \ldots\ a_n$ to the expression $e$ (\sref{sec:annotations}). 






\section{Assignments}

\syntax\begin{lstlisting}
Assign_Expr ::= [Simple_Expr '.'] variable_id ':=' Expr
              | Mul_Assign_Expr
Update_Expr ::= Simple_Expr1 Argument_Exprs ':=' Expr
\end{lstlisting}

The interpretation of an assignment to a simple variable ~\lstinline!$x$ := $e$!~ depends on the definitions of $x$. If $x$ denotes a mutable variable, then the assignment changes the current value of $x$ to the result of evaluating the expression $e$. The type of $e$ is expected to conform to the type of $x$. 

If $x$ is defined as a property of some template, or the template contains a setter function ~\lstinline!$x$_=!~ as a member, then the assignment is interpreted as the invocation ~\lstinline!$x$_=($e$)!~ of that setter function. 

Analogously, an assignment ~\lstinline!$f$.$x$ := $e$!~ is interpreted as the invocation ~\lstinline!$f$.$x$_=($e$)!. If $f$ is evaluated to \code{nil}, then the invocation is forwarded to \code{nil}.\footnote{This likely results in a runtime error being raised, unless \code{nil} would actually implement method \code{x_=}.} 

An assignment ~\lstinline!$f$.?$x$ := $e$!~ is interpreted as the invocation ~\lstinline!$f$.?$x$_=($e$)!. If $f$ is evaluated to \code{nil}, then the invocation is evaluated to \code{nil}. See (\sref{sec:designators}) for more on behavior of the ``\lstinline!.?!'' navigation. 

An assignment ~\lstinline!$f$($\args$) := $e$!~ with a function application to the left of the ``\lstinline!:=!'' operator is interpreted as ~\lstinline!$f$.update($\args$)($e$)!, i.e. the invocation of an \code{update} function defined by $f$. If $f$ is evaluated to \code{nil}, then the invocation is forwarded to \code{nil}. The ``\lstinline!.?!'' navigation is not available with this expression. 

\example Here are some assignment expressions and their equivalent interpretations. 
\begin{lstlisting}
f := e                       f_=(e)
f() := e                     f.update()(e)
f(i) := e                    f.update(i)(e)
f(i, j) := e                 f.update(i, j)(e)
x.f := e                     x.f_=(e)
x.f() := e                   x.f.update()(e)
x.f(i) := e                  x.f.update(i)(e)
x.f(i, j) := e               x.f.update(i, j)(e)
f()() := e                   f().update()(e)
f(i)() := e                  f(i).update()(e)
f()(i) := e                  f().update(i)(e)
f(i)(j) := e                 f(i).update(j)(e)
f(i, j)(k) := e              f(i, j).update(k)(e)
f(i, j)(k, l) := e           f(i, j).update(k, l)(e)
f(i, j) := (e_1, e_2)        f.update(i, j)((e_1, e_2))
\end{lstlisting}






\subsection{Multiple Assignments}
\label{sec:multiple-assignments}

\syntax\begin{lstlisting}
Mul_Assign_Expr ::= Mul_Vars ':=' Mul_Exprs
Mul_Vars        ::= [variable_id {',' variable_id} ',']
                    ['*'] variable_id {',' variable_id}
Mul_Exprs       ::= [Expr {',' Expr} ',']
                    ['*'] Expr {',' Expr}
\end{lstlisting}

% TBD: expand this section with some lovely math expressions
% TBD: add explanation of what *var is and *expr is here





\section{Conditional Expressions}
\label{sec:conditional-expressions}

\syntax\begin{lstlisting}
Cond_Expr        ::= Cond_Block_Expr | Cond_Mod_Expr
Cond_Block_Expr  ::= Cond_Block_Expr1 | Cond_Block_Expr2
Cond_Block_Expr1 ::= 'if' Expr ('then' | semi) Cond_Block 
                     {[semi] 'elsif' Expr ('then' | semi) Cond_Block}
                     [[semi] 'else' Cond_Block] 'end' ['if']
Cond_Block_Expr2 ::= 'unless' Expr ('then' | semi) Cond_Block 
                     {[semi] 'elsif' Expr ('then' | semi) Cond_Block}
                     [[semi] 'else' Cond_Block] 'end' ['unless']
Cond_Mod_Expr    ::= Expr Cond_Modifier
Cond_Modifier    ::= Cond_Modifier1
                     ['else' Infix_Expr]
Cond_Modifier1   ::= ('if' | 'unless') Infix_Expr 
Cond_Block       ::= Expr | Block
\end{lstlisting}

The conditional expression ~\lstinline!if $e_1$ then $e_2$ else $e_3$!~ chooses one of the values of $e_2$ and $e_3$, depending on the value of $e_1$. The condition $e_1$ is expected to conform to type \code{Boolean}, but can be virtually any type -- if it is not a \code{Boolean}, then it is equal to \code{yes} if it implements the method ~\lstinline!to_boolean(): Boolean! and that implementation returns \code{yes}, or can be converted to \code{yes} (\sref{sec:typed-expressions}), and \code{no} otherwise. The \code{nil} object converts always to \code{no}. If the $e_1$ is the single instance ``\lstinline!()!'' of type \code{Unit}, it is an error. The \code{then}-part $e_2$ and the \code{else}-part $e_3$ are both expected to conform to the expected type of the conditional expression, but are not required to. The type of the conditional expression is the weak least upper bound (\sref{sec:weak-conformance}) of the types of $e_2$ and $e_3$. A semicolon preceding the \code{else} symbol of a conditional expression is ignored. 

The conditional expression is evaluated by evaluating first $e_1$. If this evaluates to \code{true}, the result of evaluating $e_2$ is returned, otherwise the result of evaluating $e_3$ is returned. 

The evaluation of $e_1$ utilizes the so-called {\em short-circuit evaluation}. The expression $e_1$ is split by binary boolean operators. Then every first argument is evaluated, but the second argument is evaluated only if the evaluation of the first argument does not suffice to determine the value of the expression. When the first argument of ``\lstinline!&&!'' evaluates to \code{no}, the overall value must be \code{no} and the result of evaluating the second argument does not change that. When the first argument of ``\lstinline!||!'' evaluates to \code{yes}, the overall value must be \code{yes}. These boolean operators are in fact short-circuited source-code-wide, not only as part of conditional expressions. Word equivalents of these operators are not short-circuited (``\code{and}'' and ``\code{or}'' respectively). 

\example The following examples show how short-circuit evaluation behaves. Let's mark the short-circuited ``\lstinline!&&!'' as ``\lstinline!sand!'' and the short-circuited ``\lstinline!||!'' as ``\lstinline!sor!''. On the right side are the equivalent conditional expressions. 
\begin{lstlisting}
$x$ sand $y$          if $x$ then $y$ else no
$x$ sor $y$           if $x$ then yes else $y$
\end{lstlisting}

A short form of the conditional expression eliminates the \code{else}-part. The conditional expression ~\lstinline!if $e_1$ then $e_2$!~ is evaluated as if it was ~\lstinline!if $e_1$ then $e_2$ else ()!, and is therefore expected to be the weak least upper bound of the type \code{Unit} and the type of $e_2$. 

The conditional expression 
\begin{lstlisting}
if $e_1$ then $e_2$ elsif $e_3$ then $e_4$ $\ldots$ elsif $e_n$ then $e_{n+1}$ else $e_{n+2}$
\end{lstlisting} 
is evaluated as if it was 
\begin{lstlisting}
if $e_1$ then $e_2$ else if $e_3$ then $e_4$ $\ldots$ else if $e_n$ then $e_{n+1}$ else $e_{n+2}$
\end{lstlisting}
Basically, \code{elsif} is a simple syntax sugar for the little longer \code{else if} keyword tokens sequence. 

The alternative conditional expression ~\lstinline!unless $e_1$ then $e_2$ else $e_3$!~ is evaluated as if it was ~\lstinline@if !$e_1$ then $e_2$ else $e_3$@. Unlike in Ruby, the \code{elsif}-part is allowed to appear with this conditional expression. However, there is no syntax sugar for the \code{else unless} keyword tokens sequence. 

The modifier-fashion conditional expression ~\lstinline!$e_1$ if $e_2$ else $e_3$!~ is interpreted as if it was ~\lstinline!if $e_2$ then $e_1$ else $e_3$!. Similarly with the \code{unless} version and the short form of the modifier conditional expression (without the explicit \code{else}-part). 

Unlike in some languages, conditional expressions do not require to place parentheses around the conditions -- but it is possible to do so, the result is equivalent. That might be useful when the condition is inevitably long and needs to span multiple lines -- so that boolean operators may be situated at the beginning of each new line, instead of being at the end of the previous line. 






\section{Loop Expressions}

Coral has an elaborate support for loop expressions. Not all structures known from other languages are supported though, e.g. the ~\lstinline[language=Java]!do $\ldots$ while!~ expression, which is expressed differently in Coral. 






\subsection{Loop Control Expressions}
\label{sec:loop-control-expressions}

\syntax\begin{lstlisting}
Loop_Ctrl_Expr ::= Break_Expr
                 | Skip_Expr
                 | Next_Expr
                 | Redo_Expr
                 | Exhausted_Expr
                 | Broken_Expr
Break_Expr     ::= 'break' [label_name] [Cond_Modifier1]
Skip_Expr      ::= 'skip' [integer_literal] [Cond_Modifier1]
Next_Expr      ::= 'next' [label_name] [Cond_Modifier1]
Redo_Expr      ::= 'redo' [label_name] [Cond_Modifier1]
Exhausted_Expr ::= 'exhausted' Block_Expr
Broken_Expr    ::= 'broken' Block_Expr
\end{lstlisting}

Loop control expressions are made available inside of loop expressions to allow control of the enclosing loops.

In the following paragraphs, a {\em loop identified by the label $l$} is a loop expression preceded in its syntax with the syntax element \code{Label_Dcl} (\sref{sec:local-jump-expressions}). All annotations (\sref{sec:annotated-exprs}) that precede the label declaration are applied to the following loop expression, never to the label. 

The ~\lstinline!break $l$!~ expression stops the loop labeled with $l$, and omitting the $l$ label stops the directly enclosing loop. 

The ~\lstinline!skip $i$!~ expression skips $i$ loop iterations, or with the $i$ omitted, skips $1$ loop iteration (the current iteration). 

The ~\lstinline!next $l$!~ expression skips the current loop iteration and every other enclosing iteration until the loop identified by the given label $l$ is found, and continues with its next iteration. If the label $l$ is omitted, then its behavior is equal to ~\lstinline!skip 1!. 

The ~\lstinline!redo $l$!~ restarts the loop identified by the label $l$ (and stops all loops in between), or if $l$ is omitted, restarts the directly enclosing loop. 

The ~\lstinline!exhausted $e$!~ expression evaluates the expression $e$ only if the directly enclosing loop {\em was not broken} with the \code{break} keyword. 

The ~\lstinline!broken $e$!~ expression evaluates the expression $e$ only if the directly enclosing loop {\em was broken} with the \code{break} keyword. 

The standard library provides loop-like methods, where these loop control structures are not available as keywords, but as methods instead (either imported or available on some given loop-control object) -- they might be implemented e.g. using the \code{throw} expressions (\sref{sec:throw-catch-expressions}), that the enclosing loop-like method catches and resolves as appropriate. Only the \code{exhausted} and \code{broken} constructs need to be simulated, possibly by optional parameters or additional parameter sections.\footnote{In fact, all loop expressions may be interpreted as syntax sugar to such methods. How exactly -- that may get into this specification as soon as it is clearly defined.} 





\subsection{Iterable For Expressions}
\label{sec:iterable-expressions}

\syntax\begin{lstlisting}
Loop_Expr       ::= [Label_Dcl] 'for' Val_Dcls 'in' ['reverse'] Expr 
                    ['step' Expr] For_Loop
For_Loop        ::= 'loop' Loop_Block_Expr 'end' ['loop']
                  | '{' Loop_Block_Expr '}'
Loop_Block_Expr ::= {Block_Stat | Loop_Ctrl_Expr}
Val_Dcls        ::= Val_Dcl
                  | Pattern1
\end{lstlisting}

The {\em iterable expression} is typed as \code{Unit}, so there is no point in using its value. 

In an expression ~\lstinline!for $e_1$ in $e_2$ loop $e_3$ end!, the type of $e_2$ is expected to conform to ~\lstinline!Iterable_Like[$E$]!. The type of $e_1$ is expected to conform to the type $E$. The type of $e_3$ is evaluated to ``\lstinline!()!'' anyway. The scope of variables defined in $e_1$ extends to the $e_3$ expression. 

In expression ~\lstinline!for $e_1$ in reverse $e_2$ loop $e_3$ end!, the type of $e_2$ is expected to conform to \code{Reverse_Iterable_Like}. 

Iterable expressions make use only of the two mentioned traits and the methods defined by them, and therefore advanced iterating mechanisms, such as parallel computations, are not performed -- they are simply too complex to be generalized by a simple language construct. 

Iterable expression repeats evaluation of the expression $e_3$ for every value that comes from the \code{Iterable_Like}'s \code{Iterator}, unless the loop controls alter this flow (\sref{sec:loop-control-expressions}).

Iterable expressions are simple comprehensions over iterating a single iterable value. For more complex iterating expressions, see generators (\sref{sec:generator-expressions}).

An expression 
\begin{lstlisting}
for $e_1$ in $e_2$ loop $e_3$ end
\end{lstlisting} 
is translated to the invocation
\begin{lstlisting}
$e_2$.each { when $e_1$ then $e_3$ }
\end{lstlisting} 

An expression 
\begin{lstlisting}
<<$l$>> for $e_1$ in $e_2$ loop $e_3$ end
\end{lstlisting} 
where $l$ is a label name, is translated to the invocation
\begin{lstlisting}[deletekeywords={label}]
$e_2$.each({ when $e_1$ then $e_3$ }, label: $l'$)
\end{lstlisting}
where $l'$ is a symbol literal for the label $l$. 

An expression 
\begin{lstlisting}
for $e_1$ in reverse $e_2$ loop $e_3$ end
\end{lstlisting} 
is translated to the invocation
\begin{lstlisting}[deletekeywords={reverse}]
$e_2$.reverse.each { when $e_1$ then $e_3$ }
\end{lstlisting} 

An expression 
\begin{lstlisting}
<<$l$>> for $e_1$ in reverse $e_2$ loop $e_3$ end
\end{lstlisting} 
where $l$ is a label name, is translated to the invocation
\begin{lstlisting}[deletekeywords={label,reverse}]
$e_2$.reverse.each({ when $e_1$ then $e_3$ }, label: $l'$)
\end{lstlisting}
where $l'$ is a symbol literal for the label $l$. 

An expression 
\begin{lstlisting}
for $e_1$ in $e_2$ step $i$ loop $e_3$ end
\end{lstlisting} 
is translated to the invocation
\begin{lstlisting}[deletekeywords={step}]
$e_2$.each({ when $e_1$ then $e_3$ }, step: $i$)
\end{lstlisting} 

Analogously, other combinations of \code{reverse}, \code{skip} and labeled loops are translated. If the $e_3$ expression contains a \code{exhausted} expression, then it's block is passed to the \code{each} method as an argument named \lstinline[deletekeywords={exhausted}]{exhausted}, and analogously, if the $e_3$ expression contains a \code{broken} expression, then it's block is passed to the \code{each} method as an argument named \lstinline[deletekeywords={broken}]{broken}.







\subsection{While \& Until Loop Expressions}

\syntax\begin{lstlisting}
Loop_Expr     ::= [Label_Dcl] ('while' | 'until') Expr For_Loop
                | Loop_Mod_Expr
Loop_Mod_Expr ::= Expr Loop_Modifier
Loop_Modifier ::= ('while' | 'until') Expr
\end{lstlisting}

The {\em while loop expression} ~\lstinline!while $e_1$ loop $e_2$ end!~ is typed as \code{Unit}, so there is no point in using its value. 

In an expression ~\lstinline!while $e_1$ loop $e_2$ end!, the expression $e_1$ is treated the same way as the condition part in conditional expressions (\sref{sec:conditional-expressions}). The type of $e_2$ is evaluated to ``\lstinline!()!'' anyway.

The while loop expression ~\lstinline!while $e_1$ loop $e_2$ end!~ is alone typed and evaluated as if it was an application of a hypothetical function ~\lstinline!while_loop ($e_1$) ($e_2$)!, where the function \code{while_loop} would be defined as follows, with the $e_1$ and $e_2$ would be passed by-name: 
\begin{lstlisting}
def while_loop (condition: => Boolean)(body: => Unit): Unit := {
<<repeat>>
  if (condition) { body; goto repeat } else {}
}
\end{lstlisting}
The real implementation has to handle loop control expressions (\sref{sec:loop-control-expressions}) around the evaluation of \code{body} and also handle a label, if one is given; so it is not this simple. 

A while loop expression repeats evaluation of the expression $e_2$ as long as $e_1$ evaluates to \code{yes}, unless the loop controls alter this flow (\sref{sec:loop-control-expressions}).





\subsection{Pure Loops}
\label{sec:pure-loops}

\syntax\begin{lstlisting}
Loop_Expr  ::= [Label_Dcl] 'loop'
               (semi Loop_Block_Expr 'end' ['loop'] | 
               '{' Loop_Block_Expr '}')
\end{lstlisting}

The {\em pure loop expression} ~\lstinline!loop $e$ end!~ is typed as \code{Unit}, so there is no point in using its value. 

A pure loop expression repeats evaluation of the expression $e$ as long as the loop controls don't alter this flow (\sref{sec:loop-control-expressions}). It is basically equivalent to an iterable expression (\sref{sec:iterable-expressions}) that iterates over an endless iterator. 

This expression may also be used to replace the ~\lstinline[language=Java]!do { $e_1$ } while ($e_2$)!~ expression, known from other languages, using the following structure: 
\begin{lstlisting}
loop
  $e_1$
  break if $e_2$
end loop
\end{lstlisting}

A pure loop expression is the only expression that is not translated into a method call, but rather into another expression. The following constructs are practically the same: 
\begin{lstlisting}
// construct with loop
loop
  $\ldots$
end loop

// construct with goto
label loop_begin
  $\ldots$
  goto loop_begin
\end{lstlisting}
However, the loop construct has built-in support for loop control expressions. 





\section{Generator Expressions}
\label{sec:generator-expressions}

\syntax\begin{lstlisting}
Loop_Expr      ::= 'for' (Generator_Iter | Generator_Expr)
Generator_Iter ::= '(' Enumerators ')' {nl} (Expr | For_Loop)
Generator_Expr ::= '{' Enumerators '}' {nl} 'yield' Expr
Enumerators    ::= Generator {semi Enumerator}
Enumerator     ::= Generator
                 | Guard
                 | Pattern1 ':=' Expr
Generator      ::= [Label_Dcl] Pattern1 '<-' Expr [Guard]
Guard          ::= Cond_Modifier1
\end{lstlisting}

A {\em generator iteration} ~\lstinline!for ($\enums$) $e$!~ executes expression $e$ for each binding generated by the enumerators $\enums$ and as an expression, it is typed as \code{Unit}. A {\em generator expression} ~\lstinline!for {$\enums$} yield $e$!~ evaluates expression $e$ for each binding generated by the enumerators $\enums$ and collects the results.

An enumerator sequence always starts with a generator; this can be followed by further generators, value definitions or guards. A {\em generator} ~\lstinline!$p$ <- $e$!~ produces bindings from an expression $e$, which are matched in some way against pattern $p$ (\sref{sec:pattern-matching}). A {\em value definition} ~\lstinline!$p$ := $e$!~ binds the value name $p$ (or several names in a pattern $p$) to the result of evaluating the expression $e$. A {\em guard} ~\lstinline!if $e$!~ (or ~\lstinline!unless $e$!) contains a boolean expression $e$, which restricts enumerated bindings. The precise meaning of generators and guards is defined by translation to invocations of four methods: \code{map}, \code{with_filter}, \code{flat_map} and \code{each}. These methods can be implemented in different ways for different carrier types.

The translation scheme is defined as follows. In a first step, every generator ~\lstinline!$p$ <- $e$!, where $p$ is not irrefutable (\sref{sec:irrefutable-patterns}) for the type of $e$, is replaced by 
\begin{lstlisting}
$p$ <- $e$.with_filter { when $p$ then yes else no }
\end{lstlisting}

Then, the following rules are applied repeatedly, until all comprehensions are eliminated. 
\begin{itemize}

\item A comprehensioin 
\begin{lstlisting}
for {$p$ <- $e$} yield $e'$
\end{lstlisting}
is translated to
\begin{lstlisting}
$e$.map { when $p$ then $e'$ }
\end{lstlisting}

\item A comprehension
\begin{lstlisting}
for {<<$l$>> $p$ <- $e$} yield $e'$
\end{lstlisting}
where $l$ is a label name, is translated to
\begin{lstlisting}[deletekeywords={label}]
$e$.map({ when $p$ then $e'$ }, label: $l'$)
\end{lstlisting}
where $l'$ is a symbol literal for the label $l$. 

\item A comprehension 
\begin{lstlisting}
for ($p$ <- $e$) $e'$
\end{lstlisting}
is translated to
\begin{lstlisting}
$e$.each { when $p$ then $e'$ }
\end{lstlisting}

\item A comprehension 
\begin{lstlisting}
for (<<$l$>> $p$ <- $e$) $e'$
\end{lstlisting}
where $l$ is a label name, is translated to
\begin{lstlisting}[deletekeywords={label}]
$e$.each({ when $p$ then $e'$ }, label: $l$)
\end{lstlisting}
where $l'$ is a symbol literal for the label $l$. 

\item A comprehension 
\begin{lstlisting}
for {$p$ <- $e$; $p'$ <- $e'\ \ldots$} yield $e''$
\end{lstlisting}
where $\ldots$ is a (possibly empty) sequence of generators, value definitions, or guards, is translated to
\begin{lstlisting}
$e$.flat_map { when $p$ then for {$p'$ <- $e'\ \ldots$ } yield $e''$ }
\end{lstlisting}

\item A comprehension 
\begin{lstlisting}
for {<<$l$>> $p$ <- $e$; $p'$ <- $e'\ \ldots$} yield $e''$
\end{lstlisting}
where $l$ is a label name, and where $\ldots$ is a (possibly empty) sequence of generators, value definitions, or guards, is translated to
\begin{lstlisting}[deletekeywords={label}]
$e$.flat_map(
  { when $p$ then for {$p'$ <- $e'\ \ldots$ } yield $e''$ },
  label: $l$
)
\end{lstlisting}
where $l'$ is a symbol literal for the label $l$. 

\item A comprehension 
\begin{lstlisting}
for ($p$ <- $e$; $p'$ <- $e'\ \ldots$) $e''$
\end{lstlisting}
where $\ldots$ is a (possibly empty) sequence of generators, value definitions, or guards, is translated to
\begin{lstlisting}
$e$.each { when $p$ then for ($p'$ <- $e'\ \ldots$) $e''$ }
\end{lstlisting}

\item A comprehension 
\begin{lstlisting}
for (<<$l$>> $p$ <- $e$; $p'$ <- $e'\ \ldots$) $e''$
\end{lstlisting}
where $\ldots$ is a (possibly empty) sequence of generators, value definitions, or guards, is translated to
\begin{lstlisting}[deletekeywords={label}]
$e$.each(
  { when $p$ then for ($p'$ <- $e'\ \ldots$) $e''$ },
  label: $l$
)
\end{lstlisting}

\item A generator ~\lstinline!$p$ <- $e$!~ followed by a guard ~\lstinline!if $g$!~ is translated to a single generator
\begin{lstlisting}
$p$ <- $e$.with_filter(($x_1 \commadots x_n$) -> { $g$ })
\end{lstlisting}
where $x_1 \commadots x_n$ are the free variables of the pattern $p$. 

\item A generator ~\lstinline!$p$ <- $e$!~ followed by a guard ~\lstinline!unless $g$!~ is translated to a single generator
\begin{lstlisting}
$p$ <- $e$.with_filter(($x_1 \commadots x_n$) -> { !($g$) })
\end{lstlisting}
where $x_1 \commadots x_n$ are the free variables of the pattern $p$. 

\item A generator ~\lstinline!$p$ <- $e$!~ followed by a definition ~\lstinline!$p'$ := $e'$!~ is translated to the following generator of pairs of values, where $x$ and $x'$ are fresh names:
\begin{lstlisting}
($p$, $p'$) <- for {$x$ @ $p$ <- $e$} yield { val $x'$ @ $p'$ := $e'$; ($x$, $x'$) }
\end{lstlisting}

\end{itemize}

Generators in generator expression can optionally have a label $l$ assigned, so that expressions like ~\lstinline!break $l$!~ could work.\footnote{It is up to the concrete method how it handles the invocation, which uses \code{throw}-\code{catch} expressions -- however, ignoring it may result in an uncaught \code{Throwable} killing the thread.} Like with other loop expressions, if an \code{exhausted} or a \code{broken} loop control expression is given in the generator iteration expression $e$, it is passed to the outermost \code{each} method as a named argument, possibly along the \code{label} argument. 

\example The following code produces all pairs of numbers between $1$ and $n - 1$, whose sums are prime numbers. 
\begin{lstlisting}
for { i <- 1 .. n
      j <- 1 .. i
      if is_prime? i + j
} yield (i, j)
\end{lstlisting}
The comprehension is translated to:
\begin{lstlisting}
(1..n).flat_map {
  when i then (1 .. i).
    with_filter { (j) -> { is_prime? i + j } }.
    map { when j then (i, j) }
}
\end{lstlisting}

\example Generator expressions can be used to express vector and matrix algorithms concisely.
\begin{lstlisting}[mathescape=false]
def transpose[$A](xss: List[List[$A]]): List[List[$A]] :=
  for {i <- 0 .. xss(0).length} yield {
    for (xs <- xss) yield xs(i)
  }
\end{lstlisting} 
The comprehension is translated to: 
\begin{lstlisting}[mathescape=false]
def transpose[$A](xss: List[List[$A]]): List[List[$A]] := 
  (0 .. xss(0).length).
    map { 
      when i then xss.
        map { when xs then xs(i) }
    }
\end{lstlisting}






\section{Collection Comprehensions}

\syntax\begin{lstlisting}
List_Literal       ::= '%' Collection_Flags '[' 'for' Generator_Expr ']'
Dictionary_Literal ::= '%' Collection_Flags '{' 'for' Generator_Expr '}'
Bag_Literal        ::= '%' Collection_Flags '(' 'for' Generator_Expr ')'
\end{lstlisting}

Collection comprehensions extend the syntax of collection ``literals''\footnote{Pure literals are terminal symbols in the language, but collection literals are wrappers around virtually any expression.}, so that collections may be defined by not their explicit values, but by a function that generates them -- and that function is a generator. Only tuple literals don't have collection comprehension, due to their special nature within the language. 

Note that the generator expression for dictionary literal comprehension has to generate values of type ~\lstinline!($K$, $E$)!, where $K$ is the type of the keys and $E$ is the type of mapped values. 






\section{Pattern Matching \& Case Expressions}

\syntax\begin{lstlisting}
Match_Expr     ::= Pat_Match_Expr | Case_Expr
Pat_Match_Expr ::= 'match' Simple_Expr1 Match_Body
Match_Body     ::= semi When_Clauses 'end' ['match']
                 | '{' When_Clauses '}'
When_Clauses   ::= When_Clause {['next'] semi When_Clause} 
                   [['next'] 'else' Cond_Block]
When_Clause    ::= 'when' Pattern [Guard] ('then' | semi) Cond_Block
Case_Expr      ::= 'case' Simple_Expr1 Case_Body
Case_Body      ::= semi Case_Clauses 'end' ['case']
                 | '{' Case_Clauses '}'
Case_Clauses   ::= Case_Clause {['next'] semi Case_Clause}
                   [['next'] 'else' Cond_Block]
Case_Clause    ::= 'when' Case_Patterns ('then' | semi) Cond_Block
Case_Patterns  ::= Case_Pattern {',' Case_Pattern}
Case_Pattern   ::= Stable_Id
                 | literal [('..' | '...') literal]
                 | variable_id
                 | Infix_Expr
\end{lstlisting}

Pattern matching is described in (\sref{sec:pattern-matching}). Here, the syntax of expressions that make use of pattern matching is given. 

Case expressions 
\begin{lstlisting}
case $e$ { when $c_1$ then $b_1\ \ldots$ when $c_n$ then $b_n$ else $b_{n+1}$ }
\end{lstlisting}
are simplified pattern matching expressions, though they do not use pattern matching at all, but {\em case equality} instead, defined with the method ``\lstinline!===!''. Thus, case expressions do not aim at matching the selector expression $e$, thus decomposing the selector $e$, but rather tests if it falls into a particular set of values, defined using the case equality method, by:
\begin{itemize}
\item a type of values ~\lstinline!$c$.`===`($e$)!,
\item a range of values ~\lstinline!($e_1$ .. $e_2$).`===`($e$)!, 
\item a set of values defined by another value ~\lstinline!$e_1$.`===`($e$)!.
\end{itemize}

Let $T$ be the type of the selector expression $e$. The parameter $p_i$ of each invocation of the method ``\lstinline!===!'' is typed with $T$ as its expected type and \code{Boolean} as the return type. It is an error if $T$ does not conform to the actual type of the parameter, as the invocation would not be applicable (\sref{sec:function-applications}). The method ``\lstinline!===!'' may be overloaded for multiple parameter types, then overloading resolution (\sref{sec:overloading-resolution}) applies as usual. 

The method ``\lstinline!===!'' is defined basically as follows:
\begin{lstlisting}
operator === ($x$: $T$): Boolean
  $\ldots$
end
\end{lstlisting}
where $x$ is the parameter name and $T$ is the expected type of the parameter, and the type of the selector expression $e$. 

The expected type of every block $b_i$ is the expected type of the whole pattern matching expression. The type of the pattern matching expression is then the weak least upper bound (\sref{sec:conformance}) of the types of all blocks $b_i$.

Multiple values can define a case pattern, for convenience. Note that no variables are bound from the case pattern to the corresponding block.





\section{Unconditional Expressions}

Unconditional expressions change the flow of programs without a condition. 

\subsection{Return Expressions}
\label{sec:return-expressions}

\paragraph{Implicit return expressions}
Implicit return expression is always the value of the last expression in a code execution path. 

\syntax\begin{lstlisting}
Result_Expr ::= Anon_Params '->' Block 
              | ['memoize'] Expr
\end{lstlisting}

\paragraph{Explicit return expressions}
Explicit return expressions unconditionally change the flow of programs by making the enclosing function definition return a value early (or return no value). 

\syntax\begin{lstlisting}
Return_Expr ::= ['memoize'] 'return' [Expr] [Cond_Modifier1]
\end{lstlisting}

A return expression ~\lstinline!return $e$!~ must occur inside the body of some enclosing method, or inside a block nested in the body of the innermost enclosing method. Unlike in Scala, the innermost enclosing method in a source program, $f$, does not need to have an explicitly declared result type, as the result type can be inferred as the weak least upper bound of all return paths, including the explicit return path. The return expression evaluates the expression $e$ and returns its value as the result of $f$. The evaluation of any statements or expressions following the return expression is omitted.The type of a return expression is \code{Nothing}.

The expression $e$ may be omitted, then the return expression \code{return} is type-checked and evaluated as if it was ~\lstinline!return ()!, typed as \code{Unit}. 

Returning from a nested block is implemented by throwing and catching a specialized exception, which may be seen by \code{throw}-\code{catch} expressions (\sref{sec:throw-catch-expressions}) between the point of return and the enclosing method. If such a block is captured and run later, at the point where the original call stack frame is long gone, the exception might propagate up the call stack that ran the captured block. Returning from anonymous functions does not affect the enclosing method. 

\paragraph{Memoized return expressions}
A returned expression may optionally be memoized, by using the keyword \code{memoize} right before the returned expression $e$ or ~\lstinline!return $e$!. In that case, arguments and reference to \code{self} are captured and stored along the returned value, so that further calls to the same method with the same arguments may be sped up significantly (\sref{sec:memoization}). Memoization is not available from within anonymous functions and blocks. 






\subsection{Structured Return Expressions}

\syntax\begin{lstlisting}
Return_Expr ::= ['memoize'] 'return' Var_Def 'do' 
                Block_Stat {semi Block_Stat} 
                'end' ['return']
\end{lstlisting}

A structured return expression is practically the same as explicit return expression. The variable defined in it has its scope extended to the following block statements, which are evaluated, and then the variable is returned. 






\subsection{Local Jump Expressions}
\label{sec:local-jump-expressions}

\syntax\begin{lstlisting}
Jump_Expr  ::= Goto_Expr | Label_Dcl
Goto_Expr  ::= 'goto' label_name [Cond_Modifier1]
Label_Dcl  ::= 'label' label_name 
             | '<<' label_name '>>'
label_name ::= variable_id | constant_id
\end{lstlisting}

Local jumps transfer control from the points of \code{goto} statements to the statements following a \code{label}. Such a jump may only occur inside of the same function, i.e. it is not possible to jump from one method to another. Also, the jump can't happen to be from outside of a loop into a loop, but the other way around is possible. The only loop expressions that may be jumped out of are the pure loop (\sref{sec:pure-loops}) and a \code{while} loop, which are not transformed as comprehensions into method calls. 






\subsection{Continuations}

\paragraph{\em Unlimited continuations}
Unlimited continuations are defined by the whole program, as the unlimited continuation allows almost arbitrary non-local jumps. The unlimited continuation is captured with \code{call/cc} function. 

\paragraph{\em Delimited continuations}
Delimited continuations are defined with \code{reset} and \code{shift} functions. Reset and shift expressions are actually not language constructs, but rather regular functions that have a native implementation capable of unconditionally changing the standard control flow of a program. Moreover, the first \code{shift} expression (which captures the delimited continuation) controls the return value of the \code{reset} expression, which overrides the implicit return expression (\sref{sec:return-expressions}).








\section{Throw, Catch \& Ensure Expressions}
\label{sec:throw-catch-expressions}

\syntax\begin{lstlisting}
Catch_Expr  ::= Catch_Expr1 | Catch_Expr2
Catch_Expr1 ::= 'begin' Block 
                'catch' semi When_Clauses
                ['ensure' semi Block_Stat {semi Block_Stat}] 'end'
                'end'
Catch_Expr2 ::= '{' Block '}'
                'catch' '{' When_Clauses '}'
                ['ensure' '{' Block_Stat {semi Block_Stat} '}']
Throw_Expr  ::= 'throw' Expr
\end{lstlisting}

A throw expression ~\lstinline!throw $e$!~ evaluates the expression $e$. The type of this expression must conform to \code{Throwable}. It is an error if $e$ evaluates to \code{nil} or ~\lstinline!()!. If there is an active \code{begin}-\code{catch} expression that handles the thrown value, evaluation is resumed with the handler, otherwise a thread executing the \code{throw} is aborted. The type of a \code{throw} expression is \code{Nothing}. 

A \code{begin}-\code{catch} expression is of the form ~\lstinline!{ $b$ } catch $h$!, where $h$ is a handler pattern matching anonymous function (\sref{sec:pattern-matching-anon-fun})
\begin{lstlisting}
{ when $p_1$ then $b_1$ $\ldots$ when $p_k$ then $b_k$ else $b_{k+1}$ } .
\end{lstlisting}

This expression is evaluated by evaluating the block $b$ -- if evaluation of $b$ does not throw any value, the result of $b$ is returned, otherwise the handler $h$ is applied to the thrown value. If the handler $h$ contains a \code{when} clause matching the thrown value, the first such clause is invoked (and may throw another value, or the same value). If the handler contains no such clause, the value is re-thrown. 

Let $T$ be the expected type of the \code{begin}-\code{catch} expression. The block $b$ is expected to conform to $T$. The handler $h$ is expected to conform to type ~\lstinline!Partial_Function[Throwable, $T$]!. The type of the \code{begin}-\code{catch} expression is the weak least upper bound (\sref{sec:conformance}) of the type of $b$ and the result type of $h$. 

A \code{begin}-\code{ensure} expression ~\lstinline!{ $b$ } ensure { $e$ }!~ evaluates the block $b$. If evaluation of $b$ does not cause any value to be thrown, the block $e$ is evaluated. If any value is thrown during evaluation of $e$, the evaluation of the whole expression is aborted with the thrown value. If no value is thrown during evaluation of $e$, the result of $b$ is returned as the result of the whole expression, unless $e$ contains an explicit \code{return} (\sref{sec:return-expressions}) -- in that case, the value returned from $e$ replaces the value returned from $b$, even if $b$ returns a value explicitly. 

If a value is thrown during evaluation of $b$, the \code{ensure} block $e$ is also evaluated. If another value is thrown during evaluation of $e$, evaluation of the whole expression is aborted with the new thrown value and the previous is discarded. If no value is thrown during evaluation of $e$, the original value thrown from $b$ is re-thrown once evaluation of $e$ has completed, unless $e$ again contains an explicit \code{return} (\sref{sec:return-expressions}) -- in that case, the value thrown from $b$ is discarded, and the value returned from $e$ is returned. 


The block $b$ is expected to conform to the expected type of the whole expression and the \code{ensure} block $e$ is expected to conform to type \code{Unit}. 

An expression ~\lstinline!{ $b$ } catch $e_1$ ensure { $e_2$ }!~ is a shorthand for ~\lstinline!{{ $b$ } catch $e_1$ } ensure { $e_2$ }!. 





\subsection{Raise Expressions}

\syntax\begin{lstlisting}
Raise_Expr ::= 'raise' Raiseable
Raiseable  ::= string_literal
             | Path [',' string_literal]
             | Expr
\end{lstlisting}

A raise expression ~\lstinline!raise $e$!~ is similar to ~\lstinline!throw $e$! (\sref{sec:throw-catch-expressions}), it throws a value (raises an error) that is expected to be of type \code{Raiseable}. It has three variants: 
\begin{itemize}
\item[] \lstinline!raise $s$!, where $s$ is a string provided to constructor of the type \code{Runtime_Error}. 
\item[] \lstinline!raise $T$, $s$!, where $s$ is a string provided to constructor of the type $T$. 
\item[] \lstinline!raise $e$!, where $e$ is an expression, whose type is expected to conform to \code{Raiseable}, and whose result value will be raised after its evaluation. 
\item[] \lstinline!raise!, which raises a value of type \code{Runtime_Error} without any message. Such errors should not propagate outside of the method that raises them. 
\end{itemize}

\code{Raiseable} is a subtype of \code{Throwable}. 







\subsection{Rescue Expressions}

\syntax\begin{lstlisting}
Rescue_Expr  ::= [Label_Dcl] (Rescue_Expr1 | Rescue_Expr2)
Rescue_Expr1 ::= 'begin' Block 
                 'rescue' [Pattern [Guard]] semi Rescue_Block
                 {'rescue' [Pattern [Guard]] semi Rescue_Block }
                 ['ensure' semi Block_Stat {semi Block_Stat}] 'end'
Rescue_Expr2 ::= '{' Block '}' 
                 'rescue' [Pattern [Guard]] '{' Rescue_Block '}'
                 {'rescue' [Pattern [Guard]] '{' Rescue_Block '}'}
                 ['ensure' '{' Block_Stat {semi Block_Stat} '}']
Fun_Stats    ::= Block
                 {'rescue' [Pattern [Guard]] semi Rescue_Block }
                 ['ensure' semi Block_Stat {semi Block_Stat}]
Rescue_Block ::= {Rescue_Stat semi} [Result_Expr]
Rescue_Stat  ::= Block_Stat | Retry_Expr
Retry_Expr   ::= 'retry' [label_name] [Cond_Modifier1]
\end{lstlisting}

Rescue expression ~\lstinline!rescue $h$!~ is similar to catch expression (\sref{sec:throw-catch-expressions}), with two major differences: First, each \code{rescue} is followed by \code{when} clause; second, all \code{rescue} expressions in the same scope form together a handler $h$, where rules from catch expressions apply, only that $h$ is expected to conform to type ~\lstinline!Partial_Function[Raiseable, $T$]!, where $T$ is the expected type of the whole \code{begin}-\code{rescue} expression. 

The syntactic overlap with \code{ensure} expression signifies that the same expression with the exact same behavior may be used with \code{rescue} expressions as well. 

Optionally, the \code{rescue} may appear before any \code{begin} keyword, being connected to the function body instead as the expression protected agains raiseables (this does not apply to \code{catch}), where the \code{begin} is implied to be at the very start of the function's body. 

The ~\lstinline!retry $l$!~ expression is available inside of each raiseable handler block, and evaluating it restarts evaluation of the whole expression since \code{begin} of the labeled rescue expression, or if no label is given, then of the innermost (if nested) rescue expression. Again, it is not available in catch handler block. 

The keyword ~\lstinline[language=Java]!try!~ is not available in Coral -- in Coral, there is no trying, there is doing or not doing.  





\section{Anonymous Functions}
\label{sec:anonymous-functions}

\syntax\begin{lstlisting}
Anon_Fun        ::= Anon_Params '->' '{' Block '}'
Result_Expr     ::= Anon_Params '->' Block 
Anon_Params     ::= Bindings {'->' Bindings}
                  | Param_Clause
                  | '(' ['implicit'] variable_id ')'
                  | '(' [Nameless_Param] ')'
Bindings        ::= '(' Binding {',' Binding} ')'
Binding         ::= (variable_id | '_') [':' Type]
Nameless_Params ::= Nameless_Param {',' Nameless_Param}
Nameless_Param  ::= '_' [':' Compound_Type]
\end{lstlisting}

The anonymous function ~\lstinline!($x_1$: $T_1 \commadots x_n$: $T_n$) -> { $b$ }!~ maps parameters $x_i$ of types $T_i$ to a result value given by evaluation of block $b$. The scope of each formal parameter $x_i$ is $e$. Formal parameters must have pairwise distinct names.\footnote{In future versions of Coral, a syntax where curly brackets are not required to be surrounding an anonymous function's body may be allowed.}

If the expected type of an anonymous function is of the form ~\lstinline!Function_$n$[$S_1 \commadots S_n$, $R$]!, the expected type of $b$ is $R$ and the type $T_i$ of any of the parameters $x_i$ can be omitted, in which case $T_i = S_i$ is assumed. If there is no expected type of the anonymous function, then for each parameter $x_i$ which has no explicit type $T_i$, $T_i$ is assumed to be \code{Object}, and the type of the result value is also assumed to be \code{Object}. 

Note that anonymous functions explicitly specify all of their parameters, unlike anonymous pattern matching functions (\sref{sec:pattern-matching-anon-fun}), where the parameters are inferred from the expected type. 

The anonymous function is evaluated as the following expression:
\begin{lstlisting}
(Function_$n$[$S_1 \commadots S_n$, $T$] with {
  def apply ($x_1$: $T_1 \commadots x_n$: $T_n$): $T$ := { $b$ }
}).new
\end{lstlisting}

In the case of a single untyped formal parameter, ~\lstinline!($x$) -> { $b$ }!~ can be abbreviated to ~\lstinline!$x$ -> { $b$ }!. If an anonymous function ~\lstinline!($x$: $T$) -> { $b$ }!~ with a single typed parameter appears as the result of expression of a block, it can be abbreviated to ~\lstinline!$x$: $T$ -> { $b$ }!.

A formal parameter may also be a wildcard represented by an underscore ``\lstinline!_!''. In that case, a fresh name for the parameter is chosen arbitrarily. 

A parameter of an anonymous function may optionally be preceded by an \code{implicit} modifier. In that case the parameter is labeled \code{implicit} (\sref{sec:implicit-params-views}); however the parameter section itself does not count as an implicit parameter section in the sense of (\sref{sec:implicit-parameters}). Such a parameter ~\lstinline!implicit $x_i$!~ is then added transparently to the block $b$ as ~\lstinline!implicit val $y_i$ := $x_i$!, where $y_i$ is a fresh name. Also, therefore arguments to anonymous functions always have to be given explicitly. 
% TBD: decide whether to add placeholder syntax: _.map(_ + 1)

\example Examples of anonymous functions:
\begin{lstlisting}
// identity function
x -> { x }

// curried function composition
f -> g -> x -> { f(g(x)) }

// a summation function
(x: Integer, y: Integer) -> { x + y }

// a function which takes an empty parameter list,
// increments a non-local variable (via closure)
// and returns the new value
() -> { count += 1; count }

// a function that ignores its argument and returns 5
_ -> { 5 }
\end{lstlisting}







\subsection{Method Values}
\label{sec:method-values}

\syntax\begin{lstlisting}
Simple_Expr ::= '&' Simple_Expr1
              | '&' '(' Simple_Expr1 ')'
\end{lstlisting}

The expression ~\lstinline!&$e$!~ (or alternatively ~\lstinline!&($e$)!) is well-formed if $e$ is of method type or if $e$ is a call-by-name parameter. If $e$ is a method with parameters, ~\lstinline!&$e$!~ represents $e$ converted to a function type by eta expansion (\sref{sec:eta-expansion}). If $e$ is a parameterless method or call-by-name parameter of type ~\lstinline!=> $T$!, ~\lstinline!&$e$!~ represents the function of type ~\lstinline!() -> $T$!, which evaluates $e$ when it is applied to the empty parameter list ~\lstinline!()!. 

\example The method values in the left column are each equivalent to the anonymous functions (\sref{sec:anonymous-functions}) on their right. 
\begin{lstlisting}[deletekeywords={range}]
&(Math.sin)                (x)      -> { Math.sin(x) }
&(Array.range)             (x1, x2) -> { Array.range(x1, x2) }
&(List.map_2)              (x1, x2) -> (x3) -> { List.map_2(x1, x2)(x3) }
&(List.map_2(xs, ys))      (x)      -> { List.map_2(xs, xy)(x) }
&(42.`*`)                  (x)      -> { 42 * x }
\end{lstlisting}

Note that if $e$ resolves to a parameterless method of type ~\lstinline!() -> $T$!~ or if $e$ has a method type ~\lstinline!() $\mapsto\ T$!, it is evaluated to type $T$ (\sref{sec:method-conversions}) -- and the method value syntax provides a way to prevent this. 





\section{Anonymous Classes}
\label{sec:anonymous-classes}

\syntax\begin{lstlisting}
Anon_Class      ::= ['class' [Class_Param_Clauses] 'extends'] 
                    [Early_Defs] Anon_Class_Tmpl
Anon_Class_Tmpl ::= Class_Parents 'with' '{' [Template_Body] '}'
\end{lstlisting}

Anonymous classs are a mechanism to implement an abstract class or override a concrete class ``ad hoc'', in place where needed, without needing to create a new constant (although as an expression, the anonymous class definition can indeed be assigned to a constant and gain its name). Anonymous classes can't be type constructors (\sref{sec:type-constructors}). 

A minimal anonymous class expression is of the form ~\lstinline!$c$ with { $t$ }!, where $c$ is the class that the anonymous class inherits from (can be even \code{Object}), and $t$ is the template of the anonymous class. The anonymous class inherits all traits mixed into this parent class, and can itself include or prepend more traits (via the \code{Class_Parents} syntax element). 

Optionally, the anonymous class may define its own primary constructor parameters, in which case the form of the anonymous class is ~\lstinline!class ($\ps_1$)$\ldots$($\ps_n$) extends $c$ with { $t$ }!, where $\ps_1$ to $\ps_n$ are the primary constructor parameters. Superclass constructor arguments may be specified in any case. 






\section{Statements}
\label{sec:statements}

\syntax\begin{lstlisting}
Block_Stat    ::= Use
                | {Annotation} ['implicit'] Def
                | {Annotation} {Local_Modifier} Tmpl_Def
                | Expr
                | Alias_Expr
                | ()
Template_Stat ::= Use
                | {Annotation} {Modifier} Def
                | {Annotation} {Modifier} Dcl
                | Expr
                | Alias_Expr
                | ()
Fun_Stats     ::= [Fun_Stat {semi Fun_Stat}] Return_Expr
                | Block
                  {'rescue' [Pattern [Guard]] semi Block }
                  ['ensure' semi Block_Stat {semi Block_Stat}]
Fun_Stat      ::= Block_Stat
Fun_Dec_Expr  ::= {Annotation} Dcl
                | {Annotation} ['implicit'] Def
                | 'transparent'
                | 'opaque'
                | 'native' [Expr]
                | ()
Alias_Expr    ::= 'alias' symbol_literal 'is' symbol_literal
\end{lstlisting}

Statements occur as parts of blocks and templates. Despite their name, they are actually generally expressions as well, except that for some statements, their value is not much of a use, i.e. use clauses, whose value is a \code{nil}, or the empty statement/expression, whose value is again \code{nil}. 

Function statements is an umbrella term for a series of statements and expressions, so their effective value is more complex. 

Statement can be an import via a use clause (\sref{sec:use-clauses}), a definition or an expression, or it can be empty. Statements used in the template of a class definition can also be declarations. 








\section{Implicit Conversions}
\label{sec:implicit-conversions}

\subsection{Value Conversions}
\label{sec:value-conversions}

\subsection{Method Conversions}
\label{sec:method-conversions}

\subsection{Overloading Resolution}
\label{sec:overloading-resolution}

\subsection{Local Type Inference}
\label{sec:local-type-inference}

\subsection{Eta-Expansion}
\label{sec:eta-expansion}

\subsection{Dynamic Member Selection}
\label{sec:dynamic-member-selection}

\section{Workflows}
\label{sec:workflows}



