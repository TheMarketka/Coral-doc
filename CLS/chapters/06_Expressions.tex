%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Expressions}

% TBD: update this chapter and the syntax gradually as the CLS evolves

\syntax\begin{lstlisting}
Expr        ::= Cond_Expr
              | Loop_Expr
              | Rescue_Expr
              | Raise_Expr
              | Throw_Expr
              | Catch_Expr
              | Return_Expr
              | Assign_Expr
              | Update_Expr
              | Yield_Expr
              | Infix_Expr
              | Simple_Expr
              | Match_Expr
              | Binding
              | Annot_Expr
              | Cast_Expr
              | Use_Expr
              | Jump_Expr
              | Anon_Fun
Infix_Expr  ::= Prefix_Expr
              | Infix_Expr [op_id Infix_Expr]
Simple_Expr ::= '(' Anon_Class ')'
              | Block_Expr
              | Simple_Expr1 ['_']
Result_Expr ::= Anon_Params '->' Block 
              | ['memoize'] Expr
\end{lstlisting}

Expressions are composed of various keywords, operators and operands. Expression forms are discussed subsequently. 







\section{Expression Typing}

The typing of expressions is often relative to some {\em expected type} (which might be undefined). When we write ``expression $e$ is expected to conform to type $T$'', we mean:
\begin{enumerate}
\item The expected type of $e$ is $T$.
\item The type of expression $e$ must conform to $T$. 
\end{enumerate}

Usually, the type of the expression is defined by the last element of an execution branch, as discussed subsequently with each expression kind. 

What we call ``statement'', in context of Coral is in fact yet another kind of an expression, and those expressions themselves always have a type and a value. 





\section{Literals}

\syntax\begin{lstlisting}
Simple_Expr1 ::= literal
\end{lstlisting}

Typing of literals is as described in (\sref{sec:literals}); their evaluation is immediate, including non-scalar literals (collection literals). 






\subsection{The Nil Value}

\syntax\begin{lstlisting}
Simple_Expr1 ::= 'nil'
\end{lstlisting}

The \code{nil} value is of type \code{Nothing}, and is thus compatible with every type that is nullable (\sref{sec:nullability}), either preferably or explicitly.

The \code{nil} represents a ``no object'', and is itself represented by an object. This object overrides methods in \code{Object} as follows: 
\begin{itemize}
\item 
\lstinline!equals($x$)! and \lstinline!=($x$)! return \code{yes} if the argument $x$ is also the \code{nil} object. 

\item 
\lstinline@!=($x$)@ return \code{yes} if the argument $x$ is not the \code{nil} object.

\item
\lstinline[mathescape=false]!as_instance_of:[$T]()! returns always \code{nil}. 

\item
\lstinline!hash_code()! returns \code{0}. 
\end{itemize}

A reference to any other member of the \code{nil} object causes \code{Method_Not_Found_Error} or \code{Member_Not_Found_Error} to be raised, unless the member in fact exists.\footnote{It is even possible to use a refinement to actually implement some methods of \code{nil} locally (preferred approach), or globally implement those methods (discouraged, causes warnings).} 






\section{Designators}

\syntax\begin{lstlisting}
Simple_Expr1 ::= Path
               | Simple_Expr '.' importable_id
\end{lstlisting}

A designator refers to a named term. It can be a {\em simple name} or a {\em selection}.






\section{Self, This \& Super}
\label{sec:self-this-super}

\syntax\begin{lstlisting}
Simple_Expr1 ::= [Container_Path '.'] 'self'
                 ['.' (constant_id | variable_id | function_id)]
               | [Container_Path '.'] 'this'
                 ['.' (constant_id | variable_id | function_id)]
               | [Container_Path '.'] 'super' 
                 [Class_Qualifier] 
                 ['.' (constant_id | variable_id | function_id)]
               | [Container_Path '.'] 'self' '[' 'cloned' ']'
                 '.' ivar_id
               | ivar_id
               | cvar_id
\end{lstlisting}

The expression \code{self} stands always for the current instance in the context and function resolution searches in the actual class of the instance. 

The expression \code{this} is the same as \code{self}, except that function resolution searches from the class that this expression appears in, possibly skipping overrides. 

% TBD: expand the description, include ivars, cvars






\section{Use Expressions}
\label{sec:use-expressions}

\syntax\begin{lstlisting}
Use_Expr ::= 'use' Simple_Expr 'as' 
             [variable_id ':'] Type [Block_Expr]
\end{lstlisting}

Use expressions are similar to type cast expressions. Their intention is to rebind an expression to a specific type, and then either have this type be effective in the same scope from that point onward, or, if a \code{Block_Expr} is syntactically given, only in the scope of that block expression. If a block is given, then the return value of the block is the value of this expression, otherwise, the value retrieved by evaluation of \code{Simple_Expr} is the value of this expression. 








\section{Function Applications}
\label{sec:function-applications}

\syntax\begin{lstlisting}
Simple_Expr1   ::= Simple_Expr1 Argument_Exprs 
Argument_Exprs ::= '(' [Arg_Exprs] ')' [Block_Expr]
                 | '(' [Arg_Exprs ','] '*' Expr ')' [Block_Expr]
                 | '(' [Arg_Exprs ','] ['*' Expr ','] '**' Expr ')'
                   [Block_Expr]
                 | Arg_Exprs [Block_Expr2]
                 | [Arg_Exprs ','] '*' Expr [Block_Expr2]
                 | [Arg_Exprs ','] ['*' Expr ','] '**' Expr
                   [Block_Expr2]
                 | Block_Expr
Arg_Exprs      ::= Arg_Expr {',' Arg_Expr}
Arg_Expr       ::= Expr
\end{lstlisting}

% TBD: extend this section, note tuple of arguments






\subsection{Named and Optional Arguments}
\label{sec:named-optional-arguments}

\subsection{By-Name Arguments}
\label{sec:by-name-arguments}

\subsection{Input \& Output Arguments}
\label{sec:io-arguments}

\subsection{Function Compositions \& Pipelines}






\section{Type Applications}
\label{sec:type-applications}

\syntax\begin{lstlisting}
Simple_Expr1 ::= Simple_Expr (Type_Args [UoM_Args] | UoM_Args)
\end{lstlisting}






\section{Tuples}
\label{sec:tuples}

\syntax\begin{lstlisting}
Simple_Expr ::= '(' [Exprs] ')'
\end{lstlisting}

A tuple expression ~\lstinline!($e_1 \commadots e_n$)!~ is an alias for the class instance creation ~\lstinline!Tuple_$n$($e_1 \commadots e_n$)!, where $n \geq 2$. The empty tuple ~\lstinline!()!~ is the unique value of type \code{Unit}. A tuple with only one value is only the value itself, without being wrapped in a tuple. 






\section{Instance Creation Expressions}
\label{sec:instance-creation-exprs}

Unlike languages like Java, Scala, C\# and similar, Coral does not have dedicated language construct for creating new instances of classes. Instead, all such attempts are made through the ~\lstinline!Class#new!~ method (not to be confused with ~\lstinline@Class.new@), which in the end\footnote{Because constructor currying can happen, the constructor is invoked by a native implementation from outside of the \code{new} method, by the curried function, which is a mechanism inaccessible to users otherwise than via the constructor definition.} has all arguments for a constructor, which gets invoked by a native implementation. 






\section{Blocks}

\syntax\begin{lstlisting}
Block_Expr  ::= Block_Expr1 | Block_Expr2
Block_Expr1 ::= '{' [Block_Args semi] Block '}'
Block_Expr2 ::= 'do' [Block_Args semi] Block 'end'
Block_Args  ::= '|' [Params] '|' [':' Type]
Block       ::= {Block_Stat semi} [Result_Expr]
\end{lstlisting}






\section{Yield Expressions}

\syntax\begin{lstlisting}
Yield_Expr ::= 'yield' '(' [Arg_Exprs] ')'
             | '(' [Arg_Exprs ','] '*' Expr ')'
             | '(' [Arg_Exprs ','] ['*' Expr ','] '**' Expr ')'
             | [Arg_Exprs]
             | [Arg_Exprs ','] '*' Expr
             | [Arg_Exprs ','] ['*' Expr ','] '**' Expr
\end{lstlisting}







\section{Prefix \& Infix Operations}
\label{sec:prefix-infix-ops}

\syntax\begin{lstlisting}
Infix_Expr  ::= Prefix_Expr
              | Infix_Expr [op_id Infix_expr]
Prefix_Expr ::= [op_id] Simple_Expr
\end{lstlisting}






\subsection{Prefix Operations}

\subsection{Infix Operations}

\subsection{Assignment Operators}

\section{Typed Expressions}

\syntax\begin{lstlisting}
Cast_Expr ::= Infix_Expr 'as' Type
\end{lstlisting}







\section{Annotated Expressions}
\label{sec:annotated-exprs}

\syntax\begin{lstlisting}
Annot_Expr ::= Annotation {Annotation} Infix_Expr
\end{lstlisting}








\section{Assignments}

\syntax\begin{lstlisting}
Assign_Expr ::= [Simple_Expr '.'] variable_id ':=' Expr
Update_Expr ::= Simple_Expr1 Argument_Exprs ':=' Expr
\end{lstlisting}








\section{Conditional Expressions}

\syntax\begin{lstlisting}
Cond_Expr        ::= Cond_Block_Expr | Cond_Mod_Expr
Cond_Block_Expr  ::= Cond_Block_Expr1 | Cond_Block_Expr2
Cond_Block_Expr1 ::= 'if' Expr ('then' | semi) Expr 
                     {'elsif' Expr ('then' | semi) Expr}
                     ['else' Expr] 'end' ['if']
Cond_Block_Expr2 ::= 'unless' Expr ('then' | semi) Expr 
                     {'elsif' Expr ('then' | semi) Expr}
                     ['else' Expr] 'end' ['unless']
Cond_Mod_Expr    ::= Expr Cond_Modifier
Cond_Modifier    ::= Cond_Modifier1
                     ['else' Infix_Expr]
Cond_Modifier1   ::= ('if' | 'unless') Infix_Expr 
\end{lstlisting}








\section{Loop Expressions}

\subsection{Iterable For Expressions}

\syntax\begin{lstlisting}
Loop_Expr       ::= [Label_Dcl] 'for' Val_Dcl 'in' ['reverse'] Expr 
                    ['step' Expr] For_Loop
For_Loop        ::= 'loop' Expr 'end' ['loop']
                  | '{' Loop_Block_Expr '}'
Loop_Block_Expr ::= {Block_Stat | Loop_Ctrl_Expr}
\end{lstlisting}






\subsection{Loop Control Expressions}

\syntax\begin{lstlisting}
Loop_Ctrl_Expr ::= Break_Expr
                 | Skip_Expr
                 | Next_Expr
Break_Expr     ::= 'break' [label_id] [Cond_Modifier1]
Skip_Expr      ::= 'skip' [integer_literal] [Cond_Modifier1]
Next_Expr      ::= 'next' [label_id] [Cond_Modifier1]
\end{lstlisting}






\subsection{While \& Until Loop Expressions}

\syntax\begin{lstlisting}
Loop_Expr     ::= [Label_Dcl] ('while' | 'until') Expr For_Loop
                | Loop_Mod_Expr
Loop_Mod_Expr ::= Expr Loop_Modifier
Loop_Modifier ::= ('while' | 'until') Expr
\end{lstlisting}





\subsection{Pure Loops}

\syntax\begin{lstlisting}
Loop_Expr  ::= [Label_Dcl] 'loop'
               (semi Loop_Block_Expr 'end' ['loop'] | 
               '{' Loop_Block_Expr '}')
\end{lstlisting}






\section{Generator Expressions}

\syntax\begin{lstlisting}
Loop_Expr      ::= 'for' (Generator_Iter | Generator_Expr)
Generator_Iter ::= '(' Enumerators ')' (Expr | For_Loop)
Generator_Expr ::= '{' Enumerators semi 'yield' Expr '}'
Enumerators    ::= Generator {semi Enumerator}
Enumerator     ::= Generator
                 | Enumerator_Guard
                 | Pattern1 ':=' Expr
Generator      ::= Pattern1 '<-' Expr [Guard]
Guard          ::= Cond_Modifier1
\end{lstlisting}






\section{Collection Comprehensions}

\syntax\begin{lstlisting}
List_Literal       ::= '%' Collection_Flags '[' 'for' Generator_Expr ']'
Dictionary_Literal ::= '%' Collection_Flags '{' 'for' Generator_Expr '}'
Bag_Literal        ::= '%' Collection_Flags '(' 'for' Generator_Expr ')'
\end{lstlisting}

Collection comprehensions extend the syntax of collection ``literals''\footnote{Pure literals are terminal symbols in the language, but collection literals are wrappers around virtually any expression.}, so that collections may be defined by not their explicit values, but by a function that generates them -- and that function is a generator. Only tuple literals don't have collection comprehension, due to their special nature within the language. 






\section{Pattern Matching \& Case Expressions}

\syntax\begin{lstlisting}
Match_Expr     ::= Pat_Match_Expr | Case_Expr
Pat_Match_Expr ::= 'match' Simple_Expr1 Match_Body
Match_Body     ::= semi When_Clauses 'end' ['match']
                 | '{' When_Clauses '}'
When_Clauses   ::= When_Clause {['next'] semi When_Clause} 
                   [['next'] 'else' Block]
When_Clause    ::= 'when' Pattern [Guard] ('then' | semi) Block
Case_Expr      ::= 'case' Simple_Expr1 Case_Body
Case_Body      ::= semi Case_Clauses 'end' ['case']
                 | '{' Case_Clauses '}'
Case_Clauses   ::= Case_Clause {['next'] semi Case_Clause}
                   [['next'] 'else' Block]
Case_Clause    ::= 'when' Case_Patterns ('then' | semi) Block
Case_Patterns  ::= Case_Pattern {',' Case_Pattern}
Case_Pattern   ::= Stable_Id
                 | literal [('..' | '...') literal]
                 | variable_id
                 | Infix_Expr
\end{lstlisting}






\section{Unconditional Expressions}

Unconditional expressions change the flow of programs without a condition. 

\subsection{Return Expressions}
\label{sec:return-expressions}

\paragraph{Implicit Return Expressions}
Implicit return expression is always the value of the last expression in a code execution path. 

\syntax\begin{lstlisting}
Result_Expr ::= Anon_Params '->' Block 
              | ['memoize'] Expr
\end{lstlisting}

\paragraph{Explicit Return Expressions}
Explicit return expressions unconditionally change the flow of programs by making the enclosing function definition return a value early (or return no value). 

\syntax\begin{lstlisting}
Return_Expr ::= ['memoize'] 'return' [Expr] [Cond_Modifier1]
\end{lstlisting}






\subsection{Structured Return Expressions}

\syntax\begin{lstlisting}
Return_Expr ::= ['memoize'] 'return' Var_Def 'do' 
                Block_Stat {semi Block_Stat} 
                'end' ['return']
\end{lstlisting}






\subsection{Local Jump Expressions}

\syntax\begin{lstlisting}
Jump_Expr  ::= Goto_Expr | Label_Dcl
Goto_Expr  ::= 'goto' label_name [Cond_Modifier1]
Label_Dcl  ::= 'label' label_name 
             | '<<' label_name '>>'
label_name ::= variable_id | constant_id
\end{lstlisting}

Local jumps transfer control from \code{goto} statements to the statements following a \code{label}. 


\subsection{Continuations}

\paragraph{\em Unlimited continuations}
Unlimited continuations are defined by the whole program, as the unlimited continuation allows almost arbitrary non-local jumps. The unlimited continuation is captured with \code{call/cc} function. 

\paragraph{\em Delimited continuations}
Delimited continuations are defined with \code{reset} and \code{shift} functions. Reset and shift expressions are actually not language constructs, but rather regular functions that have a native implementation capable of unconditionally changing the standard control flow of a program. Moreover, the first \code{shift} expression (which captures the delimited continuation) controls the return value of the \code{reset} expression, which overrides the implicit return expression (\sref{sec:return-expressions}).








\section{Throw \& Catch Expressions}

\syntax\begin{lstlisting}
Catch_Expr  ::= Catch_Expr1 | Catch_Expr2
Catch_Expr1 ::= 'begin' Block 
                'catch' semi When_Clauses
                'end'
Catch_Expr2 ::= '{' Block '}'
                'catch' '{' When_Clauses '}'
Throw_Expr  ::= 'throw' Expr
\end{lstlisting}







\subsection{Raise Expressions}

\syntax\begin{lstlisting}
Raise_Expr ::= 'raise' Raiseable
Raiseable  ::= string_literal
             | Container_Path [',' string_literal]
             | Expr
\end{lstlisting}






\subsection{Rescue \& Ensure Expressions}

\syntax\begin{lstlisting}
Rescue_Expr  ::= Rescue_Expr1 | Rescue_Expr2
Rescue_Expr1 ::= 'begin' Block 
                 {'rescue' [Pattern [Guard]] semi Block }
                 ['ensure' semi Block_Stat {semi Block_Stat}] 'end'
Rescue_Expr2 ::= '{' Block '}' 
                 {'rescue' [Pattern [Guard]] '{' Block '}'}
                 ['ensure' '{' Block_Stat {semi Block_Stat} '}']
Fun_Stats    ::= Block
                 {'rescue' [Pattern [Guard]] semi Block }
                 ['ensure' semi Block_Stat {semi Block_Stat}]
\end{lstlisting}






\section{Anonymous Functions}
\label{sec:anonymous-functions}

\syntax\begin{lstlisting}
Anon_Fun        ::= Anon_Params '->' '{' Block '}'
Result_Expr     ::= Anon_Params '->' Block 
Anon_Params     ::= Bindings {'->' Bindings}
                  | Param_Clause
                  | '(' ['implicit'] variable_id ')'
                  | '(' [Nameless_Param] ')'
Bindings        ::= '(' Binding {'' Binding} ')'
Binding         ::= (variable_id | '_') [':' Type]
Nameless_Params ::= Nameless_Param {',' Nameless_Param}
Nameless_Param  ::= '_' [':' Compound_Type]
\end{lstlisting}







\subsection{Method Values}

\syntax\begin{lstlisting}
Simple_Expr ::= Simple_Expr1 '_'
\end{lstlisting}

\example The method values in the left column are each equivalent to the anonymous functions (\sref{sec:anonymous-functions}) on their right. 
\begin{lstlisting}[deletekeywords={range}]
Math.sin _                (x)      -> { Math.sin(x) }
Array.range _             (x1, x2) -> { Array.range(x1, x2) }
List.map_2 _              (x1, x2) -> (x3) -> { List.map_2(x1, x2)(x3) }
List.map_2(xs, ys) _      (x)      -> { List.map_2(xs, xy)(x) }
42.* _                    (x)      -> { 42 * x }
\end{lstlisting}







\section{Anonymous Classes}
\label{sec:anonymous-classes}

\syntax\begin{lstlisting}
Anon_Class      ::= ['class' [Class_Param_Clauses] 'extends'] 
                    [Early_Defs] Anon_Class_Tmpl
Anon_Class_Tmpl ::= Class_Parents 'with' '{' [Template_Body] '}'
\end{lstlisting}

Anonymous classs are a mechanism to implement an abstract class or override a concrete class ``ad hoc'', in place where needed, without needing to create a new constant (although as an expression, the anonymous class definition can indeed be assigned to a constant and gain its name). Anonymous classes can't be type constructors (\sref{sec:type-constructors}). 

A minimal anonymous class expression is of the form ~\lstinline!$c$ with { $t$ }!, where $c$ is the class that the anonymous class inherits from (can be even \code{Object}), and $t$ is the template of the anonymous class. The anonymous class inherits all traits mixed into this parent class, and can itself include or prepend more traits (via the \code{Class_Parents} syntax element). 

Optionally, the anonymous class may define its own primary constructor parameters, in which case the form of the anonymous class is ~\lstinline!class ($\ps_1$)$\ldots$($\ps_n$) extends $c$ with { $t$ }!, where $\ps_1$ to $\ps_n$ are the primary constructor parameters. Superclass constructor arguments may be specified in any case. 






\section{Statements}

\syntax\begin{lstlisting}
Block_Stat    ::= Use
                | {Annotation} ['implicit'] Def
                | {Annotation} {Local_Modifier} Tmpl_Def
                | Expr
                | ()
Template_Stat ::= Use
                | {Annotation} {Modifier} Def
                | {Annotation} {Modifier} Dcl
                | Expr
                | ()
Fun_Stats     ::= [Fun_Stat {semi Fun_Stat}] Return_Expr
                | Block
                  {'rescue' [Pattern [Guard]] semi Block }
                  ['ensure' semi Block_Stat {semi Block_Stat}]
Fun_Stat      ::= Block_Stat
Fun_Dec_Expr  ::= {Annotation} Dcl
                | {Annotation} ['implicit'] Def
                | 'transparent'
                | 'opaque'
                | 'native' [Expr]
                | ()
\end{lstlisting}

Statements occur as parts of blocks and templates. Despite their name, they are actually generally expressions as well, except that for some statements, their value is not much of a use, i.e. use clauses, whose value is a \code{nil}, or the empty statement/expression, whose value is again \code{nil}. 

Function statements is an umbrella term for a series of statements and expressions, so their effective value is more complex. 

Statement can be an import via a use clause (\sref{sec:use-clauses}), a definition or an expression, or it can be empty. Statements used in the template of a class definition can also be declarations. 








\section{Conversions}

\subsection{Explicit Conversions}

\subsection{Implicit Conversions}
\label{sec:implicit-conversions}

\section{Workflows}
\label{sec:workflows}



