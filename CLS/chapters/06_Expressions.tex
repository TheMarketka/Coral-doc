%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Expressions}

% TBD: update this chapter and the syntax gradually as the CLS evolves

\syntax\begin{lstlisting}
Expr        ::= Cond_Expr
              | Loop_Expr
              | Rescue_Expr
              | Raise_Expr
              | Throw_Expr
              | Catch_Expr
              | Return_Expr
              | Assign_Expr
              | Update_Expr
              | Yield_Expr
              | Infix_Expr
              | Simple_Expr
              | Match_Expr
              | Binding
              | Annot_Expr
              | Cast_Expr
              | Use_Expr
Infix_Expr  ::= Prefix_Expr
              | Infix_Expr [op_id Infix_Expr]
Simple_Expr ::= '(' Anon_Class ')'
              | Block_Expr
              | Simple_Expr1 ['_']
\end{lstlisting}

Expressions are composed of various keywords, operators and operands. Expression forms are discussed subsequently. 







\section{Expression Typing}

The typing of expressions is often relative to some {\em expected type} (which might be undefined). When we write ``expression $e$ is expected to conform to type $T$'', we mean:
\begin{enumerate}
\item The expected type of $e$ is $T$.
\item The type of expression $e$ must conform to $T$. 
\end{enumerate}

Usually, the type of the expression is defined by the last element of an execution branch, as discussed subsequently with each expression kind. 

What we call ``statement'', in context of Coral is in fact yet another kind of an expression, and those expressions themselves always have a type and a value. 





\section{Literals}

\syntax\begin{lstlisting}
Simple_Expr1 ::= literal
\end{lstlisting}

Typing of literals is as described in (\sref{sec:literals}); their evaluation is immediate, including non-scalar literals (collection literals). 






\subsection{The Nil Value}

\syntax\begin{lstlisting}
Simple_Expr1 ::= 'nil'
\end{lstlisting}

The \code{nil} value is of type \code{Nothing}, and is thus compatible with every type that is nullable (\sref{sec:nullability}), either preferably or explicitly.

The \code{nil} represents a ``no object'', and is itself represented by an object. This object overrides methods in \code{Object} as follows: 
\begin{itemize}
\item 
\lstinline!equals($x$)! and \lstinline!=($x$)! return \code{yes} if the argument $x$ is also the \code{nil} object. 

\item 
\lstinline@!=($x$)@ return \code{yes} if the argument $x$ is not the \code{nil} object.

\item
\lstinline[mathescape=false]!as_instance_of:[$T]()! returns always \code{nil}. 

\item
\lstinline!hash_code()! returns \code{0}. 
\end{itemize}

A reference to any other member of the \code{nil} object causes \code{Method_Not_Found_Error} or \code{Member_Not_Found_Error} to be raised, unless the member in fact exists.\footnote{It is even possible to use a refinement to actually implement some methods of \code{nil} locally (preferred approach), or globally implement those methods (discouraged, causes warnings).} 






\section{Designators}

\syntax\begin{lstlisting}
Simple_Expr1 ::= Path
               | Simple_Expr '.' importable_id
\end{lstlisting}

A designator refers to a named term. It can be a {\em simple name} or a {\em selection}.






\section{Self, This \& Super}
\label{sec:self-this-super}

\syntax\begin{lstlisting}
Simple_Expr1 ::= [Container_Path '.'] 'self'
                 ['.' (constant_id | variable_id | function_id)]
               | [Container_Path '.'] 'this'
                 ['.' (constant_id | variable_id | function_id)]
               | [Container_Path '.'] 'super' 
                 [Class_Qualifier] 
                 ['.' (constant_id | variable_id | function_id)]
               | [Container_Path '.'] 'self' '[' 'cloned' ']'
                 '.' ivar_id
               | ivar_id
               | cvar_id
\end{lstlisting}

The expression \code{self} stands always for the current instance in the context and function resolution searches in the actual class of the instance. 

The expression \code{this} is the same as \code{self}, except that function resolution searches from the class that this expression appears in, possibly skipping overrides. 

% TBD: expand the description, include ivars, cvars






\section{Use Expressions}
\label{sec:use-expressions}

\syntax\begin{lstlisting}
Use_Expr ::= 'use' Simple_Expr 'as' 
             [variable_id ':'] Type [Block_Expr]
\end{lstlisting}

Use expressions are similar to type cast expressions. Their intention is to rebind an expression to a specific type, and then either have this type be effective in the same scope from that point onward, or, if a \code{Block_Expr} is syntactically given, only in the scope of that block expression. If a block is given, then the return value of the block is the value of this expression, otherwise, the value retrieved by evaluation of \code{Simple_Expr} is the value of this expression. 








\section{Function Applications}
\label{sec:function-applications}

\syntax\begin{lstlisting}
Simple_Expr1   ::= Simple_Expr1 Argument_Exprs [Block_Expr]
Argument_Exprs ::= '(' [Arg_Exprs] ')'
                 | '(' [Arg_Exprs ','] '*' Expr ')'
                 | '(' [Arg_Exprs ','] ['*' Expr ','] '**' Expr ')'
                 | Block_Expr
Arg_Exprs      ::= Arg_Expr {',' Arg_Expr}
Arg_Expr       ::= Expr
\end{lstlisting}

% TBD: extend this section, note tuple of arguments






\subsection{Named and Optional Arguments}
\label{sec:named-optional-arguments}

\subsection{By-Name Arguments}
\label{sec:by-name-arguments}

\subsection{Input \& Output Arguments}
\label{sec:io-arguments}

\subsection{Function Compositions \& Pipelines}






\section{Type Applications}
\label{sec:type-applications}

\syntax\begin{lstlisting}
Simple_Expr1 ::= Simple_Expr (Type_Args [UoM_Args] | UoM_Args)
\end{lstlisting}






\section{Tuples}
\label{sec:tuples}

\syntax\begin{lstlisting}
Simple_Expr ::= '(' [Exprs] ')'
\end{lstlisting}

A tuple expression ~\lstinline!($e_1 \commadots e_n$)!~ is an alias for the class instance creation ~\lstinline!Tuple_$n$($e_1 \commadots e_n$)!, where $n \geq 1$. The empty tuple ~\lstinline!()!~ is the unique value of type \code{Unit}. 






\section{Instance Creation Expressions}
\label{sec:instance-creation-exprs}

Unlike languages like Java, Scala, C\# and similar, Coral does not have dedicated language construct for creating new instances of classes. Instead, all such attempts are made through the ~\lstinline!Class#new!~ method (not to be confused with ~\lstinline@Class.new@), which in the end\footnote{Because constructor currying can happen, the constructor is invoked by a native implementation from outside of the \code{new} method, by the curried function, which is a mechanism inaccessible to users otherwise than via the constructor definition.} has all arguments for a constructor, which gets invoked by a native implementation. 






\section{Blocks}

\syntax\begin{lstlisting}
Block_Expr  ::= Block_Expr1 | Block_Expr2
Block_Expr1 ::= '{' [Block_Args semi] Block '}'
Block_Expr2 ::= 'do' [Block_Args semi] Block 'end'
Block_Args  ::= '|' [Arg_Exprs] '|' [':' Type]
Block       ::= {Block_Stat semi} [Result_Expr]
\end{lstlisting}






\subsection{Local Variable Closure}
\label{sec:local-variable-closure}

\section{Prefix \& Infix Operations}

\subsection{Prefix Operations}

\subsection{Infix Operations}

\subsection{Assignment Operators}

\section{Typed Expressions}

\section{Annotated Expressions}
\label{sec:annotated-exprs}

\section{Assignments}

\section{Conditional Expressions}

\section{Loop Expressions}

\subsection{Classic For Expressions}

\subsection{Iterable For Expressions}

\subsection{Basic Loop Expressions}

\subsection{While \& Until Loop Expressions}

\subsection{Conditions in Loop Expressions}

\section{Collection Comprehensions}

\section{Return Expressions}

\subsection{Implicit Return Expressions}

\subsection{Explicit Return Expressions}

\subsection{Structured Return Expressions}

\section{Raise Expressions}

\section{Rescue \& Ensure Expressions}


\section{Throw \& Catch Expressions}

\section{Anonymous Functions}
\label{sec:anonymous-functions}

\subsection{Method Values}

\syntax\begin{lstlisting}
Simple_Expr ::= Simple_Expr1 '_'
\end{lstlisting}

\example The method values in the left column are each equivalent to the anonymous functions (\sref{sec:anonymous-functions}) on their right. 
\begin{lstlisting}[deletekeywords={range}]
Math.sin _                (x)      -> { Math.sin(x) }
Array.range _             (x1, x2) -> { Array.range(x1, x2) }
List.map_2 _              (x1, x2) -> (x3) -> { List.map_2(x1, x2)(x3) }
List.map_2(xs, ys) _      (x)      -> { List.map_2(xs, xy)(x) }
\end{lstlisting}







\section{Anonymous Classes}
\label{sec:anonymous-classes}

\syntax\begin{lstlisting}
Anon_Class      ::= ['class' [Class_Param_Clauses] 'extends'] 
                    [Early_Defs] Anon_Class_Tmpl
Anon_Class_Tmpl ::= Class_Parents 'with' '{' [Template_Body] '}'
\end{lstlisting}

Anonymous classs are a mechanism to implement an abstract class or override a concrete class ``ad hoc'', in place where needed, without needing to create a new constant (although as an expression, the anonymous class definition can indeed be assigned to a constant and gain its name). Anonymous classes can't be type constructors (\sref{sec:type-constructors}). 

A minimal anonymous class expression is of the form ~\lstinline!$c$ with { $t$ }!, where $c$ is the class that the anonymous class inherits from (can be even \code{Object}), and $t$ is the template of the anonymous class. The anonymous class inherits all traits mixed into this parent class, and can itself include or prepend more traits (via the \code{Class_Parents} syntax element). 

Optionally, the anonymous class may define its own primary constructor parameters, in which case the form of the anonymous class is ~\lstinline!class ($\ps_1$)$\ldots$($\ps_n$) extends $c$ with { $t$ }!, where $\ps_1$ to $\ps_n$ are the primary constructor parameters. Superclass constructor arguments may be specified in any case. 






\section{Conversions}

\subsection{Explicit Conversions}

\subsection{Implicit Conversions}
\label{sec:implicit-conversions}

\section{Workflows}
\label{sec:workflows}



