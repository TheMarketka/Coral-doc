%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Types}

\syntax\begin{lstlisting}
Type                ::= Function_Type
                      | Infix_Type [Existential_Clauses]
Function_Type       ::= Function_Args {'->' Function_Args} 
                        '->' Type
Function_Args       ::= Infix_Type
                      | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg        ::= [Param_Io] ['*' | '**' | '&' | ['~'] id ':'] 
                        Param_Type
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
                      | 'var' Var_Dcl
Compound_Type       ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                        ['with' ['refinement'] Refine_Stats]
                      | ['refinement'] Refine_Stats
Postfix_Type        ::= Compound_Type 
                        ['with' 'constraint' Constraint_Block]
Infix_Type          ::= Postfix_Type {op_id [nl] Postfix_Type}
Annot_Type          ::= {Annotation} Simple_Type
Simple_Type         ::= Simple_Type [Type_Args]
                      | Simple_Type '#' id
                      | Stable_Id
                      | Path '.' 'type'
                      | Literal ['.' 'type']
                      | '(' Types ')'
Types               ::= Type {',' Type}
\end{lstlisting}

When we say \textit{type} in the context of Coral, we are talking about a blueprint of an entity, while the type itself is an entity. Every type in Coral is backed by a \textit{class}, which is an instance of the type \lstinline@Class@. 

We distinguish a few different properties of types in Coral. There are first-order types and type constructors, which take type parameters and yield new types. A subset of first-order types called \textit{value types} represents set of first-class values. Value types are either \textit{concrete} or \textit{abstract}. 

Concrete value types can be either a \textit{class type} (e.g. referenced with a type designator, referencing a class or maybe a trait), or a \textit{compound type} representing an intersection of types, possibly with a refinement that further constrains the types of its members. Both class types and compound types may be bound to a constant, but only class types referencing a concrete class can be blueprints of values -- \textit{objects}. Compound types can only constrain bindings to a subset of other types. 

Non-value types capture properties of identifiers that are not values. For instance, a type constructor does not directly specify a type of values, but a type constructor, when applied to the correct type arguments, yields a first-order type, which may be a value type. Non-value types are expressed indirectly in Coral. In example, a method type is described by writing down a method signature, which is not a real type itself, but it creates a corresponding method type. 






\section{About Coral's Type System}

There are two main streams of typing systems out there -- statically typed and dynamically typed. Static typing in a language usually means that the language is compiled into an executable with a definite set of types and every operation is type checked. Dynamic typing means that these checks are deferred until needed, in runtime. 

Let's talk about Java. Java uses static typing -- but, in a very limited and unfriendly way, you may use class loaders and a lot of type casts to dynamically load a new class. And then possibly endure a lot of pain using it. 

Let's talk about Ruby. Ruby uses dynamic typing -- but, using types blindly can possibly lead to some confusion. Ruby is amazing though, because you can write programs with it really fast and enjoy the process at the same time. But when it comes to type safety, you need to be careful. 

And now, move on to Coral. Coral uses hybrid typing. In its core, it uses static typing. But, it allows to opt-in for dynamic typing using a special type \code{Any}. Unlike in Ruby, you can overload methods (not just override!). You can constrain variables, constants, properties, arguments and result types to particular types. But you don't have to. Types in Coral were heavily inspired by Scala's type system, but modified for this dynamic environment that Coral provides. Unlike in Ruby, you can have pure interfaces (called protocols\footnote{Interfaces in Coral are used to extract the {\em public interface} of classes in modules, so that only a small amount of code may be distributed along with the module to allow binding to it.}), or interfaces with default method implementations (similar to Java 8). Unlike in Java, you can have traits, union types and much more. Unlike in Java, you may easily modify classes, even from other modules ({\em pimp my library!} and {\em open-class principle}). You may even easily add more classes if needed, and possibly shadow existing ones. 

While Coral is so dynamic, it also needs to maintain stability and performance. Therefore, it ``caches'' its bindings and tracks versions of each type\footnote{Versions are simply integers that are incremented with each significant change to the type and distributed among its subtypes.}. If a {\em cached binding} would change, it is ok -- as long as the new binding would be compatible with the old one. Practically, the code that executes first initiates the binding -- first to come, first to bind. Bindings are also cached, so that the Coral interpreter does not need to traverse types all the time -- it only does so if the needed binding does not exist (initial state with dynamic typing), or if the cached version does not match the current version of the bound type. This mechanism is also used for caching methods, not only types.

Types in Coral are represented by objects that are members of the \code{Type} type. Instances of value types are represented by objects that are members of the \code{Class} type. 






\section{Paths}
\label{sec:type-paths}

\syntax\begin{lstlisting}
path_id          ::= id [Type_Args]
Path             ::= Stable_Id
                   | [path_id '.'] ('this' | 'self')
                   | 'self' '[' ('cloned' | 'origin') ']'
                   | Container_Path
Stable_Id        ::= [Path '.'] path_id
                   | [path_id '.'] 'super' [Class_Qualifier]
Class_Qualifier  ::= '[' Container_Path ']'
\end{lstlisting}

Paths are not types themselves, but they can be a part of named types and in that function form a role in Coral's type system. 

A path is one of the following:

\begin{itemize}
\item 
The empty path $\epsilon$ (which can not be written explicitly in user programs). 

\item 
\code{this}, which references the directly enclosing class. 

\item 
\lstinline@$C$.self@, where $C$ references a class or a trait. The path \code{self} is taken as a shorthand for \lstinline@$C$.self@, where $C$ is the name of the class directly enclosing the reference. A special path ~\lstinline!Function.self!, where \code{Function} is defined by Coral's \code{Lang} module (not imported to be anything else), is a reference to the directly enclosing function object and is available only within functions (or methods, anonymous functions, and even blocks).

\item
\lstinline@self[cloned]@, which references the directly enclosing class of a clone (a cloned instance, see \sref{sec:clone-def}). 

\item
\lstinline@self[origin]@, which references the directly enclosing class of an original object (an instance being cloned, see \sref{sec:clone-def}). 

\item 
\lstinline@$p$.$x$@, where $p$ is a path and $x$ is a member of $p$. Additionally, $p$ allows modules to appear instead of references to classes or traits, but no module reference can follow a class or a trait reference: \lstinline@{module_ref '.'} {(class_ref|trait_ref) '.'} $\ldots$@. 

\item
\lstinline@$C$.super.$x$@ or \lstinline@$C$.super[$M$].$x$@, where $C$ references a class or a trait and $x$ references a member of the superclass or designated parent class $M$ of $C$. The prefix \code{super} is taken as a shorthand for \lstinline@$C$#super@, where $C$ is the name of the class directly enclosing the reference, and \lstinline@super[$M$]@ as a shorthand for \lstinline@$C$.super[$M$]@, where $C$ is yet again the name of the class directly enclosing the reference. 
\end{itemize}

Paths introduce also {\em path dependent types}, if the referenced member is a type. 






\section{Value Types}

Every value in Coral has a type which is of one of the following forms. 






\subsection{Singleton Type}
\label{sec:singleton-types}

\syntax\begin{lstlisting}
Simple_Type ::= Path '.' 'type'
\end{lstlisting}

A singleton type is of the form ~\lstinline@$p$.type@, where $p$ is a path pointing to a value. The type denotes the set of values consisting of \code{nil} (in spite of nullability) and the value denoted by $p$.

A {\em stable type} is either a singleton type or a type which is declared to be a subtype of a trait \code{Singleton_Type}. 





\subsection{Cloned Type}
\label{sec:cloned-types}

\syntax\begin{lstlisting}
Simple_Type ::= Path '.' 'cloned' '.' 'type'
\end{lstlisting}

A cloned type is of the form ~\lstinline!$p$.cloned.type!, where $p$ is a path pointing to a value. The type denotes the set of values consisting of \code{nil} (in spite of nullability), the value denoted by $p$ and every value that is cloned from the value denoted by $p$. 

A {\em stable type} is either a cloned type or a type which is declared to be a subtype of a trait \code{Cloned_Type}. Singleton in this view appears to be a special case (more concrete to be precise) of a cloned type, excluding the cloned values. 





\subsubsection{Literal-Based Singleton Type}
\label{sec:literal-based-singleton-type}

\syntax\begin{lstlisting}
Simple_Type ::= Literal ['.' 'type']
\end{lstlisting}

A singleton type based on a literal is of the form \lstinline@$l$.type@, where $l$ is a literal. The type denotes the set of values consisting of \code{nil} and every literal value that is equal to $l$. 

A {\em stable type} is either a literal-based singleton type or a type which is declared to be a subtype of a trait \code{Literal_Singleton_Type}. 

In contexts where a type is expected\footnote{Most notably type arguments or type annotations of variables or function result types.}, the ``\code{.type}'' part of the type can be omitted. 





\subsection{Type Projection}
\label{sec:type-projection}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type '#' id
\end{lstlisting}

A type projection \lstinline@$T$#$x$@ references type member named $x$ of type $T$. This is useful i.e. with nested classes that belong to the class instances, not the class object. 

% example based on: http://stackoverflow.com/a/9444487/473180
\example A sample code that shows off what type projections are good for:
\begin{lstlisting}
class A {
  class B {}
  def f (b: B): Unit   := Console.print_line "Got my B."
  def g (b: A#B): Unit := Console.print_line "Got a B."
}

val a1 := A.new
val a2 := A.new
a2.f a1.B.new     // type mismatch, found a1.B, required a2.B
a2.g a1.B.new     // prints "Got a B." to stdout
a2.f a2.B.new     // prints "Got my B." to stdout
\end{lstlisting}
This is due to the fact that the \code{class B} is defined as a class instance member of \code{class A}, not as a class object member (either via object definition (\sref{sec:object-definitions}) or some form of metaclass access (\sref{sec:metaclasses})). Therefore, \code{a1.B} refers to type member \code{B} of the instance \code{a1}, but not of \code{a2}. Moreover, \code{A.B} is not defined here. 

% TBD: add example with graphs from http://www.scala-lang.org/old/node/115, as Coral does the same thing






\subsection{Type Designators}
\label{sec:type-designators}

\syntax\begin{lstlisting}
Simple_Type ::= Stable_Id
\end{lstlisting}

A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections. 

Specifically, the unqualified type name $t$ where $t$ is bound in some class $C$ is taken as a shorthand for ~\lstinline@$C$.self.type#$t$@. If $t$ is bound in some object\footnote{Also in class object methods.} or module $C$, it is taken as a shorthand for ~\lstinline@$C$.type#$t$@. If $t$ is not bound in a class, object or module, then $t$ is taken as a shorthand for ~\lstinline@$\epsilon$.type#$t$@. 

A qualified type designator has the form ~\lstinline@$p$.$t$@, where $p$ is a path (\sref{sec:type-paths}) and $t$ is a type name. Such a type designator is equivalent to the type projection ~\lstinline@$p$.type#$t$@. 

\example Some type designators and their expansions are listed below, the type designator being on the left and the expansion on the right of ``\code{=}''. 
\begin{lstlisting}
t = $\epsilon$.type#t // "global space"
Number = Lang~[coral].type#Number // predefined import of Lang~[coral]

object An_Object {
  type t
  t = An_Object.type#t // bound by object
}

class A_Class {
  type t
  def a_method := {
    t = A_Class.self.type#t // bound by class
  }
  class << self
    type u
    u = A_Class.type#u // bound by (class) object
  end
  t = A_Class.self.type#t // bound by class
  self.u = A_Class.type#u // bound by (class) object
}
\end{lstlisting}






\subsection{Parameterized Types}
\label{sec:parameterized-types}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type [Type_Args]
Type_Args   ::= '[' Types ']'
Types       ::= Type_Arg {',' Type_Arg}
Type_Arg    ::= [['~'] id ':'] Type 
              | '<' uom_expr '>'
              | '_'
\end{lstlisting}

A parameterized type $T[T_1 \commadots T_n]$ consists of a type designator $T$ and type parameters $T_1 \commadots T_n$, where $n \geq 1$. $T$ must refer to a type constructor which takes exactly $n$ type parameters $a_1 \commadots a_n$. 

Say the type parameters have lower bounds $L_1 \commadots L_n$ and upper bounds $U_1 \commadots U_n$. The parameterized type is well-formed if each actual type parameter {\em conforms to its bounds}, so that $\sigma L_i <: T_i <: \sigma U_i$, where $\sigma$ is the substitution $[a_1 := T_1 \commadots a_n := T_n]$\footnote{The substitution works by replacing occurrences of $a_i$ in the argument by $T_i$, so that, e.g. ~\lstinline!$A$ <: Comparable[$A$]!~ is substituted into ~\lstinline!$C$ <: Comparable[$C$]!.}. Also, $U_i$ must never be a subtype of $L_i$, since no other type ever would be able to fulfill the bounds ($U_i$ and $L_i$ may be the exact same type though, but in that case the type parameter would be invariant and the whole point of having a parameterized type would be useless). 

Each type parameter may be given a name $n$, which is done by prepending it with an id immediately followed by a colon, which itself may be prepended with a tilde ``\lstinline!~!''. The first case is a shorthand for adding an annotation ~\lstinline!@[named :$n$]!, the second is a shorthand for adding the previous annotation and also ~\lstinline!@[purely_named]!. 

\example
\label{example:parameterized-types}
Given the generic type definitions: 

\begin{lstlisting}
class Tree_Map[A <: Comparable[A], B] $\ldots$ end
class List[A] $\ldots$ end
class I extends Comparable[I]; $\ldots$ end

class F[M[_], X] $\ldots$ end
class S[K <: String] $\ldots$ end
class G[M[Z <: I], I] $\ldots$ end

trait Function_1[T, R]; end
\end{lstlisting}

the following parameterized types are well-formed: 

\begin{lstlisting}
Tree_Map[I, String]
List[I]
List[List[Boolean]]

F[List, Number]
G[S, String]

Function_1[named: List[String], String]
\end{lstlisting}

\example
\label{example:parameterized-types-mal}

Given the type definitions of the previous example, the following types are malformed: 

\begin{lstlisting}
Tree_Map[I]               // wrong number of parameters
Tree_Map[List[I], Number] // type parameter List not within bound

F[Number, Boolean]        // Number is not a type constructor
F[Tree_Map, Number]       // Tree_Map takes two parameters, 
                          //   F expects a type constructor taking one

G[S, Number]              // type S constrains its parameter to
                          //   conform to String, 
                          // G expects type constructor with a parameter
                          //   that conforms to Number
\end{lstlisting}





\subsection{Tuple Types}
\label{sec:tuple-types}

\syntax\begin{lstlisting}
Simple_Type ::= '(' Types ')'
\end{lstlisting}

A tuple type ($T_1 \commadots T_n$) is an alias for the class \lstinline@Tuple_$n$[$T_1 \commadots T_n$]@, where $n \geq 2$. 

Tuple classes are available as patterns for pattern matching. The properties can be accessed as methods ~\lstinline!_1$ \commadots $_n!~ (using an ``offset'' that is outside of the tuple's size results in a method-not-found error, not offset-out-of-bounds). 

Tuple classes are generated lazily by the runtime as needed, so that the language does not constrain users to tuples of only limited sizes, but allows any size. 

If any of the tuple's type parameters $T_i$ is annotated to be named $n$ (see \sref{sec:parameterized-types}, then an additional method named $n$ is added, returning the same value as ~\lstinline!_$i$!, of the type $T_i$. If that type parameter is furthermore annotated with ~\lstinline!@[purely_named]!, then the ~\lstinline!_$i$!~ is removed. 






\subsection{Annotated Types}

\syntax\begin{lstlisting}
Annot_Type ::= {Annotation} Simple_Type
\end{lstlisting}

An annotated type $a_1 \ldots a_n T$ attaches annotations $a_1 \commadots a_n$ to the type $T$. % TBD: add ref to a chapter about annotations.






\subsection{Compound Types}
\label{sec:compound-types}

\syntax\begin{lstlisting}
Compound_Type ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                  ['with' ['refinement'] Refine_Stats]
                | ['refinement'] Refine_Stats
Refine_Stats  ::= '{' [Refine_Stat {semi Refine_Stat}] '}'
Refine_Stat   ::= Dcl
                | 'type' Type_Def
                | Constraint_Dcl
\end{lstlisting} % TBD: define Refine_Stat syntax

A compound type \lstinline@$T_1$ with $\ldots$ with $T_n$ with refinement {$R$}@ represents values with members as given in the component types $T_1 \commadots T_n$ and the refinement \lstinline@{$R$}@. A refinement \lstinline@{$R$}@ contains declarations and definitions (\sref{sec:refinements}). 

If no refinement is given, the type is implicitly equivalent to the same type having an empty refinement. 

A compound type may also consist of just a refinement \lstinline@{$R$}@ with no preceding component types -- such a type has an implicit component type \code{Object} and describes the member values as ``any value, as long as it has what the refinement requires'', thus it works like an anonymous protocol. 

If a compound type does not contain a concrete class type, then \code{Object} is implied in case the type is used as a concrete class\footnote{Meaning that the compound type is used as an ad-hoc (possibly anonymous) class, e.g. to create new instances of it.}.

The keyword \code{refinement} instructs that the following tokens will be a part of a refinement, and the construct ~\lstinline!refinement {$R$}!~ is called an {\em anonymous refinement}, being equivalent to ~\lstinline!Object with refinement {$R$}!, although when the refinement is a part of a compound type with more elements than just the refinement itself, the \code{Object} type is replaced with the class type appearing in the compound type, if any. 

The \code{refinement} keyword can be omitted from a compound type that consists of more elements than just the refinement. Constructs ~\lstinline!Object with {$R$}!~ and ~\lstinline!refinement {$R$}!~ are then equal. 

The \code{refinement} keyword may also be omitted from a compound type that consists of just the refinement, but only in contexts in which a type is expected, i.e.: parameter type declaration, value or variable type declaration, result type declaration, type argument application or type parameter declaration; but never stand-alone. If used as such, the constructs ~\lstinline!refinement {$R$}!~ and ~\lstinline!{$R$}!~ are then equal. 






\subsection{Infix Types}
\label{sec:infix-types}

\syntax\begin{lstlisting}
Infix_Type ::= Postfix_Type {op_id [nl] Postfix_Type}
\end{lstlisting}

An infix type $T_1\ \op\ T_2$ consists of an infix operator $\op$, which gets applied to two type operands $T_1$ and $T_2$. The type is equivalent to the type application ~\lstinline!$\op$[$T_1$, $T_2$]!. The infix operator $\op$ may be an arbitrary identifier, and is expected to represent a type constructor. 

Infix type may also result from an infix expression (\sref{sec:prefix-infix-ops}), if such operator name is not found on the result type of the expression that it is applied to. In any case, precedence and associativity rules of operators apply here as well. 






\subsection{Function Types}
\label{sec:function-types}

\syntax\begin{lstlisting}
Type          ::= Function_Args {'->' Function_Args}
                  '->' Type
Function_Args ::= Infix_Type
                | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg  ::= [Param_Io] ['*' | '**' | '&' | ['~'] id ':']
                  Param_Type
\end{lstlisting}

The type \lstinline@($T_1 \commadots T_n$) -> $R$@ represents the set of function values that take arguments of types $T_1 \commadots T_n$ and yield results of type $R$. In the case of exactly one argument, type \lstinline@$T$ -> $R$@ is a shorthand for \lstinline@($T$) -> $R$@. 

Function argument types may be annotated with some extra properties. In that case, these map to annotations of their types, defined as follows:
\begin{itemize}
\item ``\code{out}'' maps to \lstinline[deletekeywords={out}]!@[out]!. 
\item ``\code{in}'' maps to no annotation, as it is implied, and if the parameter is \code{out}-only, the function is still applicable. 
\item ``\code{*}'' maps to \code{@[variadic]}. 
\item ``\code{**}'' maps to \code{@[capturing_named]}. 
\item ``\code{&}'' maps to \code{@[captured_block]}. 
\item ``\code{$\id$}'' maps to \code{@[named :$\id$]}. 
\item ``\lstinline!~$\id$!'' maps to ~\lstinline!@[named :$\id$] @[purely_named]!. 
\end{itemize}

Function types associate to the right, e.g. \lstinline@($S$) -> ($T$) -> $R$@ is the same as \lstinline@($S$) -> (($T$) -> $R$)@. 

Function types are shorthands for class types that conform to the \lstinline@Function_$i$@ protocol -- i.e. having an \code{apply} function or simply {\em being} a function. The $n$-ary function type \lstinline@($T_1 \commadots T_n$) -> $R$@ is a shorthand for the protocol \lstinline@Function_$n$[$T_1 \commadots T_n,R$]@. Such protocols are defined in the Coral library for any $n \ge 0$:

\begin{lstlisting}
protocol Function_$n$[-$T_1 \commadots\,$-$T_n$, +$R$]
  message apply ($x_1$: $T_1 \commadots x_n$: $T_n$): $R$
  $\ldots$
end protocol
\end{lstlisting}

Function types are covariant in their result type and contravariant in their argument types (\sref{sec:variance-of-type-parameters}).

A function that returns ``nothing'' may be declared as returning the type \code{Unit}, which is similar to \lstinline[language=C]!void! in C-related languages. Such a type is then written as ~\lstinline!($S$) -> Unit!. 

Function arguments may be optionally annotated with more requirements: 
\begin{itemize}
\item
Parameter prefixed with \code{Param_Io} defines whether the parameter is required to be an output parameter. 

\item
Parameter prefixed with ``\lstinline!*!'' is a requirement of a repeated parameter. 

\item 
Parameter prefixed with ``\lstinline!$\id$!'' is a requirement of a parameter named $\id$.

\item 
Parameter prefixed with ``\lstinline!~$\id$!'' is a requirement of a parameter purely named $\id$.

\item 
Parameter prefixed with ``\lstinline!**!'' is a requirement of a captured named parameters. 

\item
Parameter prefixed with ``\lstinline!&!'' is a requirement for the passed block. It does not tell whether the function must capture the passed block, it only restricts the requirements for the particular block, if any. The actual passed block may have more or even less positional or named parameters (extra ones on the block side are given \code{nil}, unless the type is not nullable (\sref{sec:nullable-types}) -- that is an error; and extra ones on the type side are simply discared), but the result type of the passed block must conform (\sref{sec:conformance}).
\end{itemize}

\paragraph{Note}
Although the function type alone allows to attach the extra annotations to types of arguments in a \code{1:1} manner (and therefore types of parameters), due to how conformance is defined for function types, it is not always desirable to use them. The only argument extra that might be of any use is the captured block argument, so that a requirement of a passed block is marked (not caring about the actual style of the block passing). 

\example The following definition of functions \code{g} and \code{h} conform to a definition of a function \code{f}, and there are many more such functions that conform to \code{f}. And vice versa, \code{f} conforms to both \code{g} and \code{h}, although the latter two are more specific than the first one (\sref{sec:overloading-resolution}). 
\begin{lstlisting}
def f (*x: Integer) end
def g (x: Integer, y: Integer) end
def h (x: Integer, y: Integer, z: Integer) end
\end{lstlisting}






\subsection{Existential Types}
\label{sec:existential-types}

\syntax\begin{lstlisting}[escapechar=@]
Type                ::= Infix_Type Existential_Clauses
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
\end{lstlisting}

An existential type has the form ~\lstinline@$T$ for-some { $Q$ }@, where $Q$ is a sequence of type declarations (\sref{sec:type-decls-aliases}). Let ~\lstinline@$t_1$[$\tps_1$] >: $L_1$ <: $U_1\ \commadots\ t_n$[$\tps_n$] >: $L_n$ <: $U_n$@~ be the types declared in $Q$ (any of the type parameter sections ~\lstinline![$\tps_i$]!~ might be missing). The scope of each type $t_i$ includes the type $T$ and the existential clause $Q$. The type variables $t_i$ (occurring in the sequence $Q$) are said to be {\em bound} in the type ~\lstinline!$T$ for-some { $Q$ }!. Type variables that occur in a type $T$, but which are not bound in $T$, are said to be {\em free} in $T$. 

A {\em type instance} of ~\lstinline@$T$ for-some { $Q$ }@~ is a type $\sigma T$, where $\sigma$ is a substitution over $t_1 \commadots t_n$, such that for each $i$, $\sigma L_i \conforms \sigma t_i \conforms \sigma U_i$. The set of values denoted by the existential type \lstinline@$T$ for-some { $Q$ }@ is the union of the set of values of all its type instances. In other words, a type instance of an existential type is a type application (\sref{sec:type-applications}) of the type ~\lstinline@$T$ for-some { $Q$ }@, where the applied type arguments conform to the bounds, or are free in ~\lstinline@$T$ for-some { $Q$ }@. 

A {\em skolemization} of ~\lstinline@$T$ for-some { $Q$ }@~ is a type instance $\sigma T$, where $\sigma$ is the substitution $[t_1 := t'_1 \commadots t_n := t'_n]$ and each $t'_i$ is a fresh abstract virtual type with lower bound $\sigma L_i$ and upper bound $\sigma U_i$\footnote{This virtual type $t'_i$ denotes the set of all types, for which $\sigma L_i \conforms \sigma t'_i \conforms \sigma U_i$.}. Such type instance is inaccessible to user programs, but is essential to type equality and conformance checks, as it describes the set of values denoted by the existential type without an actual existential type, but with a universal type. 



\paragraph{Simplification rules}
Existential types obey the following equivalences:
\begin{enumerate}
\item
Multiple \code{for-some} clauses in an existential type can be merged. E.g., ~\lstinline@$T$ for-some { $Q$ } for-some { $Q'$ }@~ is equivalent to ~\lstinline@$T$ for-some { $Q$; $Q'$ }@. 

\item
Unused quantifications can be dropped. E.g., ~\lstinline@$T$ for-some { $Q$; $Q'$ }@, where none of the types defined in $Q'$ are referred to by $T$ or $Q$, is equivalent to ~\lstinline@$T$ for-some { $Q$ }@. 

\item
An empty quantification can be dropped. E.g., ~\lstinline@$T$ for-some { }@~ is equivalent to $T$. 

\item
An existential type ~\lstinline@$T$ for-some { $Q$ }@, where $Q$ contains a clause ~\lstinline!type $t$[$\tps$] >: $L$ <: $U$!~ is equivalent to the type ~\lstinline@$T'$ for-some { $Q$ }@, where $T'$ results from $T$ by replacing every covariant occurrence (\sref{sec:variance-of-type-parameters}) of $t$ in $T$ by $U$ and by replacing every contravariant occurrence of $t$ in $T$ by $L$. 
\end{enumerate}



\paragraph{Existential quantification over values}
As a syntactic convenience, the bindings clause in an existential type may also contain value declarations ~\lstinline!val $x$: $T$!. An existential type ~\lstinline@$T$ for-some { $Q$; val $x$: $S$; $Q'$ }@~ is treated as a shorthand for the type ~\lstinline@$T'$ for-some { $Q$; type $t$ <: $S$ with Singleton_Type; $Q'$ }@, where $t$ is a fresh type name and $T'$ results from $T$ by replacing every occurrence of ~\lstinline!$x$.type!~ with $t$. 



\paragraph{Placeholder syntax for existential types}
Coral supports a placeholder syntax for existential types. A {\em wildcard type} is of the form ~\lstinline!_ >: $L$ <: $U$!. Both bound clauses may be omitted. If a lower bound clause ~\lstinline!_ >: $L$!~ is omitted, ~\lstinline!_ >: Nothing!~ is assumed. If an upper bound clause ~\lstinline!_ <: $U$!~ is omitted, ~\lstinline!_ >: Object!~ is assumed. A wildcard type is a shorthand for an existentially quantified type variable, where the existential quantification is implicit. 

A wildcard type must appear as a type argument of a parameterized type. Let ~\lstinline!$T$ := $p$.$c$[$\targs$, $T$, $\targs'$]!~ be a parameterized type, where $\targs$, $\targs'$ may be empty and $T$ is a wildcard type ~\lstinline!_ >: $L$ <: $U$!. Then $T$ is equivalent to the existential type
\begin{lstlisting}
$p$.$c$[$\targs$, $t$, $\targs'$] for-some { type $t$ >: $L$ <: $U$ }
\end{lstlisting}
where $t$ is a fresh type variable. Wildcard types may also appear as parts of compound types (\sref{sec:compound-types}), function types (\sref{sec:function-types}) or tuple types (\sref{sec:tuple-types}). Their expansion is then the expansion in the equivalent parameterized type. 

\example Assume the class definitions
\begin{lstlisting}
class Ref[T] {}
abstract class Outer { type T }
\end{lstlisting}

Here are some examples of existential types:
\begin{lstlisting}
Ref[T] for-some { type T <: Number }
Ref[x.T] for-some { val x: Outer }
Ref[x_type#T] for-some { type x_type <: Outer with Singleton_Type }
\end{lstlisting}

The last two types in this list are equivalent. An alternative formulation of the first type above using wildcard syntax is:
\begin{lstlisting}
Ref[_ <: Number]
\end{lstlisting}

which is equivalent to Java's
\begin{lstlisting}[language=Java]
Ref<? super Number>
\end{lstlisting}

\lstinline!Ref[_ <: Number]!~ then represents any type constructed by the type\code{Ref} parameterized with a type that is \code{Number} or any type that conforms to \code{Number}. 

\lstinline!Ref[_ >: Number]!~ would then represents any type constructed by the type \code{Ref} parameterized with a type that is \code{Number} or any type that \code{Number} conforms to. 

\example The type ~\lstinline!List[List[_]]!~ is equivalent to the existential type
\begin{lstlisting}
List[List[T] for-some { type T }]  .
\end{lstlisting}

\example Assume a covariant type
\begin{lstlisting}
class List[+T] {}
\end{lstlisting}

The type 
\begin{lstlisting}
List[T] for-some { type T <: Number }
\end{lstlisting}

is equivalent (by simplification rule 4 above\footnote{As ~\lstinline!T!~ appears in covariant position in \code{List}, its upper bound can replace the type variable in \code{List}.}) to
\begin{lstlisting}
List[Number] for-some { type T <: Number }
\end{lstlisting}

which is in turn equivalent (by simplification rules 2 and 3 above\footnote{The type variable ~\lstinline!T!~ is unused, and after dropping it, the quantification is empty.}) to
\begin{lstlisting}
List[Number]  .
\end{lstlisting}

Since this \code{List} type is covariant in its type parameter, then e.g. ~\lstinline!List[Integer]!~ is still a subtype of ~\lstinline!List[Number]!. 





\subsection{Nullable Types}
\label{sec:nullable-types}

\syntax\begin{lstlisting}
Type          ::= Type Nullable_Mod
Nullable_Mod  ::= '?'
\end{lstlisting}

A nullable type has the form \lstinline!$T$?!, where ``\code{?}'' denotes a nullable type. Although \code{nil} as the singleton member of the \code{Nothing} type is a subtype of every type, Coral types are implicitly not-nullable, meaning that the language complains when the \code{nil} value is assigned to a variable whose type is not bound to be nullable. And it does so by issuing compile-time warnings and runtime warnings\footnote{In debug mode.} when the \code{nil} value is assigned to a type that is not nullable, including parameter assignment and result value assignment. This is due to the fact that the type \code{Nothing} conforms to any type that descends from \code{Any}, which is, well, any type. 

A block of code (or whole files or modules) may opt-in to behaviour that raises errors in runtime, instead of issuing warnings, using \code{pragma Error_on_Nil} inside the code block, file or module. 

If an implicit conversion from \code{Nothing} to $T$ is available, then nullability is not a problem. 

Nullable types in this form can appear everywhere where a type is expected. 

A nullable type may be seen as a syntax sugar for the following union type ~\code{Nullable[$T$]} (\sref{sec:unions}):
\begin{lstlisting}
type Nullable [T] is union of (
  T
  Nothing
) end type
\end{lstlisting}

When a method is applied on a variable containing \code{nil}, the standard \code{Member_Not_Found} may occur, if the method is really not found in the class \code{Nothing} or in any of implicit conversions from \code{Nothing} (e.g., \code{Nothing} has an implicit conversion to the option type \code{None}). 





\subsection{Unions}
\label{sec:unions}

\syntax\begin{lstlisting}
Const_Type_Def ::= id [Type_Param_Clause] 'is' 'union' 'of'
                   '(' Type {semi Type} ')'
Simple_Type    ::= '(' Type {'or' Type} ')'
\end{lstlisting}

Union types represent multiple types, possibly unrelated. Union types are abstract by nature and can not be instantiated, only the types that they contain may, if these are instantiable. For type safety, bindings of union types should be matched for the actual type prior to usage. 

Unions are indeed virtually ``tagged'' with the actual type that they represent at the runtime moment, although when it comes to overloading resolution, the union type is used, as it is the expected type. 

The first syntax shows a named union type, while the second shows an anonymous union type (which may still be given a name later). If any of the types that are a part of a union type is a union type itself, the two types are merged. The syntax used for the anonymous version is correlating with infix type syntax, but this syntax gives it the meaning of a union type, which is preferred to infix type syntax. In fact, it might be implemented with a native infix type that generates union types:

\begin{lstlisting}
operator or [A, B] (): Union[A, B] end
\end{lstlisting}





\subsection{Constrained Types}
\label{sec:constrained-types}

\syntax\begin{lstlisting}
Postfix_Type     ::= Compound_Type 
                     'with' 'constraint' Constraint_Block
Constraint_Block ::= '{' Block '}'
\end{lstlisting}

A constrained type constructs a subset of allowed members of its component type. Such a subset is defined as members for which the constraint block returns boolean \code{yes}. Constraints defined within the component type are implicitly available in such block as local variables. In case of a change in any value returned by any defined and used constraint, the type is marked dirty\footnote{For concurrency purposes.} and rechecked upon next value read. 

Constrained types, in face of overloading, force argument expression evaluation, so that the constrained type of a parameter can even be checked. Therefore, constrained types are not suitable candidates for parameters that are supposed to be lazy-evaluated, unless the early evaluation is intended. 

\paragraph{Note}
Constrained types are an implementation of {\em dependent types} in Coral. Dependent types are basically functions from values to types, where the value part is present in the defined constraint and/or the constraint block. 





\section{Non-Value Types}

The types explained in the following paragraphs do not appear explicitly in programs, they are internal and do not represent any type of value directly. 






\subsection{Method Types}
\label{sec:method-types}

A method type is denoted internally as $(Ps) \mapsto R$, where $(Ps)$ is a sequence of types  $(p_1 : T_1 \commadots p_n : T_n)$ for some $n \geq 0$ and $R$ is a (value or method) type. This type represents named or anonymous methods that take arguments of types $T_1 \commadots T_n$ and return a result of type $R$. Types of parameters are possibly annotated with conformance restricting annotations (\sref{sec:annotations}). 

Method types associate to the right:\footnote{Like in Haskell or Scala.} \newline
$(Ps_1) \mapsto (Ps_2) \mapsto R$ is treated as $(Ps_1) \mapsto ((Ps_2) \mapsto R)$. 

A special case are types of methods without any parameters. They are written here as $() \mapsto R$. 

Another special case are types of methods without any result type. They are written here as $(Ps) \mapsto ()$. Methods that have this result type do not have an implicit return expressions and an attempt to return a value from it results in a compile-time error.\footnote{A compile-time error like this may happen during a runtime evaluation as well.}

Method types do not exist as types of values. If a method name is used as a value, its type is implicitly converted to a corresponding function type (\sref{sec:function-types}). 

Extra properties of parameters are as follows: a \lstinline@*@ for variadic parameters, \lstinline@**@ for any named parameters and \lstinline@&@ for a captured block parameter, or nothing for regular parameters. 

\example The declarations
\begin{lstlisting}
def a: -> Integer // or def a () -> Integer
def b (x: Integer): Boolean
def c (x: Integer): (y : String, z : String) -> String
def d (~x: Integer): Integer
def e (*x: Integer): Integer
def f (x: Integer): Unit
def g (x: Integer)(y: Integer): Integer
def h (x: Integer): (y: Integer) -> Integer
\end{lstlisting}
produce the typings
\begin{lstlisting}
a : () $\mapsto$ Integer
b : (@[named :x] Integer) $\mapsto$ Boolean
c : (@[named :x] Integer) $\mapsto$ (y: String, z: String) $\mapsto$ String
d : (@[named :x] @[purely_named] Integer) $\mapsto$ Integer
e : (@[named :x] @[variadic] Integer) $\mapsto$ Integer
f : (@[named :x] Integer) $\mapsto$ Unit
g : (@[named :x] Integer) $\mapsto$ (@[named :y] Integer) $\mapsto$ Integer
g : (@[named :x] Integer) $\mapsto$ (@[named :y] Integer) $\mapsto$ Integer
\end{lstlisting}

The difference between the ``\code{g}'' and ``\code{h}'' functions is that using the chain of result types as in function ``\code{g}'', the function body is automatically curried to return a function that is of type \lstinline@(Integer) $\mapsto$ Integer@. With the function ``\code{h}'', currying has to be implemented manually. 






\subsection{Polymorphic Method Types}
\label{sec:polymorphic-method-types}

A polymorphic method type is the same as a regular method type, but enhanced with a type parameters section. It is denoted internally as \lstinline@[$\tps$]$ \mapsto T$@, where \lstinline@[$\tps$]@ is a type parameter section ~\lstinline@[$\pm a_1$ >: $L_1$ <: $U_1$ $\commadots$ $\pm a_n$ >: $L_n$ <: $U_n$]@ for some $n \geq 0$ and $T$ is a (value or method) type. This type represents (only\footnote{Not anonymous.}) named methods that take type arguments $S_1 \commadots S_n$, for which the lower bounds $L_1 \commadots L_n$ conform (\sref{sec:conformance}) to the type arguments and the type arguments conform and the upper bounds $U_1 \commadots U_n$ and that yield results of type $T$. No explicit lower bound implies \code{Nothing} to be the corresponding lower bound, no explicit upper bound implies \code{Object} to be the corresponding upper bound. As usual, lower bound must conform to the corresponding upper bound. 

\example The declarations
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
def empty[A]: List[A]
def union[A <: Comparable[A]] (x : Set[A], 
         xs : Set[A]): Set[A]
\end{lstlisting}
produce the typings
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
empty : [A >: Nothing <: Any] () $\mapsto$ List[A]
union : [A >: Nothing <: Comparable[A]] (Set[A], 
        Set[A]) $\mapsto$ Set[A]
\end{lstlisting}






\subsection{Type Constructors}
\label{sec:type-constructors}

A type constructor is in turn represented internally much like a polymorphic method type. \lstinline@[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto T$@ represents a type that is expected by a type constructor parameter. The difference is that the represented internal entity is not a method, but a type, creating higher-kinded types. 






\section{Base Types \& Member Definitions}
\label{sec:base-types}
\label{sec:member-definitions}

Types of class members depend on the way the members are referenced. Central here are these notions:
\begin{enumerate}
\item The notion of the set of base types of a type $T$.
\item The notion of a type $T$ in some class $C$ seen from some prefix type $S$.
\item The notion of the set of member bindings of some type $T$. 
\end{enumerate}

These notions are defined mutually recursively as follows. 

\begin{enumerate}

\item
The set of {\em base types} of a type is a set of class types, given as follows.
\begin{itemize}
\item The base types of a class type $C$ with parents $T_1 \commadots T_n$ are $C$ itself, as well as the base types of the compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$!. 

\item The base types of an aliased type are the base types of its alias. 

\item The base types of an abstract type\footnote{E.g. type members.} are the base types of its upper bound. 

\item The base types of a parameterized type ~\lstinline!$C$[$T_1 \commadots T_n$]!~ are the base types of type $C$, where every occurence of a type parameter $a_i$ of $C$ has been replaced by the corresponding parameter type $T_i$. 

\item The base types of a compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$ with { $R$ }!~ are set of base classes of all $T_i$'s. 

\item The base types of a type projection ~\lstinline!$S$#$T$!~ are determined as follows: If $T$ is an alias or an abstract type, the previous clauses apply. Otherwise, $T$ must be a (possibly parameterized) class type, which is defined in some class $B$. Then the base types of ~\lstinline!$S$#$T$!~ are the base types of $T$ in $B$ as seen from the prefix type $S$. 

\item The base types of an existential type ~\lstinline!$T$ for-some { $Q$ }!~ are all types ~\lstinline!$S$ for-some { $Q$ }!, where $S$ is a base type of $T$. 
\end{itemize}

\item
The notion of a type {\em $T$ in class $C$ seen from some prefix type $S$} makes sense only if the prefix type $S$ has a type instance of class $C$ as a base type, say ~\lstinline!$S'$#$C$[$T_1 \commadots T_n$]!. Then we define it as follows.
\begin{itemize}
\item If ~\lstinline!$S$ = $\epsilon$.type!, then $T$ in $C$ seen from $S$ is $T$ itself. 

\item Otherwise, if $S$ is an existential type ~\lstinline!$S'$ for-some { $Q$ }!, and $T$ in $C$ seen from $S'$ is $T'$, then $T$ in $C$ seen from $S$ is ~\lstinline!$T'$ for-some { $Q$ }!. 

\item Otherwise, if $T$ is the $i^{\superth}$ type parameter of some class $D$, then:
\begin{itemize}
\item If $S$ has a base type ~\lstinline!$D$[$U_1 \commadots U_n$]!, for some type parameters $U_1 \commadots U_n$, then $T$ in $C$ seen from $S$ is $U_i$. 
\item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
\item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
\end{itemize}

\item Otherwise, if $T$ is the singleton type ~\lstinline!$D$.self.type!~ for some class $D$, then:
\begin{itemize}
\item If $D$ is a subclass of $C$ and $S$ has a type instance of class $D$ among its base types, then $T$ in $C$ seen from $S$ is $S$. 
\item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
\item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
\end{itemize}

\item
If $T$ is some other type, then the described mapping is performed on all its type components. 

\end{itemize}

If $T$ is a possibly parameterized class type, where $T$'s class is defined in some other class $D$, and $S$ is some prefix type, then we use ``$T$ seen from $S$'' as a shorthand for ``$T$ in $D$ seen from $S$''. 

\item
The {\em member bindings} of a type $T$ are:
\begin{enumerate}
\item All bindings $d$, such that there exists a type instance of some class $C$ among the base types of $T$ and there exists a definition or declaration of $d'$ in $C$, such that $d$ results from $d'$ by replacing every type $T'$ in $d'$ with $T'$ in $C$ seen from $T$.
\item All bindings of the type's refinement (\sref{sec:compound-types}), if it has one. 
\end{enumerate}

The definition of a type projection ~\lstinline!$S$#$t$!~ is the member binding $d_t$ of the type $t$ in $S$. In that case, we also say that {\em ~\lstinline!$S$#$t$!~ is defined by $d_t$}. 

\end{enumerate}







\section{Any-Value Type}
\label{sec:any-value-type}

\syntax\begin{lstlisting}[morekeywords={Any}]
Simple_Type ::= 'Any'
// also:
Simple_Type ::= 'Lang~[coral].Predef.Any'
\end{lstlisting}

This type does not represent a single concrete value type, but any concrete type. It is used in places where the actual type does not matter, and could be even from other language running along Coral in the VM. 

With respect to overloading resolution (\sref{sec:value-conversions}), this type is always the least specific, as there is no other less specific type available. 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Any} is used as a class type (never a trait type).

The \code{Any} identifier is not reserved for the language as a keyword, instead, it gets usually automatically imported with the \code{Predef} object, and therefore can be shadowed and aliased (e.g. to \code{Any_Object}). 

The \code{Any} virtual type is the actual root of the type system of Coral, although explicit inheritance is not allowed from it. Other languages that integrate with Coral on the same VM may have \code{Any} as their root type as well, disobeying the rule that is set only for Coral. This way, Coral preserves its unified type system. 





\section{Structural Inferred Auto Type}
\label{sec:auto-type}

\syntax\begin{lstlisting}[morekeywords={Auto}]
Simple_Type ::= 'Auto'
// also:
Simple_Type ::= 'Lang~[coral].Predef.Auto'
\end{lstlisting}

This type does represent a single concrete value type: a compound type with usually just the refinement part. However, it does not explicitly state what the refinement is. Instead, the refinement is inferred from the context in which it is used. The inference algorithm is very different from local type inference (\sref{sec:local-type-inference}). 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Auto} is used as a class type (never a trait type) and its parts of the inferred refinement are merged with any given refinement from the compound type. 

The \code{Auto} identifier is not reserved for the language as a keyword, instead, it gets usually automatically imported with the \code{Predef} object, and therefore can be shadowed and aliased (e.g. to \code{Inferred}). 

Elements that determines the inferred parts of the \code{Auto} type:

% TBD: update this simple list with more concrete details as the inference is defined
\begin{itemize}
  \item Any methods that are invoked on the value that has this type assigned. These are parts of the refinement. 
  \item Any classes or traits that are required of the value, except when there is a definitive \code{else}-style clause that allows the value to be of any other type as well. Those requirements are then presented in a union type, with the refinement being compound with each member of the union type. 
  \item If the value is passed as an argument anywhere, where the expected type is determined to be not \code{Any} or locally type inferred, then the aforementioned handling applies as if the expected type was required of the value.
  \item If a method is dynamically added to the value before being required, then it is not included in the refinement. 
  \item The \code{Auto} type is also automatically generalized. If a method that uses it has already type parameters, then these are appended after them, in order of appearance, with method result type being the last one. 
  \item If the value is passed as an argument, with an expected type to be locally type inferred, then it itself becomes typed with an unknown type and a type parameter is appended to the containing function.
\end{itemize}

There is one important limitation: the \code{Auto} type must not cause circular references between functions. In that case, the type has to be specified in another way. This inference happens only during compilation, unlike local type inference, which takes place in runtime. 

This kind of type inference is useful when a method only cares about actually used capabilities of it's parameters. In that way, it is similar to protocols, but only includes those capabilities that are actually used. Note that in runtime, test of structural types (refinements) is somewhat slower than simple type test, depending on the amount of members present in the refinement of the resulting compound type. This is common to compound types, where the test needs to check all components and not just one. 

\example An automatically generalized swap function.
\begin{lstlisting}
def swap (x: Auto, y: Auto): Auto
  (y, x)
end
\end{lstlisting}
This is inferred and generalized into the following polymorphic function:
\begin{lstlisting}
def swap [A, B] (x: A, y: B): (B, A)
  (y, x)
end
\end{lstlisting}
This inference and generalization is possible, because no other requirements are imposed on the values \code{x} and \code{y} and the result type is unaffected either. 

\example An automatically inferred function.
\begin{lstlisting}
def print (x: Auto): Unit
  IO.console.print x.to_string
end
\end{lstlisting}
This is inferred into the following function:
\begin{lstlisting}
def print (x: { def to_string (): String end }): Unit
  IO.console.print x.to_string
end
\end{lstlisting}
This happens because the only requirement on \code{x} is that it has a method \code{to_string} that accepts no arguments (could be variadic either), which is a requirement from the function body, and that method returns a \code{String}, which is a known requirement of parameter type of the \code{IO.console.print} function. Note that the refinement type is equivalent to:
\begin{lstlisting}
Any with refinement { def to_string (): String end }
\end{lstlisting}

\example Another automatically inferred function.
\begin{lstlisting}
def print (x: Auto): Unit
  IO.console.print x
end
\end{lstlisting}
This is inferred into the following function:
\begin{lstlisting}
def print (x: String): Unit
  IO.console.print x
end
\end{lstlisting}
Here, the only requirement on the value \code{x} comes from a known requirement of parameter type of the \code{IO.console.print} function. In fact, if \code{IO.console.print} had several overloaded variants, then the type of \code{x} would be inferred to be a union type of all the overloaded variants' requirements on it. 

By default, when a type annotation is missing in a function declaration, then it is either inherited (based on overriding), or taken to be \code{Auto}. A pragma (\sref{sec:pragmas}) exists to modify this default behaviour: to use other type in place of missing type annotation, use ~\lstinline!pragma missing-type $T$!, where $T$ can be also \code{Any}, or any other type, like \code{Object} and even \code{Dynamic} (\sref{sec:dynamic-type}). 

Note that \code{Auto} type inference does not track requirements of values from their usage within other methods.






\section{Dynamic Type}
\label{sec:dynamic-type}

\syntax\begin{lstlisting}[morekeywords={Dynamic}]
Simple_Type ::= 'Dynamic'
// also:
Simple_Type ::= 'Lang~[coral].Predef.Dynamic'
\end{lstlisting}

This type does not represent a single concrete value type\footnote{This type is similar to what ~\lstinline[language={[Sharp]C}]!dynamic!~ is to C\#.}, but any concrete type, very much like \code{Any} or \code{Auto}. 

In runtime, this type is always dynamically replaced by the type of the actual referenced value -- e.g., if a variable is typed with \code{Dynamic} type, assigned a value, and used in a function application, the type of that value is used, not \code{Dynamic}, unless it would be typed with \code{Any} again (\sref{sec:typed-expressions}). Nonetheless, this does not imply that a value of another type can not be assigned to that same variable -- such variable is still bound to \code{Dynamic} and accepts \code{Any} type. 

Structural constraints may be appended to this type as with any other type by using a new compound type (\sref{sec:compound-types}), where \code{Dynamic} is used as a trait type.\footnote{Thus, if \code{Dynamic} is used in a compound type, the compound type can contain a class type that is not \code{Dynamic}. This is different from \code{Any}, which can only appear as a class type.}

With respect to overloading resolution (\sref{sec:overloading-resolution}), this type is almost\footnote{The type annotation would have to 1:1 copy the runtime type to be the same specific, but no explicit type annotation can ever be more specific.} always the most specific, as it is replaced by the actual runtime type of the value it is assigned to. 

Typing an expression with this type triggers early evaluation, which is important to know if the expression is an argument expression and its corresponding parameter is lazily evaluated. 

If the \code{Dynamic} type is used as the type annotation of a parameter, it is translated to \code{Any} (plus additional structural constraints, if any present), and treated as \code{Dynamic} in the following code.

The \code{Dynamic} type is disallowed from use within type parameters, result types and conformance check expressions (\sref{sec:typed-expressions}). 

Using \code{Dynamic} type is one of possible ways to use multi-methods -- the type of arguments typed as \code{Dynamic} are bound at runtime, not during compilation. Moreover, the two approaches can be combined, as not every argument expression needs to be \code{Dynamic}. 








\section{Relations Between Types}

We define two relations between types. 
\begin{quote}\begin{tabular}{l@{\gap}l@{\gap}l}
\em Type equivalence & $T \equiv U$ & $T$ and $U$ are interchangeable
in all contexts.
\\
\em Conformance & $T \conforms U$ & Type $T$ conforms to type $U$.
\end{tabular}\end{quote}






\subsection{Type Equivalence}

Equivalence ($\equiv$) between types is the smallest congruence, such that the following statements are true:

\begin{itemize}
\item
If $t$ is defined by a type alias ~\lstinline@type t := T@, then $t$ is equivalent to $T$. 

\item
If a path $p$ has a singleton type ~\lstinline@$q$.type@, then \lstinline@$p$.type $\equiv\ q$.type@. 

\item
Two compound types (\sref{sec:compound-types}) are equivalent, if the sequences of their components are pairwise equivalent, occur in the same order and their refinements are equivalent.

\item
Two constrained types (\sref{sec:constrained-types}) are equivalent, if their base types are equivalent and their constraint blocks read the same. 

\item
Two refinements (\sref{sec:compound-types} \& \sref{sec:refinements}) are equivalent, if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements. 

\item
Two method types (\sref{sec:method-types}) are equivalent, if they are {\em override-equivalent} (\sref{sec:method-signature}).

\item
Two polymorphic method types (\sref{sec:polymorphic-method-types}) are equivalent, if they have the same number of type parameters, the result types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\item
Two existential types (\sref{sec:existential-types}) are equivalent, if they have the same number of quantifiers and the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent. 

\item
Two type constructors (\sref{sec:type-constructors}) are equivalent, if they have the same number of type parameters, the result types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\item 
Two unions (\sref{sec:unions}) are equivalent, if they have the same number of member types and those types are pairwise equivalent. 

\end{itemize}






\subsection{Conformance}
\label{sec:conformance}

The conformance relation $(\conforms)$ is the smallest transitive relation that satisfies the following conditions:

\begin{itemize}

\item
Conformance includes equivalence, therefore if $T \equiv U$, then \lstinline@$T \conforms U$@. 

\item
For every value type $T$, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
For every type constructor $T$ with any number of type parameters, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
A type variable $t$ conforms to its upper bound and its lower bound conforms to $t$. 

\item
A class type or a parameterized type conforms to any of its base types. 

\item
A class type or a parameterized type conforms to a union type, iff it conforms to at least one of the union's component types. 

\item 
A singleton type ~\lstinline!$p$.type!~ conforms to the type of the path $p$.

\item
A type projection ~\lstinline!$T$#$t$!~ conforms to ~\lstinline!$U$#$t$!~ if $T$ conforms to $U$. 

\item
A unit of measure type $t$ conforms to another unit of measure type $u$ if and only if $t \equiv u$ or $t$ extends $u$, where $us$ is an abstract unit of measure type. 

\item 
A parameterized type ~\lstinline!$T$[$T_1 \commadots T_n$]!~ conforms to ~\lstinline!$T$[$U_1 \commadots U_n$]!~ if the following conditions hold for $i = 1 \commadots n$.
  \begin{itemize}
  \item If the $i^{\superth}$ type parameter of $T$ is declared covariant, then $T_i \conforms U_i$.
  \item If the $i^{\superth}$ type parameter of $T$ is declared contravariant, then $U_i \conforms T_i$.
  \item If the $i^{\superth}$ type parameter of $T$ is declared invariant (neither covariant nor contravariant), then $U_i \equiv T_i$.
  \item If the $i^{\superth}$ type parameter of $T$ is declared with a conformance restricting annotation, then that annotation of $T_i$ must conform to the corresponding annotation of $U_i$. 
  \end{itemize}

\item
A unit of type $N$ conforms to unit of type $U$ if $N$ extends $U$ or if $N \equiv U$. 

\item
A parameterized type ~\lstinline!$T$[<$N_1 \commadots N_n$>]!~ conforms to ~\lstinline!$T$[<$U_1 \commadots U_n$>]!~ if the following conditions hold for $i = 1 \commadots n$.
\begin{itemize}
\item For the $i^{\superth}$ type parameter of $T$, $N_i \conforms U_i$.
\end{itemize}

\item 
A compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$ with { $R$ }!~ conforms to each of its component types $T_i$, and to any compound type created as a combination of subsets of the components, excluding empty sets. 

\item
A constrained type ~\lstinline!$T$ with constraint $b$!~ conforms to $T$. A type ~\lstinline!$T$ with constraint $b_1$!~ conforms to ~\lstinline!$T$ with constraint $b_2$!, if any value $e$ that conforms ~\lstinline!$T$ with constraint $b_1$!~ by being a member of $T$ and passing the test presented by $b_1$, also conforms to ~\lstinline!$T$ with constraint $b_2$!~ by passing the test presented by $b_2$.\footnote{This conformance is only tested based on actual values being tested, not the types themselves.}

\item 
If $T \conforms U_i$ for $i = 1 \commadots n$, and every binding $d$ of a type or value $x$ in $R$ exists a member binding of $x$ in $T$ which subsumes $d$, then $T$ conforms to the compound type ~\lstinline!$U_1$ with $\ldots$ with $U_n$ with { $R$ }!. 

\item
The existential type ~\lstinline!$T$ for-some { $Q$ }!~ conforms to $U$, if its skolemization (\sref{sec:existential-types}) conforms to $U$. This also means that the $t'_i$ type variables have to fall in between $U$'s type parameter bounds. 

\item
The type $T$ conforms to the existential type ~\lstinline!$U$ for-some { $Q$ }!~ if $T$ conforms to at least one of the type instances (\sref{sec:existential-types}) of ~\lstinline!$U$ for-some { $Q$ }!. 

\item
If $T_i \equiv T'_i$ for $i = 1 \commadots n$ and $R \conforms R'$, then the method type ~\lstinline!($p_1$: $T_1 \commadots p_n$: $T_n$) $\mapsto\ R$!~ conforms to ~\lstinline!($p'_1$: $T'_1 \commadots p'_n$: $T'_n$) $\mapsto\ R'$!. 

\item
The polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto\ T$
\end{lstlisting}
conforms to the polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L'_1$ <: $U'_1 \commadots \pm a_n$ >: $L'_n$ <: $U'_n$] $\mapsto\ T'$
\end{lstlisting}
if one has $T \conforms T'$, and $L_i \conforms L'_i$ and $U_i \conforms U'_i$ for $i = 1 \commadots n$. 

\item
Polymorphic types or type constructors $T$ and $T'$ must also fulfil the following. We characterize $T$ and $T'$ by their type parameter clauses ~\lstinline![$a_1 \commadots a_n$]!~ and ~\lstinline![$a'_1 \commadots a'_n$]!, where an $a_i$ or $a'_i$ may include a variance annotation, annotations, a higher-order type parameter clauses, and bounds. Then, $T$ conforms to $T'$ if any list ~\lstinline![$t_1 \commadots t_n$]!~ -- with declared variances, annotations, bounds and higher-order type parameter clauses -- of valid type arguments for $T'$ is also a valid list of type arguments for $T$ and ~\lstinline!$T$[$t_1 \commadots t_n$] <: $T'$[$t_1 \commadots t_n$]!. Note that this entails that:
  \begin{itemize}
  \item The bounds on $a_i$ must be the same or weaker than the corresponding bounds declared for $a'_i$. 
  \item The variance of $a_i$ must match the variance of $a'_i$, where covariance matches covariance, contravariance matches contravariance and any variance matches invariance. 
  \item If annotation of $a'_i$ restricts conformance (\sref{sec:annotations}), then the corresponding annotation of $a_i$ must conform to it. 
  \item Recursively, these restrictions apply to the corresponding higher-order type parameter clauses of $a_i$ and $a'_i$. 
  \end{itemize}

\item 
A function type ~\lstinline!($T_1 \commadots T_n$) -> $R$!~ (name it $f$) conforms to a function type ~\lstinline!($T'_1 \commadots T'_m$) -> $R'$!~ (name it $f'$), if types of arguments that are applicable to $f'$ are also applicable to $f$ (\sref{sec:function-applications}), and if $R$ conforms to $R'$. This includes reordering of named arguments/parameters and handling of repeated/optional parameters, and also variances -- since although $f$ might be applied to whatever $f'$ might be applied to, $f'$ might not be applied to whatever $f$ might be applied to (and vice versa).

\item
Polymorphic function traits ~\lstinline!Function_$n$!~ and ~\lstinline!Partial_Function!~ follow the rules for conformance of function types, as defined above. The repeated parameter, optional parameters, named parameters and all capturing parameters are derived from their conformance restricting annotations (\sref{sec:annotations}). Note that optional parameters may not be expressed with function types in another than with an annotation. The rules may be inverted in the means of constructing a virtual methods $m$ and $m'$ that are reconstructed from the type arguments of the function types $f$ and $f'$ respectively, and applying the rules for function types on them.
 
\item 
A union type (\sref{sec:unions}) $U_1$ conforms to $U_2$, if every member type that is present in $U_2$ has also an equivalent member type in $U_1$. $U_1$ may thus contain more member types than $U_2$, but must contain all of member types in $U_2$. 
\end{itemize}

A declaration or definition in some compound type of class type $C$ {\em subsumes} another declaration of the same name in some compound type or class type $C'$, if one of the following conditions holds. 
  \begin{itemize}
  \item A value declaration or definition that defines a name $x$ with type $T$ subsumes a value or method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
  \item A method declaration or definition that defines a name $x$ with type $T$ subsumes a method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
  \item A type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] := $T$!~ subsumes a type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] := $T'$!~ if $T \equiv T'$. 
  \item A type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!~ subsumes a type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L'$ <: $U'$!, if $L' \conforms L$ and $U \conforms U'$. 
  \item A type or class definition that binds a type name $t$ subsumes an abstract type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!, if $L \conforms t \conforms U$. 
  \end{itemize}

The ($\conforms$) relation forms partial order between types, i.e. it is transitive, antisymmetric and reflexive. The terms {\em least upper bound} and {\em greatest lower bound} of a set of types are understood to be relative to that order. 

\paragraph{Note}
The least upper bound or the greatest lower bound of a set of types does not always exist. Coral is free to reject a term which has a type specified as a least upper bound or a greatest lower bound, and that bound would be more complex than a preset limit, e.g. this could happen with infinite bounds sequence. 

The least upper bound or the greatest lower bound might also not be unique. If there are several such bounds, Coral is free to pick up any of them. 





\subsection{Weak Conformance}
\label{sec:weak-conformance}

For now, {\em weak conformance} is a relation defined on members of the \code{Number} type as a relaxation of conformance, written as $S \conforms _w T$. The relation is simple: a type $t$ weakly conforms to another type $u$ when $u$'s size contains all values of $t$ (we say that $t$ can be converted to $u$ without precision loss). 

A {\em weak least upper bound} is a least upper bound with respect to weak conformance. 





\section{Reified Types}
\label{sec:reified-types}

Unlike in Java or Scala, {\em type erasure} does not exist in Coral. Instead, type arguments are {\em reified} -- meaning that they persist in runtime. This is achieved by generating a lightweight subtype of parameterized types, containing basically just a reference to the parameterized type and a tuple of type arguments. This also implies that each new combination of type arguments to the exact same parameterized type creates a new lightweight subtype.

Reified types have some major effects on programs in Coral:
\begin{itemize}

\item Type arguments are accessible in runtime. The actual type argument can be inspected via reflection. 

\item Type arguments do not go away after compilation. This means, for example, that mutable collections should have invariant type parameters, since a hypothetical \code{List[+T]} can have type instance \code{List[String]} assigned to a variable bound to be a \code{List[Object]}, but instances of other subclasses than those that conform to \code{String} will not be able to be added to the collection. This is in fact true even if Coral did have type erasure -- the difference is, with reified types, the addition of a new incompatible value will fail immediately, unlike with type erasure, where retrieving the added value would fail later. 
\end{itemize}





\section{Types Representing Emptiness}
\label{sec:emptiness}

In Coral, there are a few types and their values that represent emptiness of some sort. The following lists specifies their semantical purposes. 

\begin{enumerate}
  \item The \code{Nothing} type. It represents a missing object in places where an object is expected. 
  
  The type has just one inhabitant, and that is the frozen \code{nil} value. 
  
  \item The \code{Undefined} type. It represents a missing object in places where an object is expected, but its source is not defined. This applies to non-defined instance variables, undefined variables, or undefined mappings in, e.g., \code{Map} implementations. 
  
  The type has just one inhabitant, and that is the frozen \code{undefined} value, which is equal to, but not identical to \code{nil}. 
  
  The semantical difference between a \code{nil} and \code{undefined} in context of, e.g., \code{Map} implementations is that \code{nil} is returned if the map contains the given key, but has \code{nil} assigned to it on purpose, whereas \code{undefined} means there was no mapping defined. 
  
  Coral forbids access to undefined local variables during compilation, unlike e.g. JavaScript. 
  
  \item The \code{None} case object. It is a subtype of \code{Option[$T$]} and represents the exact same thing as \code{Nothing}, but has the extra semantical meaning of ``being ready to handle missing values'', which non-nullable types do not represent -- those expect a value to be present and cause errors when it is not present. 
  
  The \code{None} case object is primarily designed to be used with pattern matching, and also plays an important internal part in Coral's implementation of pattern matching. 
  
  Implicit conversion (\sref{sec:implicit-conversions}) from \code{Nothing} and \code{Undefined} to \code{Option[$T$]} is defined in \code{Predef} (\sref{sec:predef}), and results in \code{None}. 
  
  \item The \code{Unit} type. It is basically a \code{Tuple_0} type. 
  
  It's semantical meaning is that no value is even expected. It is used for functions that should never return any value, and that are technically procedures, whose purpose lies in side-effects. 
  
  The type has just one inhabitant, the ``\code{()}'' value, also known as an empty tuple. 
  
  There are no implicit conversions from \code{Unit} to any other type defined by Coral. 
\end{enumerate}

The following lines show some common relations between empty values. 
\begin{lstlisting}
nil = undefined  // yes
nil == undefined // no
nil = None       // no
undefined = None // no
() = undefined   // no
() = nil         // no

Nothing === nil         // yes
Nothing === undefined   // yes
Nothing === ()          // no
Undefined === nil       // no
Undefined === undefined // yes
Undefined === ()        // no
Unit === nil            // no
Unit === undefined      // no
Unit === ()             // yes

val nothing := nil
match nothing {
  when Some(x) then () // does not match
  when None then ()    // matches
}

val nothing := get_undefined // a function that returns `undefined'
match nothing {
  when Some(x) then () // does not match
  when None then ()    // matches
}

val unit = ()
match unit {
  when Some(x) then () // does not match, 
                       // also compilation warning, because Unit 
                       // is not compatible to Option[T]
  when None then ()    // does not match, also not compatible
  when Unit then ()    // matches
}
\end{lstlisting}







