%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Types}

\syntax\begin{lstlisting}
Type                ::= Function_Type
                      | Compound_Type [Existential_Clauses]
Function_Type       ::= Function_Args {'->' Function_Args} 
                        '->' Return_Type
Function_Args       ::= Compound_Type
                      | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg        ::= [Param_Io] ['*'] [':' variable_id] Param_Type
                      | '&' Function_Type
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
                      | 'var' Var_Dcl
Compound_Type       ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                        ['with' ['refinement'] Refine_Stats]
                      | ['refinement'] Refine_Stats
Annot_Type          ::= {Annotation} Simple_Type
Simple_Type         ::= Simple_Type [Type_Args] [Dep_Args] [UoM_Args]
                      | Simple_Type '#' constant_id
                      | Stable_Id
                      | Path '.' ('type' | 'singleton-type')
                      | '(' Types ')'
Types               ::= Type {',' Type}
\end{lstlisting}

When we say \textit{type} in the context of Coral, we are talking about a blueprint of an entity, while the type itself is an entity. Every type in Coral is backed by a \textit{class}, which is an instance of the type \lstinline@Class@. 

We distinguish a few different properties of types in Coral. There are first-order types and type constructors, which take type parameters and yield new types. A subset of first-order types called \textit{value types} represents set of first-class values. Value types are either \textit{concrete} or \textit{abstract}. 

Concrete value types can be either a \textit{class type} (e.g. referenced with a type designator, referencing a class or maybe a trait), or a \textit{compound type} representing an intersection of types, possibly with a refinement that further constrains the types of its members. Both class types and compound types may be bound to a constant, but only class types referencing a concrete class can be blueprints of values -- \textit{objects}. Compound types can only constrain bindings to a subset of other types. 

Non-value types capture properties of identifiers that are not values. For instance, a type constructor does not directly specify a type of values, but a type constructor, when applied to the correct type arguments, yields a first-order type, which may be a value type. Non-value types are expressed indirectly in Coral. In example, a method type is described by writing down a method signature, which is not a real type itself, but it creates a corresponding method type. 






\section{About Coral's Type System}

There are two main streams of typing systems out there -- statically typed and dynamically typed. Static typing in a language usually means that the language is compiled into an executable with a definite set of types and every operation is type checked. Dynamic typing means that these checks are deferred until needed, in runtime. 

Let's talk about Java. Java uses static typing -- but, in a very limited and unfriendly way, you may use class loaders and a lot of type casts to dynamically load a new class. And then possibly endure a lot of pain using it. 

Let's talk about Ruby. Ruby uses dynamic typing -- but, using types blindly can possibly lead to some confusion. Ruby is amazing though, because you can write programs with it really fast and enjoy the process at the same time. But when it comes to type safety, you need to be careful. 

And now, move on to Coral. Coral uses hybrid typing. In its core, it uses dynamic typing all the way. But, it allows to opt-in for some limited static typing\footnote{This feature is expected to be gradually improved and un-limited.}. Unlike in Ruby, you can overload methods (not just override!). You can constrain variables, constants, properties, arguments and return types to particular types. But you don't have to. Types in Coral were heavily inspired by Scala's type system, but modified for this dynamic environment that Coral provides. Unlike in Ruby, you can have pure interfaces (called protocols\footnote{Interfaces in Coral are used to extract the \textit{public interface} of classes in modules, so that only a small amount of code may be distributed along with the module to allow binding to it.}), or interfaces with default method implementations (similar to Java 8). Unlike in Java, you can have traits, union types and much more. Unlike in Java, you may easily modify classes, even from other modules (\textit{pimp my library!}). You may even easily add more classes if needed, and possibly shadow existing ones. In face of static typing in Coral, \textit{no type} specified is saying that the value is of any type. 

While Coral is so dynamic, it also needs to maintain stability and performance. Therefore, it ``caches'' its bindings and tracks versions of each type\footnote{Versions are simply integers that are incremented with each significant change to the type and distributed among its subtypes.}. If a \textit{cached binding} would change, it is ok -- as long as the new binding would conform to the old one. Practically, the code that executes first initiates the binding -- first to come, first to bind. Bindings are also cached, so that the Coral interpreter does not need to traverse types all the time -- it only does so if the needed binding does not exist (initial state), or if the cached version does not match the actual version of the bound type. This mechanism is also used for caching methods, not only types. Moreover, this mechanism ensures that type projections (\sref{sec:type-projection}) are valid at any time of execution, even if their binding changes. 

Types in Coral are represented by objects that are members of the \code{Class} type. 






\section{Paths}
\label{sec:type-paths}

\syntax\begin{lstlisting}
path_id          ::= constant_id 
                   | variable_id
                   | function_id
                   | op_id
                   | path_id [Type_Args] [UoM_Args]
Path             ::= Stable_Id
                   | [path_id '.'] ('this' | 'self')
                   | 'self' '[' 'cloned' ']'
Stable_Id        ::= path_id
                   | Path '.' path_id
                   | [path_id '.'] 'super' [Class_Qualifier] 
                     '.' path_id
Class_Qualifier  ::= '[' path_id ']'
\end{lstlisting}

Paths are not types themselves, but they can be a part of named types and in that function form a role in Coral's type system. 

A path is one of the following: \footnote{This section might need a review of what a path is, since we claim that the referenced entity is a member, yet the syntax only mentions \code{constant_id}.}

\begin{itemize}
\item 
The empty path $\epsilon$ (which can not be written explicitly in user programs). 

\item 
\code{this}, which references the directly enclosing class. 

\item 
\lstinline@$C$.self@, where $C$ references a class or a trait. The path \code{self} is taken as a shorthand for \lstinline@$C$.self@, where $C$ is the name of the class directly enclosing the reference. 

\item
\lstinline@self[cloned]@, which references the directly enclosing class of a clone (a cloned instance, see \sref{sec:clone-def}). 

\item 
\lstinline@$p$.$x$@, where $p$ is a path and $x$ is a member of $p$. Additionally, $p$ allows modules to appear instead of references to classes or traits, but no module reference can follow a class or a trait reference: \lstinline@{module_ref '.'} {(class_ref|trait_ref) '.'} $\ldots$@. 

\item
\lstinline@$C$.super.$x$@ or \lstinline@$C$.super[$M$].$x$@, where $C$ references a class or a trait and $x$ references a member of the superclass or designated parent class $M$ of $C$. The prefix \code{super} is taken as a shorthand for \lstinline@$C$#super@, where $C$ is the name of the class directly enclosing the reference, and \lstinline@super[$M$]@ as a shorthand for \lstinline@$C$.super[$M$]@, where $C$ is yet again the name of the class directly enclosing the reference. 
\end{itemize}






\section{Value Types}

Every value in Coral has a type which is of one of the following forms. 






\subsection{Value \& Singleton Type}
\label{sec:value-types}
\label{sec:singleton-types}

\syntax\begin{lstlisting}
Simple_Type ::= Path '.' 'type'
Simple_Type ::= Path '.' 'singleton-type'
\end{lstlisting}

A singleton type is of the form \lstinline@$p$.singleton-type@ and a special type that denotes the set of values consisting of \code{nil} and the value denoted by $p$. A value type, on the other hand, is a special type that denotes the set of values consisting of \code{nil} and every value that conforms to the type of value denoted by $p$.\footnote{This is useful when using a value as prototype of new values.}






\subsection{Type Projection}
\label{sec:type-projection}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type '#' constant_id
\end{lstlisting}

A type projection \lstinline@$T$#$x$@ references type member named $x$ of type $T$. This is useful i.e. with nested classes that belong to the class instances, not the class object. 






\subsection{Type Designators}

\syntax\begin{lstlisting}
Simple_Type ::= Stable_Id
\end{lstlisting}

A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections. 

Specifically, the unqualified type name $t$ where $t$ is bound in some class, object or module $C$ is taken as a shorthand for \lstinline@$C$.self.type#$t$@. If $t$ is not bound in a class, object or module, then $t$ is taken as a shorthand for \lstinline@$\epsilon$.type#$t$@. 

A qualified type designator has the form \lstinline@$p$.$t$@, where $p$ is a path (\sref{sec:type-paths}) and $t$ is a type name. Such a type designator is equivalent to the type projection \lstinline@$p$.type#$t$@. 






\subsection{Parameterized Types}
\label{sec:parameterized-types}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type [Type_Args] [UoM_Args]
Type_Args   ::= '[' Types ']'
Types       ::= Type {',' Type}
UoM_Args    ::= '[<' uom_expr '>]'
\end{lstlisting}

A parameterized type $T[T_1 \commadots T_n]$ consists of a type designator $T$ and type parameters $T_1 \commadots T_n$, where $n \geq 1$. $T$ must refer to a type constructor which takes exactly $n$ type parameters $a_1 \commadots a_n$. 

Say the type parameters have lower bounds $L_1 \commadots L_n$ and upper bounds $U_1 \commadots U_n$. The parameterized type is well-formed if each actual type parameter {\em conforms to its bounds}, so that $\sigma L_i <: T_i <: \sigma U_i$, where $\sigma$ is the substitution $[a_1 := T_1 \commadots a_n := T_n]$\footnote{The substitution works by replacing occurrences of $a_i$ in the argument by $T_i$, so that, e.g. ~\lstinline[mathescape=false]!$A <: Comparable[$A]!~ is substituted into ~\lstinline!$C$ <: Comparable[$C$]!.}. Also, $U_i$ must never be a subtype of $L_i$, since no other type ever would be able to fulfil the bounds ($U_i$ and $L_i$ may be the exact same type though, but in that case the type parameter would be invariant and the whole point of having a parameterized type would be useless). 

\example
\label{example:parameterized-types}
Given the generic type definitions: 

\begin{lstlisting}[escapechar=@]
class Tree_Map[@\$@A <: Comparable[@\$@A], @\$@B] $\ldots$ end
class List[@\$@A] $\ldots$ end
class I; implements Comparable[I]; $\ldots$ end

class F[@\$@M[_], @\$@X] $\ldots$ end
class S[@\$@K <: String] $\ldots$ end
class G[@\$@M[@\$@Z <: @\$@I], @\$@I] $\ldots$ end
\end{lstlisting}

the following parameterized types are well-formed: 

\begin{lstlisting}
Tree_Map[I, String]
List[I]
List[List[Boolean]]

F[List, Number]
G[S, String]
\end{lstlisting}

\example
\label{example:parameterized-types-mal}

Given the type definitions of the previous example, the following types are malformed: 

\begin{lstlisting}
Tree_Map[I]               // wrong number of parameters
Tree_Map[List[I], Number] // type parameter List not within bound

F[Number, Boolean]        // Number is not a type constructor
F[Tree_Map, Number]       // Tree_Map takes two parameters, 
                          //   F expects a type constructor taking one

G[S, Number]              // type S constrains its parameter to
                          //   conform to String, 
                          // G expects type constructor with a parameter
                          //   that conforms to Number
\end{lstlisting}





\subsection{Tuple Types}
\label{sec:tuple-types}

\syntax\begin{lstlisting}
Simple_Type ::= '(' Types ')'
\end{lstlisting}

A tuple type ($T_1 \commadots T_n$) is an alias for the class \lstinline@Tuple_$n$[$T_1 \commadots T_n$]@, where $n \geq 2$. 

Tuple classes are available as patterns for pattern matching. The properties can be accessed as methods \lstinline@[1]$ \commadots $[$n$]@ (using an ``offset'' that is outside of the tuple's size results in a method-not-found error, not offset-out-of-bounds -- tuple classes do not implement the operator \lstinline@[i]@ for arbitrary $i$). 

Tuple classes are generated lazily by the runtime as needed, so that the language does not constrain users to tuples of only limited sizes, but allows any size. 

An effort will be made to introduce a simple enough syntax for variable parameterized types, if possible, until then, \lstinline@Tuple_$i$@ are the only such types. 






\subsection{Annotated Types}

\syntax\begin{lstlisting}
Annot_Type ::= {Annotation} Simple_Type
\end{lstlisting}

An annotated type $a_1 \ldots a_n T$ attaches annotations $a_1 \commadots a_n$ to the type $T$. % TBD: add ref to a chapter about annotations.






\subsection{Compound Types}
\label{sec:compound-types}

\syntax\begin{lstlisting}
Compound_Type ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                  ['with' ['refinement'] Refine_Stats]
                | ['refinement'] Refine_Stats
Refine_Stats  ::= '{' [Refine_Stat {semi Refine_Stat}] '}'
Refine_Stat   ::= Dcl
                | 'type' Type_Def
\end{lstlisting} % TBD: define Refine_Stat syntax

A compound type \lstinline@$T_1$ with $\ldots$ with $T_n$ with refinement {$R$}@ represents values with members as given in the component types $T_1 \commadots T_n$ and the refinement \lstinline@{$R$}@. A refinement \lstinline@{$R$}@ contains declarations and definitions (\sref{sec:refinements}). 

If no refinement is given, the type is implicitly equivalent to the same type having an empty refinement. 

A compound type may also consist of just a refinement \lstinline@{$R$}@ with no preceding component types -- such a type has an implicit component type \code{Object} and describes the member values as ``any value, as long as it has what the refinement requires'', thus it works like an anonymous protocol. 

If a compound type does not contain a concrete class type, then \code{Object} is implied in case the type is used as a concrete class\footnote{Meaning that the compound type is used as an ad-hoc (possibly anonymous) class, e.g. to create new instances of it.}.

The keyword \code{refinement} instructs that the following tokens will be a part of a refinement, and the construct ~\lstinline!refinement {$R$}!~ is called an {\em anonymous refinement}, being equivalent to ~\lstinline!Object with refinement {$R$}!, although when the refinement is a part of a compound type with more elements than just the refinement itself, the \code{Object} type is replaced with the class type appearing in the compound type, if any. 

The \code{refinement} keyword can be omitted from a compound type that consists of more elements than just the refinement. Constructs ~\lstinline!Object with {$R$}!~ and ~\lstinline!refinement {$R$}!~ are then equal. 

The \code{refinement} keyword may also be omitted from a compound type that consists of just the refinement, but only in contexts in which a type is expected, i.e.: parameter type declaration, value or variable type declaration, return type declaration, type argument application or type parameter declaration; but never stand-alone. If used as such, the constructs ~\lstinline!refinement {$R$}!~ and ~\lstinline!{$R$}!~ are then equal. 






\subsection{Function Types}
\label{sec:function-types}

\syntax\begin{lstlisting}
Type          ::= [Function_Args {'->' Function_Args}] 
                  '->' Return_Type
Function_Args ::= Compound_Type
                | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg  ::= [Param_Io] ['*'] [':' variable_id] Param_Type
                | '&' Function_Type
Return_Type   ::= Type | '(' ')'
\end{lstlisting}

The type \lstinline@($T_1 \commadots T_n$) -> $R$@ represents the set of function values that take arguments of types $T_1 \commadots T_n$ and yield results of type $R$. In the case of exactly one argument, type \lstinline@$T$ -> $R$@ is a shorthand for \lstinline@($T$) -> $R$@. Empty arguments list is indeed also possible as \lstinline@-> $R$@, equivalent to \lstinline@() -> $R$@.

Function types associate to the right, e.g. \lstinline@($S$) -> ($T$) -> $R$@ is the same as \lstinline@($S$) -> (($T$) -> $R$)@. 

Function types are shorthands for class types that conform to the \lstinline@Function_$i$@ protocol -- i.e. having an \code{apply} function or simply {\em being} a function. The $n$-ary function type \lstinline@($T_1 \commadots T_n$) -> $R$@ is a shorthand for the protocol \lstinline@Function_$n$[$T_1 \commadots T_n,R$]@. Such protocols are defined in the Coral library for any $n \ge 0$:

\begin{lstlisting}[escapechar=`]
protocol Function_$n$[-`\$`$T_1$ $\commadots$ -`\$`$T_n$, +`\$`$R$]
  message apply ($x_1$ : `\$`$T_1$ $\commadots$ $x_n$ : `\$`$T_n$): `\$`$R$
  $\ldots$
end protocol
\end{lstlisting}

Function types are covariant in their result type and contravariant in their argument types (\sref{sec:variance-of-type-parameters}).

A function return type may be declared as simple ``\lstinline!()!'', which is equivalent to the return type of ~\code{Unit}, which in turn is equivalent to empty return type, similar to \lstinline[language=C]!void! in C-related languages. Such a type is then written equivalently as either ~\lstinline!($S$) -> ()!~ or ~\lstinline!($S$) -> Unit!. 

Function arguments may be optionally annotated with more requirements: 
\begin{itemize}
\item
Parameter prefixed with \code{Param_Io} defines whether the parameter is required to be an output parameter. 

\item
Parameter prefixed with ``\lstinline!*!'' is a requirement of a repeated parameter. 

\item 
Parameter prefixed with ~\lstinline!:$x$!~ is a requirement of a named parameter. Note that a requirement of a parameter capturing other named parameters is not available. 

\item
Parameter prefixed with ``\lstinline!&!'' is a requirement for the passed block. It does not tell whether the function must capture the passed block, it only restricts the requirements on the particular block. The actual passed block may have more or even less positional or named parameters (extra ones on the block side are given \code{nil}, unless the type is not nullable (\sref{sec:nullability}) -- that is an error; and extra ones on the type side are simply discared), but the return type of the passed block must conform (\sref{sec:conformance}). 
\end{itemize}






\subsection{Existential Types}
\label{sec:existential-types}

\syntax\begin{lstlisting}[escapechar=@]
Type                ::= Compound_Type Existential_Clauses
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
                      | 'var' Var_Dcl
\end{lstlisting}

An existential type has the form \lstinline@$T$ for-some {$Q$}@, where $Q$ is a sequence of type declarations. Let \lstinline@$t_1$[$tps_1$] >: $L_1$ <: $U_1$ $\commadots$ $t_n$[$tps_n$] >: $L_n$ <: $U_n$@ be the types declared in $Q$. 

A {\em type instance} of \lstinline@$T$ for-some {$Q$}@ is a type $\sigma T$, where $\sigma$ is a substitution over $t_1 \commadots t_n$, such that for each $i$, \lstinline@$L_i$ <: $t_i$ <: $U_i$@. The set of values denoted by the existential type \lstinline@$T$ for-some {$Q$}@ is the union of the set of values of all its type instances. 






\subsection{Nullable Types}
\label{sec:nullable-types}

\syntax\begin{lstlisting}
Nullable_Type ::= Type [Nullable_Mod]
Nullable_Mod  ::= '?' | '!'
\end{lstlisting}

A nullable type has the form \lstinline!$T$?! or \lstinline@$T$!@, where ``\code{?}'' denotes explicitly a nullable type, and ``\code{!}'' denotes explicitly not-nullable type. Although \code{nil} as the singleton member of the \code{Nothing} type is a subtype of every type, Coral types are implicitly not-nullable, meaning it's not possible to pass \code{nil} where an instance of $T$ is expected, unless $T$ is of course \code{Nothing}. Nullability (\sref{sec:nullability}) is one of the intrinsic properties of every class type. 

Explicitly nullable types are handled by an intrinsic anonymous subtype of $T$, which is explicitly nullable, overriding the preference of $T$. Explicitly not-nullable types are handled by an intrinsic anonymous subtype of $T$, which is explicitly not-nullable, overriding the preference of $T$. Explicit nullability of already nullable types is redundant, as is explicit non-nullability of already not-nullable types. Explicit nullability of the \code{Option} type is also redundant and is in fact ignored. 

Nullable types in this form can appear as types of variables, parameters and return types. 






\subsection{Dependent Types}
\label{sec:dependent-types}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type Dep_Args
Dep_Args    ::= '@[' Dep_Arg {',' Dep_Arg} ']'
Dep_Arg     ::= variable_id | Dep_Sort_Val
\end{lstlisting}

Dependent types in Coral are implemented by simple indexed types. Dependent types are explained in greater detail in \sref{sec:dependent-types-decl}. 

\example The following are examples of dependent types representing the number 42 and all strings of length 42:
\begin{lstlisting}
Integer@[42]
String@[42]
\end{lstlisting}






\section{Non-Value Types}

The types explained in the following paragraphs do not appear explicitly in programs, they are internal and do not represent any type of value directly. 






\subsection{Method Types}
\label{sec:method-types}

A method type is denoted internally as $(Ps) \mapsto R$, where $(Ps)$ is a sequence of parameter names, types and extra properties $(ep_1 : T_1 \commadots ep_n : T_n)$ for some $n \geq 0$ and $R$ is a (value or method) type. This type represents named or anonymous methods that take arguments named $p_1 \commadots p_n$ of types $T_1 \commadots T_n$, have extra properties $e$ and return a result of type $R$. Names of parameters are either simple identifiers (for positional argument passing) or symbol literals (\sref{sec:symbolliterals}, for named arguments passing -- they make difference between method types with possibly same parameter types, therefore the name is a part of the method type along with the associated parameter type\footnote{This means that, for simplicity, if we have a method with one parameter, which is a named parameter, represented by having its name expressed with a symbol literal, and the parameters have an equivalent type, but different names, the method types are not equivalent.}). 

Method types associate to the right:\footnote{Like in Haskell or Scala.} \newline
$(Ps_1) \mapsto (Ps_2) \mapsto R$ is treated as $(Ps_1) \mapsto ((Ps_2) \mapsto R)$. 

A special case are types of methods without any parameters. They are written here as $() \mapsto R$. 

Another special case are types of methods without any return type. They are written here as $(Ps) \mapsto ()$. Methods that have this return type do not have an implicit return expressions and an attempt to return a value from it results in a compile-time error.\footnote{A compile-time error like this may happen during a runtime evaluation as well.}

Method types do not exist as types of values. If a method name is used as a value, its type is implicitly converted to a corresponding function type (\sref{sec:function-types}). 

Extra properties of parameters are as follows: a \lstinline@*@ for variable arguments, \lstinline@**@ for any named arguments and \lstinline@&@ for a captured block argument, or nothing for regular parameters. 

\example The declarations
\begin{lstlisting}
def a: -> Integer // or def a () -> Integer
def b (x : Integer): Boolean
def c (x : Integer): (y : String, z : String) -> String
def d (:x : Integer): Integer
def e (*x : Integer): Integer
def f (Integer): ()
def g (Integer)(Integer): Integer
def h (Integer): (Integer) -> Integer
\end{lstlisting}
produce the typings
\begin{lstlisting}
a : () $\mapsto$ Integer
b : (Integer) $\mapsto$ Boolean
c : (Integer) $\mapsto$ (String, String) $\mapsto$ String
d : (:x Integer) $\mapsto$ Integer
e : (*Integer) $\mapsto$ Integer
f : (Integer) $\mapsto$ ()
g : (Integer) $\mapsto$ (Integer) $\mapsto$ Integer
g : (Integer) $\mapsto$ (Integer) $\mapsto$ Integer
\end{lstlisting}

The difference between the ``\code{g}'' and ``\code{h}'' functions is that using the chain of return types as in function ``\code{g}'', the function body is automatically curried to return a function that is of type \lstinline@(Integer) $\mapsto$ Integer@. With the function ``\code{h}'', currying has to be implemented manually. 






\subsection{Polymorphic Method Types}
\label{sec:polymorphic-method-types}

A polymorphic method type is the same as a regular method type, but enhanced with a type parameters section. It is denoted internally as \lstinline@[$tps$]$ \mapsto T$@, where \lstinline@[$tps$]@ is a type parameter section \lstinline@[$a_1$ >: $L_1$ <: $U_1$ $\commadots$ $a_n$ >: $L_n$ <: $U_n$]@ for some $n \geq 0$ and $T$ is a (value or method) type. This type represents (only\footnote{Not anonymous.}) named methods that take type arguments $S_1 \commadots S_n$, for which the lower bounds $L_1 \commadots L_n$ conform (\sref{sec:conformance}) to the type arguments and the type arguments conform and the upper bounds $U_1 \commadots U_n$ and that yield results of type $T$. No explicit lower bound implies \code{Nothing} to be the corresponding lower bound, no explicit upper bound implies \code{Object} to be the corresponding upper bound. As usual, lower bound must conform to the corresponding upper bound. 

\example The declarations
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
def empty[@\$@A]: List[@\$@A]
def union[@\$@A <: Comparable[@\$@A]] (x : Set[@\$@A], 
         xs : Set[@\$@A]): Set[@\$@A]
\end{lstlisting}
produce the typings
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
empty : [@\$@A >: Nothing <: Object] () $\mapsto$ List[@\$@A]
union : [@\$@A >: Nothing <: Comparable[@\$@A]] (Set[@\$@A], 
        Set[@\$@A]) $\mapsto$ Set[@\$@A]
\end{lstlisting}






\subsection{Type Constructors}
\label{sec:type-constructors}

A type constructor is in turn represented internally much like a polymorphic method type. \lstinline@[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto T$@ represents a type that is expected by a type constructor parameter. The difference is that the represented internal entity is not a method, but a type, creating higher-kinded types. 






\section{Relations Between Types}

We define two relations between types. 
\begin{quote}\begin{tabular}{l@{\gap}l@{\gap}l}
\em Type equivalence & $T \equiv U$ & $T$ and $U$ are interchangeable
in all contexts.
\\
\em Conformance & $T \conforms U$ & Type $T$ conforms to type $U$.
\end{tabular}\end{quote}






\subsection{Type Equivalence}

Equivalence ($\equiv$) between types is the smallest congruence, such that the following statements are true:

\begin{itemize}
\item
If $t$ is defined by a type alias \lstinline@type t is T@, then $t$ is equivalent to $T$. 

\item
If a path $p$ has a singleton type \lstinline@$q$#singleton-type@, then \lstinline@$p$#singleton-type $\equiv$ $q$#singleton-type@. 

\item
Two compound types (\sref{sec:compound-types}) are equivalent, if the sequences of their components are pairwise equivalent, occur in the same order and their refinements are equivalent.

\item 
Two refinements (\sref{sec:compound-types} \& TBD: named refinements) are equivalent, if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements. Two equivalent refinements, both or one attached to a compound type, do not imply the compound types to be equivalent. This applies to both anonymous and named refinements. 

\item
Two method types (\sref{sec:method-types}) are equivalent, if they have equivalent return types, both have the same number of parameters and corresponding parameters have equivalent types and extra properties. Names of parameters matter for method type equivalence only with named parameters. 

\item
Two polymorphic method types (\sref{sec:polymorphic-method-types}) are equivalent, if they have the same number of type parameters, the return types are equivalent as well as lower and upper bounds of corresponding type parameters. 

\item
Two existential types (\sref{sec:existential-types}) are equivalent, if they have the same number of quantifiers and the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent. 

\item
Two type constructors (\sref{sec:type-constructors}) are equivalent, if they have the same number of type parameters, the return types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\end{itemize}






\subsection{Conformance}
\label{sec:conformance}

The conformance relation $(\conforms)$ is the smallest transitive relation that satisfies the following conditions:

\begin{itemize}

\item
Conformance includes equivalence, therefore if $T \equiv U$, then \lstinline@$T \conforms U$@. 

\item
For every value type $T$, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
For every type constructor $T$ with any number of type parameters, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
A type variable $t$ conforms to its upper bound and its lower bound conforms to $t$. 

\item
A class type or a parameterized type conforms to any of its base types. 

\end{itemize}






\subsection{Weak Conformance}

For now, {\em weak conformance} is a relation defined on members of the \code{Number} type as a relaxation of conformance. The relation is simple: a type $t$ weakly conforms to another type $u$ when $u$'s size contains all values of $t$ (we say that $t$ can be converted to $u$ without precision loss). 

