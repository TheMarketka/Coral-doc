%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Types}

\syntax\begin{lstlisting}
Type                ::= Function_Type
                      | Infix_Type [Existential_Clauses]
Function_Type       ::= Function_Args {'->' Function_Args} 
                        '->' Type
Function_Args       ::= Infix_Type
                      | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg        ::= [Param_Io] ['*' | '**' | '&' | ['^'] id ':'] 
                        Param_Type
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
                      | 'var' Var_Dcl
Compound_Type       ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                        ['with' ['refinement'] Refine_Stats]
                      | ['refinement'] Refine_Stats
Infix_Type          ::= Compound_Type {op_id [nl] Compound_Type}
Annot_Type          ::= {Annotation} Simple_Type
Simple_Type         ::= Simple_Type [Type_Args]
                      | Simple_Type '#' id
                      | Stable_Id
                      | Path '.' 'type'
                      | '(' Types ')'
Types               ::= Type {',' Type}
\end{lstlisting}

When we say \textit{type} in the context of Coral, we are talking about a blueprint of an entity, while the type itself is an entity. Every type in Coral is backed by a \textit{class}, which is an instance of the type \lstinline@Class@. 

We distinguish a few different properties of types in Coral. There are first-order types and type constructors, which take type parameters and yield new types. A subset of first-order types called \textit{value types} represents set of first-class values. Value types are either \textit{concrete} or \textit{abstract}. 

Concrete value types can be either a \textit{class type} (e.g. referenced with a type designator, referencing a class or maybe a trait), or a \textit{compound type} representing an intersection of types, possibly with a refinement that further constrains the types of its members. Both class types and compound types may be bound to a constant, but only class types referencing a concrete class can be blueprints of values -- \textit{objects}. Compound types can only constrain bindings to a subset of other types. 

Non-value types capture properties of identifiers that are not values. For instance, a type constructor does not directly specify a type of values, but a type constructor, when applied to the correct type arguments, yields a first-order type, which may be a value type. Non-value types are expressed indirectly in Coral. In example, a method type is described by writing down a method signature, which is not a real type itself, but it creates a corresponding method type. 






\section{About Coral's Type System}

There are two main streams of typing systems out there -- statically typed and dynamically typed. Static typing in a language usually means that the language is compiled into an executable with a definite set of types and every operation is type checked. Dynamic typing means that these checks are deferred until needed, in runtime. 

Let's talk about Java. Java uses static typing -- but, in a very limited and unfriendly way, you may use class loaders and a lot of type casts to dynamically load a new class. And then possibly endure a lot of pain using it. 

Let's talk about Ruby. Ruby uses dynamic typing -- but, using types blindly can possibly lead to some confusion. Ruby is amazing though, because you can write programs with it really fast and enjoy the process at the same time. But when it comes to type safety, you need to be careful. 

And now, move on to Coral. Coral uses hybrid typing. In its core, it uses static typing in most cases. But, it allows to opt-in for some dynamic typing. Unlike in Ruby, you can overload methods (not just override!). You can constrain variables, constants, properties, arguments and return types to particular types. But you don't have to. Types in Coral were heavily inspired by Scala's type system, but modified for this dynamic environment that Coral provides. Unlike in Ruby, you can have pure interfaces (called protocols\footnote{Interfaces in Coral are used to extract the {\em public interface} of classes in modules, so that only a small amount of code may be distributed along with the module to allow binding to it.}), or interfaces with default method implementations (similar to Java 8). Unlike in Java, you can have traits, union types and much more. Unlike in Java, you may easily modify classes, even from other modules ({\em pimp my library!} and {\em open-class principle}). You may even easily add more classes if needed, and possibly shadow existing ones. In face of static typing in Coral, \textit{no type} specified or inferred is saying that the value is of the special type \code{Any}, which represents any type. 

While Coral is so dynamic, it also needs to maintain stability and performance. Therefore, it ``caches'' its bindings and tracks versions of each type\footnote{Versions are simply integers that are incremented with each significant change to the type and distributed among its subtypes.}. If a {\em cached binding} would change, it is ok -- as long as the new binding would conform to the old one. Practically, the code that executes first initiates the binding -- first to come, first to bind. Bindings are also cached, so that the Coral interpreter does not need to traverse types all the time -- it only does so if the needed binding does not exist (initial state with dynamic typing), or if the cached version does not match the actual version of the bound type. This mechanism is also used for caching methods, not only types.

Types in Coral are represented by objects that are members of the \code{Type} type. Instances of value types are represented by objects that are members of the \code{Class} type. 






\section{Paths}
\label{sec:type-paths}

\syntax\begin{lstlisting}
path_id          ::= id [Type_Args]
Path             ::= Stable_Id
                   | [path_id '.'] ('this' | 'self')
                   | 'self' '[' 'cloned' ']'
                   | Container_Path
Stable_Id        ::= path_id
                   | Path '.' path_id
                   | [path_id '.'] 'super' [Class_Qualifier] 
                     '.' path_id
Class_Qualifier  ::= '[' Container_Path ']'
\end{lstlisting}

Paths are not types themselves, but they can be a part of named types and in that function form a role in Coral's type system. 

A path is one of the following:

\begin{itemize}
\item 
The empty path $\epsilon$ (which can not be written explicitly in user programs). 

\item 
\code{this}, which references the directly enclosing class. 

\item 
\lstinline@$C$.self@, where $C$ references a class or a trait. The path \code{self} is taken as a shorthand for \lstinline@$C$.self@, where $C$ is the name of the class directly enclosing the reference. 

\item
\lstinline@self[cloned]@, which references the directly enclosing class of a clone (a cloned instance, see \sref{sec:clone-def}). 

\item 
\lstinline@$p$.$x$@, where $p$ is a path and $x$ is a member of $p$. Additionally, $p$ allows modules to appear instead of references to classes or traits, but no module reference can follow a class or a trait reference: \lstinline@{module_ref '.'} {(class_ref|trait_ref) '.'} $\ldots$@. 

\item
\lstinline@$C$.super.$x$@ or \lstinline@$C$.super[$M$].$x$@, where $C$ references a class or a trait and $x$ references a member of the superclass or designated parent class $M$ of $C$. The prefix \code{super} is taken as a shorthand for \lstinline@$C$#super@, where $C$ is the name of the class directly enclosing the reference, and \lstinline@super[$M$]@ as a shorthand for \lstinline@$C$.super[$M$]@, where $C$ is yet again the name of the class directly enclosing the reference. 
\end{itemize}

Paths introduce also {\em path dependent types}, if the referenced member is a type. 






\section{Value Types}

Every value in Coral has a type which is of one of the following forms. 






\subsection{Singleton Type}
\label{sec:singleton-types}

\syntax\begin{lstlisting}
Simple_Type ::= Path '.' 'type'
\end{lstlisting}

A singleton type is of the form \lstinline@$p$.type@, where $p$ is a path pointing to a value. The type denotes the set of values consisting of \code{nil} and the value denoted by $p$, in spite of nullability.

A {\em stable type} is either a singleton type or a type which is declared to be a subtype of a trait \code{Singleton_Type}. 





\subsection{Type Projection}
\label{sec:type-projection}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type '#' id
\end{lstlisting}

A type projection \lstinline@$T$#$x$@ references type member named $x$ of type $T$. This is useful i.e. with nested classes that belong to the class instances, not the class object. 

% example based on: http://stackoverflow.com/a/9444487/473180
\example A sample code that shows off what type projections are good for:
\begin{lstlisting}
class A {
  class B {}
  def f (b: B): Unit   := Console.print_line "Got my B."
  def g (b: A#B): Unit := Console.print_line "Got a B."
}

val a1 := A.new
val a2 := A.new
a2.f a1.B.new     // type mismatch, found a1.B, required a2.B
a2.g a1.B.new     // prints "Got a B." to stdout
a2.f a2.B.new     // prints "Got my B." to stdout
\end{lstlisting}
This is due to the fact that the \code{class B} is defined as a class instance member of \code{class A}, not as a class object member (either via object definition (\sref{sec:object-definitions}) or some form of metaclass access (\sref{sec:metaclasses})). Therefore, \code{a1.B} refers to type member \code{B} of the instance \code{a1}, but not of \code{a2}. Moreover, \code{A.B} is not defined here. 

% TBD: add example with graphs from http://www.scala-lang.org/old/node/115, as Coral does the same thing






\subsection{Type Designators}
\label{sec:type-designators}

\syntax\begin{lstlisting}
Simple_Type ::= Stable_Id
\end{lstlisting}

A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections. 

Specifically, the unqualified type name $t$ where $t$ is bound in some class $C$ is taken as a shorthand for ~\lstinline@$C$.self.type#$t$@. If $t$ is bound in some object\footnote{Also in class object methods.} or module $C$, it is taken as a shorthand for ~\lstinline@$C$.type#$t$@. If $t$ is not bound in a class, object or module, then $t$ is taken as a shorthand for ~\lstinline@$\epsilon$.type#$t$@. 

A qualified type designator has the form ~\lstinline@$p$.$t$@, where $p$ is a path (\sref{sec:type-paths}) and $t$ is a type name. Such a type designator is equivalent to the type projection ~\lstinline@$p$.type#$t$@. 

\example Some type designators and their expansions are listed below, the type designator being on the left and the expansion on the right of ``\code{=}''. 
\begin{lstlisting}
t = $\epsilon$.type#t // "global space"
Number = Lang~[coral].type#Number // predefined import of Lang~[coral]

object An_Object {
  type t
  t = An_Object.type#t // bound by object
}

class A_Class {
  type t
  def a_method := {
    t = A_Class.self.type#t // bound by class
  }
  class << self
    type u
    u = A_Class.type#u // bound by (class) object
  end
  t = A_Class.self.type#t // bound by class
  self.u = A_Class.type#u // bound by (class) object
}
\end{lstlisting}






\subsection{Parameterized Types}
\label{sec:parameterized-types}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type [Type_Args]
Type_Args   ::= '[' Types ']'
Types       ::= Type_Arg {',' Type_Arg}
Type_Arg    ::= Type | '<' uom_expr '>'
\end{lstlisting}

A parameterized type $T[T_1 \commadots T_n]$ consists of a type designator $T$ and type parameters $T_1 \commadots T_n$, where $n \geq 1$. $T$ must refer to a type constructor which takes exactly $n$ type parameters $a_1 \commadots a_n$. 

Say the type parameters have lower bounds $L_1 \commadots L_n$ and upper bounds $U_1 \commadots U_n$. The parameterized type is well-formed if each actual type parameter {\em conforms to its bounds}, so that $\sigma L_i <: T_i <: \sigma U_i$, where $\sigma$ is the substitution $[a_1 := T_1 \commadots a_n := T_n]$\footnote{The substitution works by replacing occurrences of $a_i$ in the argument by $T_i$, so that, e.g. ~\lstinline[mathescape=false]!$A <: Comparable[$A]!~ is substituted into ~\lstinline!$C$ <: Comparable[$C$]!.}. Also, $U_i$ must never be a subtype of $L_i$, since no other type ever would be able to fulfil the bounds ($U_i$ and $L_i$ may be the exact same type though, but in that case the type parameter would be invariant and the whole point of having a parameterized type would be useless). 

\example
\label{example:parameterized-types}
Given the generic type definitions: 

\begin{lstlisting}
class Tree_Map[A <: Comparable[A], B] $\ldots$ end
class List[A] $\ldots$ end
class I; implements Comparable[I]; $\ldots$ end

class F[M[_], X] $\ldots$ end
class S[K <: String] $\ldots$ end
class G[M[Z <: I], I] $\ldots$ end
\end{lstlisting}

the following parameterized types are well-formed: 

\begin{lstlisting}
Tree_Map[I, String]
List[I]
List[List[Boolean]]

F[List, Number]
G[S, String]
\end{lstlisting}

\example
\label{example:parameterized-types-mal}

Given the type definitions of the previous example, the following types are malformed: 

\begin{lstlisting}
Tree_Map[I]               // wrong number of parameters
Tree_Map[List[I], Number] // type parameter List not within bound

F[Number, Boolean]        // Number is not a type constructor
F[Tree_Map, Number]       // Tree_Map takes two parameters, 
                          //   F expects a type constructor taking one

G[S, Number]              // type S constrains its parameter to
                          //   conform to String, 
                          // G expects type constructor with a parameter
                          //   that conforms to Number
\end{lstlisting}





\subsection{Tuple Types}
\label{sec:tuple-types}

\syntax\begin{lstlisting}
Simple_Type ::= '(' Types ')'
\end{lstlisting}

A tuple type ($T_1 \commadots T_n$) is an alias for the class \lstinline@Tuple_$n$[$T_1 \commadots T_n$]@, where $n \geq 2$. 

Tuple classes are available as patterns for pattern matching. The properties can be accessed as methods \lstinline@[1]$ \commadots $[$n$]@ (using an ``offset'' that is outside of the tuple's size results in a method-not-found error, not offset-out-of-bounds -- tuple classes do not implement the operator \lstinline@[i]@ for arbitrary $i$). 

Tuple classes are generated lazily by the runtime as needed, so that the language does not constrain users to tuples of only limited sizes, but allows any size. 

An effort will be made to introduce a simple enough syntax for variable parameterized types, if possible, until then, \lstinline@Tuple_$i$@ are the only such types. 






\subsection{Annotated Types}

\syntax\begin{lstlisting}
Annot_Type ::= {Annotation} Simple_Type
\end{lstlisting}

An annotated type $a_1 \ldots a_n T$ attaches annotations $a_1 \commadots a_n$ to the type $T$. % TBD: add ref to a chapter about annotations.






\subsection{Compound Types}
\label{sec:compound-types}

\syntax\begin{lstlisting}
Compound_Type ::= Annot_Type {['prepend'] 'with' Annot_Type} 
                  ['with' ['refinement'] Refine_Stats]
                | ['refinement'] Refine_Stats
Refine_Stats  ::= '{' [Refine_Stat {semi Refine_Stat}] '}'
Refine_Stat   ::= Dcl
                | 'type' Type_Def
\end{lstlisting} % TBD: define Refine_Stat syntax

A compound type \lstinline@$T_1$ with $\ldots$ with $T_n$ with refinement {$R$}@ represents values with members as given in the component types $T_1 \commadots T_n$ and the refinement \lstinline@{$R$}@. A refinement \lstinline@{$R$}@ contains declarations and definitions (\sref{sec:refinements}). 

If no refinement is given, the type is implicitly equivalent to the same type having an empty refinement. 

A compound type may also consist of just a refinement \lstinline@{$R$}@ with no preceding component types -- such a type has an implicit component type \code{Object} and describes the member values as ``any value, as long as it has what the refinement requires'', thus it works like an anonymous protocol. 

If a compound type does not contain a concrete class type, then \code{Object} is implied in case the type is used as a concrete class\footnote{Meaning that the compound type is used as an ad-hoc (possibly anonymous) class, e.g. to create new instances of it.}.

The keyword \code{refinement} instructs that the following tokens will be a part of a refinement, and the construct ~\lstinline!refinement {$R$}!~ is called an {\em anonymous refinement}, being equivalent to ~\lstinline!Object with refinement {$R$}!, although when the refinement is a part of a compound type with more elements than just the refinement itself, the \code{Object} type is replaced with the class type appearing in the compound type, if any. 

The \code{refinement} keyword can be omitted from a compound type that consists of more elements than just the refinement. Constructs ~\lstinline!Object with {$R$}!~ and ~\lstinline!refinement {$R$}!~ are then equal. 

The \code{refinement} keyword may also be omitted from a compound type that consists of just the refinement, but only in contexts in which a type is expected, i.e.: parameter type declaration, value or variable type declaration, return type declaration, type argument application or type parameter declaration; but never stand-alone. If used as such, the constructs ~\lstinline!refinement {$R$}!~ and ~\lstinline!{$R$}!~ are then equal. 






\subsection{Infix Types}
\label{sec:infix-types}

\syntax\begin{lstlisting}
Infix_Type ::= Compound_Type {op_id [nl] Compound_Type}
\end{lstlisting}

An infix type $T_1\ \op\ T_2$ consists of an infix operator $\op$, which gets applied to two type operands $T_1$ and $T_2$. The type is equivalent to the type application ~\lstinline!$\op$[$T_1$, $T_2$]!. The infix operator $\op$ may be an arbitrary identifier, and is expected to represent a type constructor. 

Infix type may also result from an infix expression (\sref{sec:prefix-infix-ops}), if such operator name is not found on the result type of the expression that it is applied to. In any case, precedence and associativity rules of operators apply here as well. 






\subsection{Function Types}
\label{sec:function-types}

\syntax\begin{lstlisting}
Type          ::= Function_Args {'->' Function_Args}
                  '->' Type
Function_Args ::= Infix_Type
                | '(' [Function_Arg {',' Function_Arg}] ')'
Function_Arg  ::= [Param_Io] ['*' | '**' | '&' | ['^'] id ':']
                  Param_Type
\end{lstlisting}

The type \lstinline@($T_1 \commadots T_n$) -> $R$@ represents the set of function values that take arguments of types $T_1 \commadots T_n$ and yield results of type $R$. In the case of exactly one argument, type \lstinline@$T$ -> $R$@ is a shorthand for \lstinline@($T$) -> $R$@. 

Function argument types may be annotated with some extra properties. In that case, these map to annotations of their types, defined as follows:
\begin{itemize}
\item ``\code{out}'' maps to \code{@[out_param]}. 
\item ``\code{in}'' maps to no annotation, as it is implied, and if the parameter is \code{out}-only, the function is still applicable. 
\item ``\code{*}'' maps to \code{@[repeated_param]}. 
\item ``\code{**}'' maps to \code{@[capturing_named_param]}. 
\item ``\code{&}'' maps to \code{@[captured_block_param]}. 
\item ``\code{^$\id$}'' maps to \code{@[named_param :$\id$]}. For now, the leading ``\code{^}'' may be omitted, as it could be implied, but it's generally better to not omit it. 
\end{itemize}

Function types associate to the right, e.g. \lstinline@($S$) -> ($T$) -> $R$@ is the same as \lstinline@($S$) -> (($T$) -> $R$)@. 

Function types are shorthands for class types that conform to the \lstinline@Function_$i$@ protocol -- i.e. having an \code{apply} function or simply {\em being} a function. The $n$-ary function type \lstinline@($T_1 \commadots T_n$) -> $R$@ is a shorthand for the protocol \lstinline@Function_$n$[$T_1 \commadots T_n,R$]@. Such protocols are defined in the Coral library for any $n \ge 0$:

\begin{lstlisting}
protocol Function_$n$[-$T_1 \commadots\,$-$T_n$, +$R$]
  message apply ($x_1$: $T_1 \commadots x_n$: $T_n$): $R$
  $\ldots$
end protocol
\end{lstlisting}

Function types are covariant in their result type and contravariant in their argument types (\sref{sec:variance-of-type-parameters}).

A function that returns ``nothing'' may be declared as returning the type \code{Unit}, which is similar to \lstinline[language=C]!void! in C-related languages. Such a type is then written as ~\lstinline!($S$) -> Unit!. 

Function arguments may be optionally annotated with more requirements: 
\begin{itemize}
\item
Parameter prefixed with \code{Param_Io} defines whether the parameter is required to be an output parameter. 

\item
Parameter prefixed with ``\lstinline!*!'' is a requirement of a repeated parameter. 

\item 
Parameter prefixed with ``\lstinline!^!'' is a requirement of a parameter named $x$.

\item 
Parameter prefixed with ``\lstinline!**!'' is a requirement of a captured named parameters. 

\item
Parameter prefixed with ``\lstinline!&!'' is a requirement for the passed block. It does not tell whether the function must capture the passed block, it only restricts the requirements for the particular block, if any. The actual passed block may have more or even less positional or named parameters (extra ones on the block side are given \code{nil}, unless the type is not nullable (\sref{sec:nullability}) -- that is an error; and extra ones on the type side are simply discared), but the return type of the passed block must conform (\sref{sec:conformance}).
\end{itemize}

\paragraph{Note}
Although the function type alone allows to attach the extra annotations to types of arguments in a \code{1:1} manner (and therefore types of parameters), due to how conformance is defined for function types, it is not always desirable to use them. The only argument extra that might be of any use is the captured block argument, so that a requirement of a passed block is marked (not caring about the actual style of the block passing). 

\example The following definition of functions \code{g} and \code{h} conform to a definition of a function \code{f}, and there are many more such functions that conform to \code{f}. And vice versa, \code{f} conforms to both \code{g} and \code{h}, although the latter two are more specific than the first one (\sref{sec:overloading-resolution}). 
\begin{lstlisting}
def f (*x: Integer) end
def g (x: Integer, y: Integer) end
def h (x: Integer, y: Integer, z: Integer) end
\end{lstlisting}






\subsection{Existential Types}
\label{sec:existential-types}

\syntax\begin{lstlisting}[escapechar=@]
Type                ::= Infix_Type Existential_Clauses
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
                      | 'val' Val_Dcl
\end{lstlisting}

An existential type has the form ~\lstinline@$T$ for-some { $Q$ }@, where $Q$ is a sequence of type declarations (\sref{sec:type-decls-aliases}). Let ~\lstinline@$t_1$[$\tps_1$] >: $L_1$ <: $U_1\ \commadots\ t_n$[$\tps_n$] >: $L_n$ <: $U_n$@~ be the types declared in $Q$ (any of the type parameter sections ~\lstinline![$\tps_i$]!~ might be missing). The scope of each type $t_i$ includes the type $T$ and the existential clause $Q$. The type variables $t_i$ (occurring in the sequence $Q$) are said to be {\em bound} in the type ~\lstinline!$T$ for-some { $Q$ }!. Type variables that occur in a type $T$, but which are not bound in $T$, are said to be {\em free} in $T$. 

A {\em type instance} of ~\lstinline@$T$ for-some { $Q$ }@~ is a type $\sigma T$, where $\sigma$ is a substitution over $t_1 \commadots t_n$, such that for each $i$, $\sigma L_i \conforms \sigma t_i \conforms \sigma U_i$. The set of values denoted by the existential type \lstinline@$T$ for-some { $Q$ }@ is the union of the set of values of all its type instances. In other words, a type instance of an existential type is a type application (\sref{sec:type-applications}) of the type ~\lstinline@$T$ for-some { $Q$ }@, where the applied type arguments conform to the bounds, or are free in ~\lstinline@$T$ for-some { $Q$ }@. 

A {\em skolemization} of ~\lstinline@$T$ for-some { $Q$ }@~ is a type instance $\sigma T$, where $\sigma$ is the substitution $[t_1 := t'_1 \commadots t_n := t'_n]$ and each $t'_i$ is a fresh abstract virtual type with lower bound $\sigma L_i$ and upper bound $\sigma U_i$\footnote{This virtual type $t'_i$ denotes the set of all types, for which $\sigma L_i \conforms \sigma t'_i \conforms \sigma U_i$.}. Such type instance is inaccessible to user programs, but is essential to type equality and conformance checks, as it describes the set of values denoted by the existential type without an actual existential type, but with a universal type. 



\paragraph{Simplification rules}
Existential types obey the following equivalences:
\begin{enumerate}
\item
Multiple \code{for-some} clauses in an existential type can be merged. E.g., ~\lstinline@$T$ for-some { $Q$ } for-some { $Q'$ }@~ is equivalent to ~\lstinline@$T$ for-some { $Q$; $Q'$ }@. 

\item
Unused quantifications can be dropped. E.g., ~\lstinline@$T$ for-some { $Q$; $Q'$ }@, where none of the types defined in $Q'$ are referred to by $T$ or $Q$, is equivalent to ~\lstinline@$T$ for-some { $Q$ }@. 

\item
An empty quantification can be dropped. E.g., ~\lstinline@$T$ for-some { }@~ is equivalent to $T$. 

\item
An existential type ~\lstinline@$T$ for-some { $Q$ }@, where $Q$ contains a clause ~\lstinline!type $t$[$\tps$] >: $L$ <: $U$!~ is equivalent to the type ~\lstinline@$T'$ for-some { $Q$ }@, where $T'$ results from $T$ by replacing every covariant occurrence (\sref{sec:variance-of-type-parameters}) of $t$ in $T$ by $U$ and by replacing every contravariant occurrence of $t$ in $T$ by $L$. 
\end{enumerate}



\paragraph{Existential quantification over values}
As a syntactic convenience, the bindings clause in an existential type may also contain value declarations ~\lstinline!val $x$: $T$!. An existential type ~\lstinline@$T$ for-some { $Q$; val $x$: $S$; $Q'$ }@~ is treated as a shorthand for the type ~\lstinline@$T'$ for-some { $Q$; type $t$ <: $S$ with Singleton_Type; $Q'$ }@, where $t$ is a fresh type name and $T'$ results from $T$ by replacing every occurrence of ~\lstinline!$x$.type!~ with $t$. 



\paragraph{Placeholder syntax for existential types}
Coral supports a placeholder syntax for existential types. A {\em wildcard type} is of the form ~\lstinline!_ >: $L$ <: $U$!. Both bound clauses may be omitted. If a lower bound clause ~\lstinline!_ >: $L$!~ is omitted, ~\lstinline!_ >: Nothing!~ is assumed. If an upper bound clause ~\lstinline!_ <: $U$!~ is omitted, ~\lstinline!_ >: Object!~ is assumed. A wildcard type is a shorthand for an existentially quantified type variable, where the existential quantification is implicit. 

A wildcard type must appear as a type argument of a parameterized type. Let ~\lstinline!$T$ := $p$.$c$[$\targs$, $T$, $\targs'$]!~ be a parameterized type, where $\targs$, $\targs'$ may be empty and $T$ is a wildcard type ~\lstinline!_ >: $L$ <: $U$!. Then $T$ is equivalent to the existential type
\begin{lstlisting}
$p$.$c$[$\targs$, $t$, $\targs'$] for-some { type $t$ >: $L$ <: $U$ }
\end{lstlisting}
where $t$ is a fresh type variable. Wildcard types may also appear as parts of compound types (\sref{sec:compound-types}), function types (\sref{sec:function-types}) or tuple types (\sref{sec:tuple-types}). Their expansion is then the expansion in the equivalent parameterized type. 

\example Assume the class definitions
\begin{lstlisting}[mathescape=false]
class Ref[$T] {}
abstract class Outer { type T }
\end{lstlisting}
Here are some examples of existential types:
\begin{lstlisting}[mathescape=false]
Ref[$T] for-some { type $T <: Number }
Ref[x.T] for-some { val x: Outer }
Ref[x_type#T] for-some { type x_type <: Outer with Singleton_Type }
\end{lstlisting}
The last two types in this list are equivalent. An alternative formulation of the first type above using wildcard syntax is:
\begin{lstlisting}
Ref[_ <: Number]
\end{lstlisting}
which is equivalent to Java's
\begin{lstlisting}[language=Java]
Ref<? super Number>
\end{lstlisting}
\lstinline!Ref[_ <: Number]!~ then represents any type constructed by the type\code{Ref} parameterized with a type that is \code{Number} or any type that conforms to \code{Number}. 
\lstinline!Ref[_ >: Number]!~ would then represents any type constructed by the type \code{Ref} parameterized with a type that is \code{Number} or any type that \code{Number} conforms to. 

\example The type ~\lstinline!List[List[_]]!~ is equivalent to the existential type
\begin{lstlisting}[mathescape=false]
List[List[$T] for-some { type $T }]  .
\end{lstlisting}

\example Assume a covariant type
\begin{lstlisting}[mathescape=false]
class List[+$T] {}
\end{lstlisting}
The type 
\begin{lstlisting}[mathescape=false]
List[$T] for-some { type $T <: Number }
\end{lstlisting}
is equivalent (by simplification rule 4 above\footnote{As ~\lstinline[mathescape=false]!$T!~ appears in covariant position in \code{List}, its upper bound can replace the type variable in \code{List}.}) to
\begin{lstlisting}[mathescape=false]
List[Number] for-some { type $T <: Number }
\end{lstlisting}
which is in turn equivalent (by simplification rules 2 and 3 above\footnote{The type variable ~\lstinline[mathescape=false]!$T!~ is unused, and after dropping it, the quantification is empty.}) to
\begin{lstlisting}[mathescape=false]
List[Number]  .
\end{lstlisting}
Since this \code{List} type is covariant in its type parameter, then e.g. ~\lstinline!List[Integer]!~ is still a subtype of ~\lstinline!List[Number]!. 





\subsection{Nullable Types}
\label{sec:nullable-types}

\syntax\begin{lstlisting}
Nullable_Type ::= Type [Nullable_Mod]
Nullable_Mod  ::= '?' | '!'
\end{lstlisting}

A nullable type has the form \lstinline!$T$?! or \lstinline@$T$!@, where ``\code{?}'' denotes explicitly a nullable type, and ``\code{!}'' denotes explicitly not-nullable type. Although \code{nil} as the singleton member of the \code{Nothing} type is a subtype of every type, Coral types are implicitly not-nullable, meaning it's not possible to pass \code{nil} where an instance of $T$ is expected, unless $T$ is of course \code{Nothing}. Nullability (\sref{sec:nullability}) is one of the intrinsic properties of every class type. 

Explicitly nullable types are handled by an intrinsic anonymous subtype of $T$, which is explicitly nullable, overriding the preference of $T$. Explicitly not-nullable types are handled by an intrinsic anonymous subtype of $T$, which is explicitly not-nullable, overriding the preference of $T$. Explicit nullability of already nullable types is redundant, as is explicit non-nullability of already not-nullable types. Explicit nullability of the \code{Option} type is also redundant and is in fact ignored. 

Nullable types in this form can appear as types of variables, parameters and return types. 






\subsection{Unions}
\label{sec:unions}

\syntax\begin{lstlisting}
Const_Type_Def ::= id 'is' 'union' 'of'
                   '(' Type {semi Type} ')'
\end{lstlisting}

Union types represent multiple types, possibly unrelated. Union types are abstract by nature and can not be instantiated, only the types that they contain may, if these are instantiable. For type safety, bindings of union types should be matched for the actual type prior to usage. 

Unions are indeed virtually ``tagged'' with the actual type that they represent at the runtime moment, although when it comes to overloading resolution, the union type is used, as it is the expected type. 







\section{Non-Value Types}

The types explained in the following paragraphs do not appear explicitly in programs, they are internal and do not represent any type of value directly. 






\subsection{Method Types}
\label{sec:method-types}

A method type is denoted internally as $(Ps) \mapsto R$, where $(Ps)$ is a sequence of types  $(p_1 : T_1 \commadots p_n : T_n)$ for some $n \geq 0$ and $R$ is a (value or method) type. This type represents named or anonymous methods that take arguments of types $T_1 \commadots T_n$ and return a result of type $R$. Types of parameters are possibly annotated with conformance restricting annotations (\sref{sec:annotations}). 

Method types associate to the right:\footnote{Like in Haskell or Scala.} \newline
$(Ps_1) \mapsto (Ps_2) \mapsto R$ is treated as $(Ps_1) \mapsto ((Ps_2) \mapsto R)$. 

A special case are types of methods without any parameters. They are written here as $() \mapsto R$. 

Another special case are types of methods without any return type. They are written here as $(Ps) \mapsto ()$. Methods that have this return type do not have an implicit return expressions and an attempt to return a value from it results in a compile-time error.\footnote{A compile-time error like this may happen during a runtime evaluation as well.}

Method types do not exist as types of values. If a method name is used as a value, its type is implicitly converted to a corresponding function type (\sref{sec:function-types}). 

Extra properties of parameters are as follows: a \lstinline@*@ for variable arguments, \lstinline@**@ for any named arguments and \lstinline@&@ for a captured block argument, or nothing for regular parameters. 

\example The declarations
\begin{lstlisting}
def a: -> Integer // or def a () -> Integer
def b (x : Integer): Boolean
def c (x : Integer): (y : String, z : String) -> String
def d (^x : Integer): Integer
def e (*x : Integer): Integer
def f (x: Integer): Unit
def g (x: Integer)(y: Integer): Integer
def h (x: Integer): (y: Integer) -> Integer
\end{lstlisting}
produce the typings
\begin{lstlisting}
a : () $\mapsto$ Integer
b : (Integer) $\mapsto$ Boolean
c : (Integer) $\mapsto$ (y: String, z: String) $\mapsto$ String
d : (@[named_param :x] Integer) $\mapsto$ Integer
e : (@[repeated_param :x] Integer) $\mapsto$ Integer
f : (Integer) $\mapsto$ Unit
g : (Integer) $\mapsto$ (Integer) $\mapsto$ Integer
g : (Integer) $\mapsto$ (Integer) $\mapsto$ Integer
\end{lstlisting}

The difference between the ``\code{g}'' and ``\code{h}'' functions is that using the chain of return types as in function ``\code{g}'', the function body is automatically curried to return a function that is of type \lstinline@(Integer) $\mapsto$ Integer@. With the function ``\code{h}'', currying has to be implemented manually. 






\subsection{Polymorphic Method Types}
\label{sec:polymorphic-method-types}

A polymorphic method type is the same as a regular method type, but enhanced with a type parameters section. It is denoted internally as \lstinline@[$\tps$]$ \mapsto T$@, where \lstinline@[$\tps$]@ is a type parameter section ~\lstinline@[$\pm a_1$ >: $L_1$ <: $U_1$ $\commadots$ $\pm a_n$ >: $L_n$ <: $U_n$]@ for some $n \geq 0$ and $T$ is a (value or method) type. This type represents (only\footnote{Not anonymous.}) named methods that take type arguments $S_1 \commadots S_n$, for which the lower bounds $L_1 \commadots L_n$ conform (\sref{sec:conformance}) to the type arguments and the type arguments conform and the upper bounds $U_1 \commadots U_n$ and that yield results of type $T$. No explicit lower bound implies \code{Nothing} to be the corresponding lower bound, no explicit upper bound implies \code{Object} to be the corresponding upper bound. As usual, lower bound must conform to the corresponding upper bound. 

\example The declarations
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
def empty[A]: List[A]
def union[A <: Comparable[A]] (x : Set[A], 
         xs : Set[A]): Set[A]
\end{lstlisting}
produce the typings
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
empty : [A >: Nothing <: Object] () $\mapsto$ List[A]
union : [A >: Nothing <: Comparable[A]] (Set[A], 
        Set[A]) $\mapsto$ Set[A]
\end{lstlisting}






\subsection{Type Constructors}
\label{sec:type-constructors}

A type constructor is in turn represented internally much like a polymorphic method type. \lstinline@[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto T$@ represents a type that is expected by a type constructor parameter. The difference is that the represented internal entity is not a method, but a type, creating higher-kinded types. 






\section{Base Types \& Member Definitions}
\label{sec:base-types}
\label{sec:member-definitions}

Types of class members depend on the way the members are referenced. Central here are these notions:
\begin{enumerate}
\item The notion of the set of base types of a type $T$.
\item The notion of a type $T$ in some class $C$ seen from some prefix type $S$.
\item The notion of the set of member bindings of some type $T$. 
\end{enumerate}

These notions are defined mutually recursively as follows. 

\begin{enumerate}

\item
The set of {\em base types} of a type is a set of class types, given as follows.
\begin{itemize}
\item The base types of a class type $C$ with parents $T_1 \commadots T_n$ are $C$ itself, as well as the base types of the compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$!. 

\item The base types of an aliased type are the base types of its alias. 

\item The base types of an abstract type\footnote{E.g. type members.} are the base types of its upper bound. 

\item The base types of a parameterized type ~\lstinline!$C$[$T_1 \commadots T_n$]!~ are the base types of type $C$, where every occurence of a type parameter $a_i$ of $C$ has been replaced by the corresponding parameter type $T_i$. 

\item The base types of a compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$ with { $R$ }!~ are set of base classes of all $T_i$'s. 

\item The base types of a type projection ~\lstinline!$S$#$T$!~ are determined as follows: If $T$ is an alias or an abstract type, the previous clauses apply. Otherwise, $T$ must be a (possibly parameterized) class type, which is defined in some class $B$. Then the base types of ~\lstinline!$S$#$T$!~ are the base types of $T$ in $B$ as seen from the prefix type $S$. 

\item The base types of an existential type ~\lstinline!$T$ for-some { $Q$ }!~ are all types ~\lstinline!$S$ for-some { $Q$ }!, where $S$ is a base type of $T$. 
\end{itemize}

\item
The notion of a type {\em $T$ in class $C$ seen from some prefix type $S$} makes sense only if the prefix type $S$ has a type instance of class $C$ as a base type, say ~\lstinline!$S'$#$C$[$T_1 \commadots T_n$]!. Then we define it as follows.
\begin{itemize}
\item If ~\lstinline!$S$ = $\epsilon$.type!, then $T$ in $C$ seen from $S$ is $T$ itself. 

\item Otherwise, if $S$ is an existential type ~\lstinline!$S'$ for-some { $Q$ }!, and $T$ in $C$ seen from $S'$ is $T'$, then $T$ in $C$ seen from $S$ is ~\lstinline!$T'$ for-some { $Q$ }!. 

\item Otherwise, if $T$ is the $i^{\superth}$ type parameter of some class $D$, then:
\begin{itemize}
\item If $S$ has a base type ~\lstinline!$D$[$U_1 \commadots U_n$]!, for some type parameters $U_1 \commadots U_n$, then $T$ in $C$ seen from $S$ is $U_i$. 
\item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
\item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
\end{itemize}

\item Otherwise, if $T$ is the singleton type ~\lstinline!$D$.self.type!~ for some class $D$, then:
\begin{itemize}
\item If $D$ is a subclass of $C$ and $S$ has a type instance of class $D$ among its base types, then $T$ in $C$ seen from $S$ is $S$. 
\item Otherwise, if $C$ is defined in a class $C'$, then $T$ in $C$ seen from $S$ is the same as $T$ in $C'$ seen from $S'$. 
\item Otherwise, if $C$ is not defined in another class, then $T$ in $C$ seen from $S$ is $T$ itself. 
\end{itemize}

\item
If $T$ is some other type, then the described mapping is performed on all its type components. 

\end{itemize}

If $T$ is a possibly parameterized class type, where $T$'s class is defined in some other class $D$, and $S$ is some prefix type, then we use ``$T$ seen from $S$'' as a shorthand for ``$T$ in $D$ seen from $S$''. 

\item
The {\em member bindings} of a type $T$ are:
\begin{enumerate}
\item All bindings $d$, such that there exists a type instance of some class $C$ among the base types of $T$ and there exists a definition or declaration of $d'$ in $C$, such that $d$ results from $d'$ by replacing every type $T'$ in $d'$ with $T'$ in $C$ seen from $T$.
\item All bindings of the type's refinement (\sref{sec:compound-types}), if it has one. 
\end{enumerate}

The definition of a type projection ~\lstinline!$S$#$t$!~ is the member binding $d_t$ of the type $t$ in $S$. In that case, we also say that {\em ~\lstinline!$S$#$t$!~ is defined by $d_t$}. 

\end{enumerate}







\section{Any-Value Type}
\label{sec:any-value-type}

\syntax\begin{lstlisting}
Simple_Type ::= 'Any'
\end{lstlisting}

This type does not represent a single concrete value type, but any concrete type. It is used in places where dynamic typing is desired. 

With respect to overloading resolution (\sref{sec:value-conversions}), this type is always the least specific. 







\section{Relations Between Types}

We define two relations between types. 
\begin{quote}\begin{tabular}{l@{\gap}l@{\gap}l}
\em Type equivalence & $T \equiv U$ & $T$ and $U$ are interchangeable
in all contexts.
\\
\em Conformance & $T \conforms U$ & Type $T$ conforms to type $U$.
\end{tabular}\end{quote}






\subsection{Type Equivalence}

Equivalence ($\equiv$) between types is the smallest congruence, such that the following statements are true:

\begin{itemize}
\item
If $t$ is defined by a type alias ~\lstinline@type t := T@, then $t$ is equivalent to $T$. 

\item
If a path $p$ has a singleton type ~\lstinline@$q$.type@, then \lstinline@$p$.type $\equiv\ q$.type@. 

\item
Two compound types (\sref{sec:compound-types}) are equivalent, if the sequences of their components are pairwise equivalent, occur in the same order and their refinements are equivalent.

\item
Two refinements (\sref{sec:compound-types} \& \sref{sec:refinements}) are equivalent, if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements. 

\item
Two method types (\sref{sec:method-types}) are equivalent, if they are {\em override-equivalent} (\sref{sec:method-signature}).

\item
Two polymorphic method types (\sref{sec:polymorphic-method-types}) are equivalent, if they have the same number of type parameters, the return types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\item
Two existential types (\sref{sec:existential-types}) are equivalent, if they have the same number of quantifiers and the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent. 

\item
Two type constructors (\sref{sec:type-constructors}) are equivalent, if they have the same number of type parameters, the return types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\end{itemize}






\subsection{Conformance}
\label{sec:conformance}

The conformance relation $(\conforms)$ is the smallest transitive relation that satisfies the following conditions:

\begin{itemize}

\item
Conformance includes equivalence, therefore if $T \equiv U$, then \lstinline@$T \conforms U$@. 

\item
For every value type $T$, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
For every type constructor $T$ with any number of type parameters, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
A type variable $t$ conforms to its upper bound and its lower bound conforms to $t$. 

\item
A class type or a parameterized type conforms to any of its base types. 

\item 
A singleton type ~\lstinline!$p$.type!~ conforms to the type of the path $p$.

\item
A type projection ~\lstinline!$T$#$t$!~ conforms to ~\lstinline!$U$#$t$!~ if $T$ conforms to $U$. 

\item
A unit of measure type $t$ conforms to another unit of measure type $u$ if and only if $t \equiv u$ or $t$ extends $u$, where $us$ is an abstract unit of measure type. 

\item 
A parameterized type ~\lstinline!$T$[$T_1 \commadots T_n$]!~ conforms to ~\lstinline!$T$[$U_1 \commadots U_n$]!~ if the following conditions hold for $i = 1 \commadots n$.
\begin{itemize}
\item If the $i^{\superth}$ type parameter of $T$ is declared covariant, then $T_i \conforms U_i$.
\item If the $i^{\superth}$ type parameter of $T$ is declared contravariant, then $U_i \conforms T_i$.
\item If the $i^{\superth}$ type parameter of $T$ is declared invariant (neither covariant nor contravariant), then $U_i \equiv T_i$.
\item If the $i^{\superth}$ type parameter of $T$ is declared with a conformance restricting annotation, then that annotation of $T_i$ must conform to the corresponding annotation of $U_i$. 
\end{itemize}

\item
A unit of type $N$ conforms to unit of type $U$ if $N$ extends $U$ or if $N \equiv U$. 

\item
A parameterized type ~\lstinline!$T$[<$N_1 \commadots N_n$>]!~ conforms to ~\lstinline!$T$[<$U_1 \commadots U_n$>]!~ if the following conditions hold for $i = 1 \commadots n$.
\begin{itemize}
\item For the $i^{\superth}$ type parameter of $T$, $N_i \conforms U_i$.
\end{itemize}

\item 
A compound type ~\lstinline!$T_1$ with $\ldots$ with $T_n$ with { $R$ }!~ conforms to each of its component types $T_i$, and to any compound type created as a combination of subsets of the components, excluding empty sets. 

\item 
If $T \conforms U_i$ for $i = 1 \commadots n$, and every binding $d$ of a type or value $x$ in $R$ exists a member binding of $x$ in $T$ which subsumes $d$, then $T$ conforms to the compound type ~\lstinline!$U_1$ with $\ldots$ with $U_n$ with { $R$ }!. 

\item
The existential type ~\lstinline!$T$ for-some { $Q$ }!~ conforms to $U$, if its skolemization (\sref{sec:existential-types}) conforms to $U$. This also means that the $t'_i$ type variables have to fall in between $U$'s type parameter bounds. 

\item
The type $T$ conforms to the existential type ~\lstinline!$U$ for-some { $Q$ }!~ if $T$ conforms to at least one of the type instances (\sref{sec:existential-types}) of ~\lstinline!$U$ for-some { $Q$ }!. 

\item
If $T_i \equiv T'_i$ for $i = 1 \commadots n$ and $R \conforms R'$, then the method type ~\lstinline!($p_1$: $T_1 \commadots p_n$: $T_n$) $\mapsto\ R$!~ conforms to ~\lstinline!($p'_1$: $T'_1 \commadots p'_n$: $T'_n$) $\mapsto\ R'$!. 

\item
The polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto\ T$
\end{lstlisting}
conforms to the polymorphic type or type constructor 
\begin{lstlisting}
[$\pm a_1$ >: $L'_1$ <: $U'_1 \commadots \pm a_n$ >: $L'_n$ <: $U'_n$] $\mapsto\ T'$
\end{lstlisting}
if one has $T \conforms T'$, and $L_i \conforms L'_i$ and $U_i \conforms U'_i$ for $i = 1 \commadots n$. 

\item
Polymorphic types or type constructors $T$ and $T'$ must also fulfil the following. We characterize $T$ and $T'$ by their type parameter clauses ~\lstinline![$a_1 \commadots a_n$]!~ and ~\lstinline![$a'_1 \commadots a'_n$]!, where an $a_i$ or $a'_i$ may include a variance annotation, annotations, a higher-order type parameter clauses, and bounds. Then, $T$ conforms to $T'$ if any list ~\lstinline![$t_1 \commadots t_n$]!~ -- with declared variances, annotations, bounds and higher-order type parameter clauses -- of valid type arguments for $T'$ is also a valid list of type arguments for $T$ and ~\lstinline!$T$[$t_1 \commadots t_n$] <: $T'$[$t_1 \commadots t_n$]!. Note that this entails that:
\begin{itemize}
\item The bounds on $a_i$ must be the same or weaker than the corresponding bounds declared for $a'_i$. 
\item The variance of $a_i$ must match the variance of $a'_i$, where covariance matches covariance, contravariance matches contravariance and any variance matches invariance. 
\item If annotation of $a'_i$ restricts conformance (\sref{sec:annotations}), then the corresponding annotation of $a_i$ must conform to it. 
\item Recursively, these restrictions apply to the corresponding higher-order type parameter clauses of $a_i$ and $a'_i$. 
\end{itemize}

\item 
A function type ~\lstinline!($T_1 \commadots T_n$) -> $R$!~ (name it $f$) conforms to a function type ~\lstinline!($T'_1 \commadots T'_m$) -> $R'$!~ (name it $f'$), if types of arguments that are applicable to $f'$ are also applicable to $f$ (\sref{sec:function-applications}), and if $R$ conforms to $R'$. This includes reordering of named arguments/parameters and handling of repeated/optional parameters, and also variances -- since although $f$ might be applied to whatever $f'$ might be applied to, $f'$ might not be applied to whatever $f$ might be applied to (and vice versa).

\item
Polymorphic function traits ~\lstinline!Function_$n$!~ and ~\lstinline!Partial_Function!~ follow the rules for conformance of function types, as defined above. The repeated parameter, optional parameters, named parameters and all capturing parameters are derived from their conformance restricting annotations (\sref{sec:annotations}). Note that optional parameters may not be expressed with function types in another than with an annotation. The rules may be inverted in the means of constructing a virtual methods $m$ and $m'$ that are reconstructed from the type arguments of the function types $f$ and $f'$ respectively, and applying the rules for function types on them.
 
\end{itemize}

A declaration or definition in some compound type of class type $C$ {\em subsumes} another declaration of the same name in some compound type or class type $C'$, if one of the following conditions holds. 
\begin{itemize}
\item A value declaration or definition that defines a name $x$ with type $T$ subsumes a value or method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
\item A method declaration or definition that defines a name $x$ with type $T$ subsumes a method declaration that defines $x$ with type $T'$, provided $T \conforms T'$. 
\item A type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] := $T$!~ subsumes a type alias ~\lstinline!type $t$[$T_1 \commadots T_n$] := $T'$!~ if $T \equiv T'$. 
\item A type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!~ subsumes a type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L'$ <: $U'$!, if $L' \conforms L$ and $U \conforms U'$. 
\item A type or class definition that binds a type name $t$ subsumes an abstract type declaration ~\lstinline!type $t$[$T_1 \commadots T_n$] >: $L$ <: $U$!, if $L \conforms t \conforms U$. 
\end{itemize}

The ($\conforms$) relation forms partial order between types, i.e. it is transitive, antisymmetric and reflexive. The terms {\em least upper bound} and {\em greatest lower bound} of a set of types are understood to be relative to that order. 

\paragraph{Note}
The least upper bound or the greatest lower bound of a set of types does not always exist. Coral is free to reject a term which has a type specified as a least upper bound or a greatest lower bound, and that bound would be more complex than a preset limit, e.g. this could happen with infinite bounds sequence. 

The least upper bound or the greatest lower bound might also not be unique. If there are several such bounds, Coral is free to pick up any of them. 





\subsection{Weak Conformance}
\label{sec:weak-conformance}

For now, {\em weak conformance} is a relation defined on members of the \code{Number} type as a relaxation of conformance, written as $S \conforms _w T$. The relation is simple: a type $t$ weakly conforms to another type $u$ when $u$'s size contains all values of $t$ (we say that $t$ can be converted to $u$ without precision loss). 

A {\em weak least upper bound} is a least upper bound with respect to weak conformance. 





\section{Reified Types}
\label{sec:reified-types}

Unlike in Java or Scala, {\em type erasure} does not exist in Coral. Instead, type arguments are {\em reified} -- meaning that they persist in runtime. This is achieved by generating a lightweight subtype of parameterized types, containing basically just a reference to the parameterized type and a tuple of type arguments. This also implies that each new combination of type arguments to the exact same parameterized type creates a new lightweight subtype.

Reified types have some major effects on programs in Coral:
\begin{itemize}

\item Type arguments are accessible in runtime. The actual type argument can be inspected via reflection. 

\item Type arguments do not go away after compilation. This means, for example, that mutable collections should have invariant type parameters, since a hypothetical \code{List[+T]} can have type instance \code{List[String]} assigned to a variable bound to be a \code{List[Object]}, but instances of other subclasses than those that conform to \code{String} will not be able to be added to the collection. This is in fact true even if Coral did have type erasure -- the difference is, with reified types, the addition of a new incompatible value will fail immediately, unlike with type erasure, where retrieving the added value would fail later. 
\end{itemize}









