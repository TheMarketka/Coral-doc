%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Top-Level Definitions}

\section{Compilation Units}
\label{sec:compilation-units}

\subsection{Modules}
\label{sec:modules}

\syntax\begin{lstlisting}
Compilation_Unit ::= {'module' Module_Path semi [Top_Stat_Seq]} 
                     Top_Stat_Seq
Top_Stat_Seq     ::= Top_Stat {semi Top_Stat}
Top_Stat         ::= {Annotation} {Modifier} Tmpl_Def
                   | Use
                   | Packaging
                   | Module_Object
                   | Expr
                   | ()
\end{lstlisting}

Module definitions are objects that have one main purpose: to join related code and separate it from the outside. Coral's approach to modules solves these issues: 
\begin{itemize}
\item {\em Namespaces}. A class with a name $C$ may appear in a module $M$ or a module $N$, or any other module, and yet be a different object. Modules may be nested.
\item {\em Vendor packages}. Even modules of the same name may co-exists, provided that they have a different vendor, which is just an identifier that looks like a reverse domain name (similar to Java or Scala packages). 
\end{itemize}

A compilation unit (a single source file) consists of a sequence of packagings, import clauses, and class and object definitions, which may be preceded (and should be preceded) by a module clause. 

A compilation unit 
\begin{lstlisting}
module $p_1$
$\ldots$
module $p_n$
$\stats$
\end{lstlisting}
starting with one or more module clauses is equivalent to a compilation unit consisting of the packaging
\begin{lstlisting}
module $p_1$
  $\ldots$
  module $p_n$
    $\stats$
  end module
end module
\end{lstlisting}

Implicitly imported into every compilation unit are, in that order: 
\begin{enumerate}
\item the module ~\lstinline!Root~Lang~[com.coral-lang]! 
\item the object ~\lstinline!Root~Lang~[com.coral-lang].Predef!
\end{enumerate} 
Members of a later import in that order hide members of an earlier import. 

% TBD: notice that the implicit import may be overridden by a pragma at the beginning of a compilation unit

The implicitly added code looks like the following code listing, with all its implications:
\begin{lstlisting}
use Root~Lang~[com.coral-lang].{_}
use Root~Lang~[com.coral-lang].Predef.{_}
\end{lstlisting}





\subsection{Packagings}

\syntax\begin{lstlisting}
Packaging  ::= 'module' Module_Path (Packaging1 | Packaging2)
Packaging1 ::= semi Top_Stat_Seq 'end' ['module']
Packaging2 ::= '{' Top_Stat_Seq '}'
\end{lstlisting}

A module is a special object which defines a set of member classes, objects and another modules. Like open templates (\sref{sec:open-templates}), modules are introduced by multiple definitions across multiple source files.  






\subsection{Module Object}

\syntax\begin{lstlisting}
Module_Object ::= 'module' 'object' Trait_Template
\end{lstlisting}






\subsection{Module References}

\syntax\begin{lstlisting}
Path ::= Module_Path
\end{lstlisting}





\section{Programs}

A {\em program} is a module that has 1 or more entry points. 

\example The following example will create a hello world program by defining a module entry point in module \code{Test}. 

\syntax\begin{lstlisting}[morekeywords={entry}]
module Test ~[com.example]
module object {
  entry def main (args: Sequence[String]) := {
    Console.print_line "Hello world!"
  }
}
\end{lstlisting}

This program can be started by the command
\begin{lstlisting}
% coral Test
\end{lstlisting}








