%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Basic Declarations \& Definitions}

\syntax\begin{lstlisting}
Dcl         ::= 'val' Val_Dcl
              | 'var' Var_Dcl
              | 'def' Def_Dcl
              | 'message' Fun_Dcl 'end' ['message']
              | 'function' Fun_Dcl 'end' ['function']
              | 'type' Type_Dcl
Pat_Var_Def ::= 'val' Pat_Def
              | 'var' Var_Def
              | 'let' ['!'] id [Param_Clauses] ':=' Expr
Def         ::= Pat_Var_Def
              | 'def' Fun_Def
              | 'method' Fun_Def 'end' ['method']
              | 'method' Fun_Alt_Def
              | 'function' Fun_Def 'end' ['function']
              | 'function' Fun_Alt_Def
              | 'type' Type_Def
              | Tmpl_Def
\end{lstlisting}

A {\em declaration} introduces names and assigns them types. Using another words, declarations are abstract members, working sort of like header files in C. 

A {\em definition} introduces names that denote terms or types. Definitions are the implementations of declarations. 

Both declarations and definitions produce {\em bindings} that associate type names with type definitions or bounds, and that associate term names with types. 

Even more simply put, declarations declare a binding with a type (or type-less), and definition defines the term behind that binding (along with the binding). 

% TBD: differences between val, var, def, type, let
% val: values, immutable variables, patterns, lazy values, constant values, parameterless functions that return a value
% var: mutable variables, patterns
% def: functions
% type: types, aliases
% let: immutable values, patterns
% let!: immutable values (see async...)




\section{Value \& Variable Names}
\label{sec:val-var-names}

Syntax rules defined in the following sections do not restrict users from choosing whatever value or variable name they want. However, there are a few conventions that are recommended to follow, because otherwise, an inconsistency in naming could arise in face of pattern matching (\sref{sec:pattern-matching}):

\begin{itemize}
  \item If a value or variable is to contain a type (such as a class), use upper-case first letter in its name (unless it makes more sense to have a lower-case first letter due to the name itself). 
  \item In other cases, where a value or variable is to contain a non-type value, use lower-case first letter in its name, without exceptions. 
\end{itemize}

This is to keep up consistency with pattern matching, where the type will usually be presented with a name that starts with an upper-case letter (but does not need to if necessary), but all bound variables have to start with a lower-case letter, without exceptions. So basically, these conventions follow the restrictions imposed by pattern matching. 





\section{Value Declarations \& Definitions}
\label{sec:value-dcl-def}

\syntax\begin{lstlisting}
Dcl         ::= 'val' Val_Dcl
Val_Dcl     ::= val_ids ':' Type
Pat_Var_Def ::= 'val' Pat_Def
              | 'let' ['!'] var_dcl ':=' Expr
Pat_Def     ::= Pattern2 {',' Pattern2} [':' Type] ':=' Exprs
              | [var_ids ','] ['*' id [':' Type] ','] var_ids 
                ':=' Mul_Exprs
              | [var_ids ','] '*' id [':' Type] 
                ':=' Mul_Exprs
var_ids     ::= var_dcl {',' var_dcl}
var_dcl     ::= id [Param_Clauses] [':' Type]
val_ids     ::= id {',' id}
\end{lstlisting}

A value declaration \lstinline@val $x$: $T$@ introduces $x$ as a name of a value of type $T$. May appear in any block of code and an attempt to use it prior to initialisation with a value is an error. More specifically, a value declaration \lstinline+val @$x$: $T$+ introduces $x$ as a name of an instance value of type $T$, and a value declaration \lstinline+val @@$x$: $T$+ introduces $x$ as a name of a class instance value of type $T$. 

A value definition \lstinline@val $x$: $T$ := $e$@ defines $x$ as a name of the value that results from evaluation of expression $e$.

A value in this sense\footnote{Everything in Coral is a value -- remember, Coral is also a functional language, to some extent.} is an immutable variable. A declared value can be assigned just once\footnote{A similar way that \lstinline[language=Java]@final@ variables or members in Java can be assigned just once, but Java furthermore requires that this assignment will happen in every code path, Coral does not impose such requirement.}, a defined value is already assigned from its definition. 

The value type $T$ may be always omitted, in that case the type is inferred and bound to the name. If a type $T$ is omitted, the type of expression $e$ is assumed. If a type $T$ is given, then $e$ is expected to conform to it (\sref{sec:conformance}). 

Evaluation of the value definition implies evaluation of its right-hand side $e$, unless it has a modifier \code{lazy} -- in that case, evaluation is deferred to the first time the value is accessed. 

A {\em lazy value} is of the form
\begin{quote}\begin{lstlisting}
lazy val $x$: $T$ := $e$
\end{lstlisting}\end{quote}

A lazy value may only be defined, and a value of the same name (binding) may be declared prior to the value definition, but never as a lazy value. 

The effect of the value definition is to bind $x$ to the value of $e$ converted to type $T$. 

A {\em constant value definition} is of the form 
\begin{quote}\begin{lstlisting}
let $x$: $T$ := $e$
\end{lstlisting}\end{quote}
where $e$ is an expression that is supposed to be treated as constant in the same block from its occurrence on. Values defined with \code{let} have certain limitations and properties:

\begin{enumerate}
\item They can't use patterns instead of a name. 
\item They can't be lazy. 
\item They can't be used in a declaration, only in a definition. 
\item They can be used to redefine a variable (the name is then treated as a new binding in the scope). 
\item They can't define (class) instance variables. 
\item They can be used in workflows (\sref{sec:workflows}).\footnote{A pragma that would turn all values into lazy values might exist, and lazy values should never appear in workflows, so that's why \code{val} should not be allowed in workflows.}
\end{enumerate}

The type $T$ may be omitted. 

Value declarations \& definitions with the type $T$ omitted are of the form
\begin{quote}\begin{lstlisting}
val $x$
val @$x$
val @@$x$
val $x$ := $e$
val @$x$ := $e$
val @@$x$ := $e$
let $x$ := $e$
\end{lstlisting}\end{quote}

A value declaration without any type is basically only declaring the name, so that a binding is introduced and the actual value is for another code to define.\footnote{Usually, that another code should be a \code{constructor} or the class-level block in another file, maybe.}

A value definition can alternatively have a pattern (\sref{sec:patterns}) as left-hand side (the name). If $p$ is a pattern other than a simple name or a name followed by a colon and a type, then the value definition \lstinline@val $p$ := $e$@ is expanded as follows: 

\begin{enumerate}
\item
If the pattern $p$ has bound variables $x_1 \commadots x_n$ for some $n > 1$:
\begin{lstlisting}[escapechar=@]
val $x$@\$@ := match $e$
  when $p$ then ($x_1 \commadots x_n$)
end match
val $x_1$ := $x$@\$@(1)
$\ldots$
val $x_n$ := $x$@\$@($n$)
\end{lstlisting}

\item
If $p$ has exactly one unique bound variable $x$:
\begin{lstlisting}
val $x$ := match $e$
  when $p$ then $x$
end match
\end{lstlisting}

\item
If $p$ has no bound variables:
\begin{lstlisting}
match $e$
  when $p$ then ()
end match
\end{lstlisting}
\end{enumerate}

\example The following are examples of value definitions. 
\begin{lstlisting}
val pi := 3.14159
val pi: Double := 3.14159
val Some(x) := f() 
val Some(x), y := f()
val x ~> xs := my_list
\end{lstlisting}

The last three definitions have the following expansions:
\begin{lstlisting}[escapechar=@]
val x := match f()
  when Some(x) then x
end match

val x@\$@ = f()
val x := match x@\$@
  when Some(x) then x
end match
val y := x@\$@

val x@\$@ := match my_list
  when x ~> xs then (x, xs)
end match
val x := x@\$@(1)
val xs := x@\$@(2)
\end{lstlisting}

The name of any declared or defined value must not end with ``\lstinline@_=@''. 

The following shorthands are recognized: 
\begin{itemize}
\item[]
A value declaration ~\lstinline@val $x_1 \commadots x_n$: $T$@~ is a shorthand for the sequence of value declarations ~\lstinline@val $x_1$: $T$; $\ldots$; val $x_n$: $T$@. 

\item[]
A value definition ~\lstinline@val $p_1 \commadots p_n$ := $e$@~ is a shorthand for the sequence of value definitions ~\lstinline@val $p_1$ := $e$; $\ldots$; val $p_n$ := $e$@. 

\item[]
A value definition ~\lstinline@val $p_1 \commadots p_n: T$ := $e$@~ is a shorthand for the sequence of value definitions ~\lstinline@val $p_1: T$ := $e$; $\ldots$; val $p_n: T$ := $e$@.

\item[]
A value definition ~\lstinline!val $p_1\ \ps$: $T \commadots p_n\ \ps$: $T$ := $e$!~ is a shorthand for the sequence of value definitions ~\lstinline!val $p_1$: $\ps$ -> $T \commadots p_n$: $\ps$ -> $T$ := $e$!~, where $\ps$ are parameter sections (\sref{sec:function-decls-defs}).
\end{itemize}






\section{Variable Declarations \& Definitions}
\label{sec:variable-dcl-def}

\syntax\begin{lstlisting}
Dcl         ::= 'var' Var_Dcl
Pat_Var_Def ::= 'var' Var_Def
Var_Dcl     ::= var_ids ':' Type
Var_Def     ::= Pat_Def
              | var_ids ':' Type ':=' '_'
\end{lstlisting}

A variable declaration \lstinline@var $x$: $T$@ introduces a mutable variable without a defined initial value of type $T$. More specifically, \lstinline+var @$x$: $T$+ introduces a mutable instance variable of type $T$ and \lstinline+var @@$x$: $T$+ introduces a mutable class instance variable of type $T$. 

A variable definition \lstinline@var $x$: $T$ := $e$@ defines $x$ as a name of the value that results from evaluation of expression $e$. The type $T$ can be omitted, in that case the type of expression $e$ is assumed, but not bound to the variable -- the variable is only bound to \code{Object} then. If the type $T$ is given, then $e$ is expected to conform to it (\sref{sec:conformance}), as well as every future value of the variable. 

Variable definitions can alternatively have a pattern (\sref{sec:patterns}) as their left-hand side. A variable definition \lstinline@var $p$ := $e$@, where $p$ is a pattern other than a simple name followed by a colon and a type, is expanded in the same way (\sref{sec:value-dcl-def}) as a value definition \lstinline@val $p$ := $e$@, except that the free names in $p$ are introduced as mutable variables instead of values. 

The name of any declared or defined variable must not end with ``\lstinline@_=@''. 

A variable definition ~\lstinline!var $x$: $T$ := _!~ introduces a mutable variable with type $T$ and a default initial value. The default value depends on the type $T$ as follows:
\begin{quote}\begin{tabular}{ll}
\code{0} & if $T$ is \code{Integer} or one of its subrange types, \\
\code{0L} & if $T$ is \code{Long},\\
\lstinline@0.0f@ & if $T$ is \code{Float},\\
\lstinline@0.0d@ & if $T$ is \code{Double},\\
\code{no} & if $T$ is \code{Boolean},\\
\lstinline@()@ & if $T$ is \code{Unit}, \\
\code{nil} & for all other types $T$.
\end{tabular}\end{quote}
It is an error if the type $T$ is not nullable and is expected to have a default value at the same time. 

The following shorthands are recognized:
\begin{itemize}
\item[]
A variable declaration ~\lstinline@var $x_1 \commadots x_n$: $T$@~ is a
shorthand for the sequence of variable declarations ~\lstinline@var $x_1$: $T$; $\ldots$; var $x_n$: $T$@. 

\item[]
A variable definition ~\lstinline@var $x_1 \commadots x_n$ := $e$@~ is a shorthand for the sequence of variable definitions ~\lstinline@var $x_1$ := $e$; $\ldots$; var $x_n$ := $e$@. 

\item[]
A variable definition ~\lstinline@var $x_1 \commadots x_n$: $T$ := $e$@~ is a shorthand for the sequence of variable definitions ~\lstinline@var $x_1$: $T$ := $e$; $\ldots$; var $x_n$: $T$ := $e$@.

\item[]
A variable definition ~\lstinline!var $p_1\ \ps$: $T \commadots p_n\ \ps$: $T$ := $e$!~ is a shorthand for the sequence of value definitions ~\lstinline!var $p_1$: $\ps$ -> $T \commadots p_n$: $\ps$ -> $T$ := $e$!~, where $\ps$ are parameter sections (\sref{sec:function-decls-defs}).
\end{itemize}






\section{Property Declarations \& Definitions}
\label{sec:property-dec-dfn}

\syntax\begin{lstlisting}
Prop_Dcl   ::= 'property' ['(' Prop_Specs ')'] simple_id 
               [':' Type]
Prop_Specs ::= Prop_Spec {',' Prop_Spec}
Prop_Spec  ::= ([Access_Modifier] ('get' | 'set')) 
             | ['optional'] 'weak'
             | 'unowned'
             | ['optional'] 'soft'
Prop_Def   ::= 'property' ['(' Prop_Specs ')'] simple_id 
               [':' Type]
               '{' Prop_Impl {semi Prop_Impl} '}'
Prop_Impl  ::= ('get' Prop_Get_Impl)
             | ('set' Prop_Set_Impl)
             | ('val' ':=' Expr)
             | ('var' ':=' Expr)
\end{lstlisting} % TBD: syntax of property implementations

A property declaration \lstinline@property $x$: $T$@ introduces a property without a defined initial value of type $T$. Property declaration does not specify any actual implementation details of how or where the declared value is stored.

A property definition \lstinline@property $x$: $T$ {get $\ldots$; set $\ldots$}@ introduces a property with a possibly defined initial value of type $T$. Property definition may specify implementation details of the behavior and storage of a property, but may as well opt-in for auto-generated implementation, which is: 

\begin{enumerate}
\item 
Storage of the property's value is in an instance variable (or a class instance variable in case of class properties) of the same name as is the name of the property: \lstinline@property $x$@ is stored in an instance variable \lstinline+@$x$+. 

\item
Properties defined with only \code{get} are stored in immutable instance variables (\sref{sec:value-dcl-def}). 

\item
Properties defined with \code{set}\footnote{It is also possible to declare/define properties that are \code{set}-only. That makes them {\em write-only}, as opposed to {\em read-only} properties with \code{get}-only.} are stored in mutable instance variables (\sref{sec:variable-dcl-def}). 

\item
Properties defined with \code{weak} are stored as weak references. A property \lstinline@property $x$: $T$@ is stored in an instance of type \lstinline@Weak_Reference[$T$]@. 

\item
Properties defined with \code{unowned} are stored as unowned references. A property \lstinline@property $x$: $T$@ is stored in an instance of type \lstinline@Unowned_Reference[$T$]@. 

\item
Properties defined with \code{soft} are stored as unowned references. A property \lstinline@property $x$: $T$@ is stored in an instance of type \lstinline@Soft_Reference[$T$]@. 

\item
The getter and setter, including both implicit and explicit versions, automatically wrap (assignment) or unwrap (evaluation) the corresponding reference type. The default values defined with \code{val} or \code{var} do the same. 

\item
If the property is declared as \code{optional}, then the property is stored in an instance variable of type \code{A_Reference[Option[$T$]]}, where \code{A_Reference} is one of \code{Weak_Reference}, \code{Unowned_Reference} or \code{Soft_Reference}, and is again automatically wrapped and unwrapped as appropriate, but inside the \code{Option[$T$]} type. Should the reference be cleared, then \code{None} is set as the value. 

\end{enumerate}

Declaring a property $x$ of type $T$ is equivalent to declarations of a {\em getter function} $x$ and a {\em setter function} \lstinline@$x$_=@, declared as follows:

\begin{lstlisting}
def $x$ (): $T$; end
def $x$_= (y: $T$): (); end
\end{lstlisting}

Assignment to properties is translated automatically into a setter function call and reading of properties does not need any translation due to implicit conversions (\sref{sec:implicit-conversions}). 






\subsection{Property Implementations}
\label{sec:property-impl}

\begin{lstlisting}
Prop_Get_Impl ::= '(' ')' '->' '{' Block '}'
                | '{' Block '}'
Prop_Set_Impl ::= '(' id ')' '->' '{' Block '}'
                | '{' '|' id '|' semi Block '}'
\end{lstlisting}

Property implementations are restricted to parameterless block expressions for property getters and to block expressions with one parameter for property setters. If the property is specified with a \code{get} or \code{set}, but without a property getter or setter defined, then a default implementation is provided for the missing definitions, based on the property specifications. 





\section{Type Declarations \& Aliases}
\label{sec:type-decls-aliases}

\syntax\begin{lstlisting}
Dcl      ::= 'type' Type_Dcl 'end' ['type']
Type_Dcl ::= id [Type_Param_Clause] 
             ['>:' Type] ['<:' Type]
Def      ::= 'type' Type_Def
Type_Def ::= id [Type_Param_Clause] 
             (':=' | 'is') [['alias'] Type | 'class']
\end{lstlisting}

A {\em type declaration} \lstinline!type $t$[$\tps$] >: $L$ <: $U$! declares $t$ to be an abstract type with lower bound type $L$ and upper bound type $U$. If the type parameter clause \lstinline@[$\tps$]@ is omitted, $t$ abstracts over a first-order type, otherwise $t$ stands for a type constructor that accepts type arguments as described by the type parameter clause. 

If a type declaration appears as a member declaration of a type, implementations of the type may implement $t$ with any type $T$, for which $L \conforms T \conforms U$. It is an error if $L$ does not conform to $U$. Either or both bounds may be omitted. If the lower bound $L$ is omitted, the bottom type \code{Nothing} is implied. If the upper bound $U$ is omitted, the top type \code{Object} is implied. 

A type constructor declaration declaration imposes additional restriction on the concrete types for which $t$ may stand. Besides the bounds $L$ and $U$, the type parameter clause, indexing parameter clause and units of measure parameter clause may impose higher-order bounds and variances, as governed by the conformance of type constructors (\sref{sec:conformance}).

The scope of a type parameter extends over the bounds ~\lstinline!>: $L$ <: $U$!~ and the type parameter clause $\tps$ itself. A higher-order type parametre clause (of an abstract type constructor $tc$) has the same kind of scope, restricted to the declaration of the type parameter $tc$. 

To illustrate nested scoping, these declarations are all equivalent: 
\begin{itemize}
\item[]
~\lstinline!type t[m[x] <: Bound[x], Bound[x]] end! 

\item[]
~\lstinline!type t[m[x] <: Bound[x], Bound[y]] end!

\item[]
~\lstinline!type t[m[x] <: Bound[x], Bound[_]] end!,
\end{itemize} 
as the scope of, e.g., the type parameter of $m$ is limited to the declaration of $m$. In all of them, $t$ is an abstract type member that abstracts over two type constructors: $m$ stands for a type constructor that takes one type parameter and that must be a subtype of \code{Bound}, $t$'s second type constructor parameter. However, the first example should be avoided, as the last ~\lstinline!x!~ is unrelated to the first two occurrences, but may confuse the reader. 

A {\em type alias} \lstinline@type $t$ := $T$@ defines $t$ to be an alias name for the type $T$. Since---for type safety and consistence reasons---types are constant and can not be replaced by another type when bound to a constant name, type aliases are permanent. A type remembers the first given constant name, no alias can change that. The left hand side of a type alias may have a type parameter clause, e.g. \lstinline@type $t$[$\tps$] := $T$@. The scope of a type parameter extends over to the right hand side $T$ and the type parameter clause $\tps$ itself. 

It is an error if a type alias refers recursively to the defined type constructor itself. 

\example The following are legal type declarations and aliases:
\begin{lstlisting}
type Integer_List := List[Integer]
type T <: Comparable[T] end
type Two[A] := Tuple_2[A, A]
type My_Collection[+X] <: Iterable[X] end
\end{lstlisting}
The following are illegal:
\begin{lstlisting}
type Abs := Comparable[Abs] end // recursive type alias

type S <: T end  // S, T are bounded by themselves
type T <: S end

type T >: Comparable[T.That] end // can't select from T
                                 // T is a type, not a value
type My_Collection <: Iterable end
  // type constructor members must explicitly state
  // their type parameters
\end{lstlisting}






\section{Type Parameters}

\syntax\begin{lstlisting}
Type_Param_Clause  ::= '[' Variant_Type_Param 
                       {',' Variant_Type_Param} ']'
Variant_Type_Param ::= {Annotation} ['+' | '-'] Type_Param
                     | '<' (id | '_') ['<:' id] '>'
Type_Param         ::= (['*'] id | '_') [Type_Param_Clause]
                       ['>:' Type] ['<:' Type]
                       {'<%' Type} {':' Type}
\end{lstlisting}

Type parameters appear in type definitions, class definitions and function definitions. In this section we consider only type parameter definitions with lower bounds ~\lstinline!>: $L$!~ and upper bounds ~\lstinline!<: $U$!, whereas a discussion of context bounds ~\lstinline!: $T$!~ and view bounds ~\lstinline!<% $T$!~ is deferred to chapter about implicit parameters and views (\sref{sec:implicit-params-views}).

The most general form of a first-order type parameter is ~\lstinline!$a_1 \ldots a_n \pm\ t$[$\tps$] >: $L$ <: $U$!. $L$ is a lower bound and $U$ is an upper bound. These bounds constrain possible type arguments for the parameter. It is an error if $L$ does not conform to $U$. Then, $\pm$ is a {\em variance} (\sref{sec:variance-of-type-parameters}), i.e. an optional prefix of either \lstinline@+@ or \lstinline@-@. The type parameter may be preceded by one or more annotation applications (\sref{sec:annotated-exprs} \& \sref{sec:annotations}).

The names of all type parameters must be pairwise different in their enclosing type parameter clause. The scope of a type parameter includes in each case the whole type parameter clause. Therefore it is possible that a type parameter appears as part of its own bounds or the bounds of other type parameters in the same clause. However, a type parameter may not be bounded directly or indirectly by itself. 

A type parameter may also contain a nested type parameter. This is for cases when the expected type argument is a type constructor. 

The above scoping restrictions are generalized to the case of nested type parameter clauses, which declare higher-order type parameters. Higher-order type parameters (the type parameters of a type parameter $t$) are only visible in their immediately surrounding parameter clause (possibly including clauses at a deeper nesting level) and in the bounds of $t$. Therefore, their names must only be pairwise different from the names of other visible type parameters. Since the names of higher-order type parameters are thus often irrelevant, they may be denoted with a ``\lstinline!_!'', which is nowhere visible. 

A type parameter name may optionally be surrounded with angle brackets, ~\lstinline!<$t$ <: $u$>!. This makes the parameter name $t$ stand in for a unit of measure parameter, which may have an upper bound $u$, representing the abstract unit of measure. As units of measure do not have any deeper hierarchy structure, variance annotations are not applicable to them. 

\example The following are some well-formed type parameter clauses:
\begin{lstlisting}
[S, T]
[@[specialized] S, T]
[Ex <: Raiseable]
[A <: Comparable[B], B <: A]
[A, B >: A, C >: A <: B]
[M[X], N[X]]
[M[_], N[_]] // equivalent to previous clause
[M[X <: Bound[X]], Bound[_]]
[M[+X] <: Iterable[X]]
[E, <Length_Unit <: length>]
[+T, *A]
\end{lstlisting}
The following type parameter clauses are illegal:
\begin{lstlisting}
[A >: A]                  // illegal, 'A' has itself as bound
[A <: B, B <: C, C <: A]  // illegal, 'A' has itself as bound
[A, B, C >: A <: B]       // illegal lower bound 'A' of 'C'
                          // does not conform to upper bound 'B'
\end{lstlisting}

A type parameter name may optionally be prefixed with an asterisk ``\code{*}''. Such type parameter is a {\em variadic type parameter}, and may only appear as the last type parameter in a sequence of type parameters, and its resulting value is a tuple of all passed type arguments that were passed after the preceding type parameters. If such type parameter is used as the type of a function parameter, that parameter's type is a tuple type, as defined by the variadic type parameter, unless the function parameter is a repeated parameter, then the number of captured argument and their types are bound with the variadic type parameter (influencing local type inference (\sref{sec:local-type-inference})). 

\paragraph{Note}
If variance annotation is present with a variadic type parameter, place a space between the two:
\begin{lstlisting}
[+T, - *A]
\end{lstlisting}






\section{Variance of Type Parameters}
\label{sec:variance-of-type-parameters}

Variance annotations indicate how instances of parameterized types relate with respect to subtyping (\sref{sec:conformance}). A ``\lstinline!+!'' variance indicates a covariant dependency, a ``\lstinline!-!'' variance indicates a contravariant dependency, and an empty variance indicates an invariant dependency. 

A variance annotation constrains the way the annotated type variable may appear in the type or class which binds the type parameter. In a type definition ~\lstinline!type $T$[$\tps$] := $S$!, or a type declaration ~\lstinline!type $T$[$\tps$] >: $L$ <: $U$!, type parameters labeled ``\lstinline!+!'' must only appear in covariant position (positive), whereas type parameters labeled ``\lstinline!-!'' must only appear in contravariant position (negative), and type parameters without any variance annotation can appear in any variance position. Analogously, for a class definition ~\lstinline!class $C$[$\tps$]($\ps$) extends $T$ { requires $x$: $S\ \ldots$ }!, type parameters labeled ``\lstinline!+!'' must only appear in covariant position in the self type $S$ and the parent template $T$, whereas type parameters labeled ``\lstinline!-!'' must only appear in contravariant position in the self type $S$ and the parent template $T$.

The variance position of a type parameter in a type or template is defined as follows. Let the opposite of covariance be contravariance (thus positive positions are flipped to negative positions and vice versa), and the opposite of invariance be itself. The top-level of the type or template is always in covariant position (positive). The variance position changes at the following constructs. 
\begin{itemize}
\item The variance position of a method parameter is the opposite of the variance position of the enclosing parameter clause. 
\item The variance position of a type parameter is the opposite of the variance position of the enclosing type parameter clause. 
\item The variance position of the lower bound of a type declaration or a type parameter is the opposite of the variance position of the type declaration or the type parameter. 
\item The type of a mutable (instance) variable is always in invariant position (neutral). 
\item The right-hand side of a type alias is always in invariant position (neutral). 
\item The prefix $S$ of a type projection ~\lstinline!$S$#$T$!~ is always in invariant position (neutral). 
\item For a type argument $T$ of a type ~\lstinline!$S$[$\ldots T \ldots$]!: If the corresponding type parameter is covariant, then the variance position stays unchanged. If the corresponding type parameter is invariant (no variance annotation), then $T$ is in invariant position (neutral). If the corresponding type parameter is contravariant, the variance position of $T$ is the opposite of the variance position of the enclosing type ~\lstinline!$S$[$\ldots T \ldots$]!. 
\end{itemize}

\example In the following example, variance of positions is annotated with $^+$ (for positive) or $^-$ (for negative):
\begin{lstlisting}
abstract class Cat[-T$^+$, +U$^+$] {
  def meow [W$^-$] (volume: T$^-$, listener: Cat[U$^+$, T$^-$]$^-$):
    Cat[Cat[U$^+$, T$^-$]$^-$, U$^+$]$^+$
}
\end{lstlisting}
The positions of the type parameter, \code{W}, and the two value parameters, \code{volume} and \code{listener}, are all negative (flipped on type parameters and method parameters). Looking at the result type of \code{meow}, the position of the first \code{Cat[U, T]} argument is negative, because \code{Cat}'s first type parameter, \code{T}, is annotated with a ``\code{-}''. The type \code{U} inside this argument is again in a positive position (two flips), whereas the type \code{T} inside that argument is still in negative position. 

References to the type parameters in object-private or object-protected values, types, variables, or methods (\sref{sec:modifiers}) of the class are not checked for their variance position. In these members the type parameter may appear anywhere without restricting its legal variance annotations. 

\example The following variance annotation is legal. 
\begin{lstlisting}
abstract class P [+A, +B] {
  def first: A end
  def second: B end
}
\end{lstlisting}
With this variance annotation, type instances of $P$ subtype covariantly with respect to their arguments. For instance, 
\begin{lstlisting}
P[Error, String] <: P[Throwable, Object]  .
\end{lstlisting}
If the members of $P$ are mutable variables, the same variance annotation becomes illegal. 
\begin{lstlisting}
abstract class P [+A, +B](x: A, y: B) {
  var @first: A := x   // error: illegal variance:
  var @second: B := y  // 'A', 'B' occur in invariant position
}
\end{lstlisting}
If the mutable variables are object-private, the class definition becomes legal again: 
\begin{lstlisting}
abstract class R [+A, +B](x: A, y: B) {
  private[self] var @first: A := x   // ok
  private[self] var @second: B := y  // ok
}
\end{lstlisting}

\example The following variance annotation is illegal, since $a$ appears in contravariant position in the parameter of \code{append}:
\begin{lstlisting}
abstract class Sequence [+A] {
  def append (x: Sequence[A]): Sequence[A] end
    // error: illegal variance, 'A' occurs in contravariant position
}
\end{lstlisting}
The problem can be avoided by generalizing the type of \code{append} by means of lower bound:
\begin{lstlisting}
abstract class Sequence [+A] {
  def append [B >: A] (x: Sequence[B]): Sequence[B] end
}
\end{lstlisting}

\example Here is a case where a contravariant type parameter is useful. 
\begin{lstlisting}
abstract class Output_Channel [-A] {
  def write (x: A): Unit end
}
\end{lstlisting}
With that annotation, we have that \code{Output_Channel[Object]} conforms to \code{Output_Channel[String]}. That is, a channel on which one can write any object can substitute for a channel on which one can write only strings. 
 





\section{Function Declarations \& Definitions}
\label{sec:function-decls-defs}

\syntax\begin{lstlisting}
Dcl           ::= 'def' Fun_Dcl 'end' ['def']
                | 'message' Fun_Dcl 'end' ['message']
                | 'function' Fun_Dcl 'end' ['function']
                | 'operator' Op_Dcl 'end' ['operator']
Fun_Dcl       ::= Fun_Sig ':' Type
Op_Dcl        ::= Op_Sig ':' Type
Def           ::= 'def' Fun_Def 'end' ['def']
                | 'def' Fun_Alt_Def
                | 'method' Fun_Def 'end' ['method']
                | 'method' Fun_Alt_Def
                | 'function' Fun_Def 'end' ['function']
                | 'function' Fun_Alt_Def
                | 'operator' Op_Def 'end' ['operator']
                | 'operator' Op_Alt_Def 'end' ['operator']
Fun_Def       ::= Fun_Sig [':' Type] [Fun_Dec] [semi Fun_Stats]
Fun_Alt_Def   ::= Fun_Sig [':' Type] ':=' Expr
Op_Def        ::= Op_Sig [':' Type] [Fun_Dec] [semi Fun_Stats]
Op_Alt_Def    ::= Op_Sig [':' Type] ':=' Expr
Fun_Dec       ::= [semi] 'declare' Fun_Dec_Exprs [semi] 'begin'
Fun_Dec_Exprs ::= Fun_Dec_Expr {semi Fun_Dec_Expr}
Fun_Sig       ::= Function_Path [Type_Param_Clause] Param_Clauses
Op_Sig        ::= Op_Path [Type_Param_Clause] Param_Clauses
Function_Path ::= id
                | 'self' '.' id
                | id '.' id
Op_Path       ::= op_id
                | 'self' '.' op_id
                | Container_Path
Param_Clauses ::= {Param_Clause} ['(' 'implicit' Params ')']
Param_Clause  ::= '(' [Params] ')'
Params        ::= Param {',' Param}
Param         ::= {Annotation} [Param_Extra] id [id]
                  [':' Param_Type] [':=' Expr]
                | Literal
                | Stable_Id ['(' [Patterns] ')']
Param_Extra   ::= ['lazy'] [Param_Io] [Param_Rw] 
                  ['*' | '&' | '~']
Param_Io      ::= 'in' ['out'] | 'out'
Param_Rw      ::= 'val' | 'var'
Param_Type    ::= ['=>' | '=>>'] (Type | id | '_')
\end{lstlisting}

A function declaration has the form of \lstinline@def $f$ $\psig$: $T$@, where $f$ is the function's name, $\psig$ is its parameter signature and $T$ is its return type. 

A function definition \lstinline@def $f$ $\psig$: $T$ := $e$@ also includes a {\em function body} $e$, i.e. an expression which defines the functions's return value. A parameter signature consists of an optional type parameter clause \lstinline@[$\tps$]@, followed by zero or more value parameter clauses \lstinline@($\ps_1$)$\ldots$($\ps_n$)@. Such a declaration or definition introduces a value with a (possibly polymorphic) method type, whose parameter types and return types are as given. 

The type of the function body is expected to conform (\sref{sec:conformance}) to the function's declared result type, if one is given. 

If the function's result type is given as one of ``\lstinline!()!'' or \code{Unit}, the function's implicit return value is stripped and it is an error if a return statement occurs in the function body with a value to be returned, unless the return value is specified again as ``\lstinline!()!''.

An optional type parameter clause $\tps$ introduces one or more type parameters, possibly with bounds. The scope of a type parameter includes the whole signature, including any of the type parameter bounds as well as the function body, if present. 






\subsection{Curried Function Definitions}

Multiple parameter clauses render curried functions. 

Type parameters of the whole function are linked to each value parameter clause. If local type inference selects a type argument that does not appear in a previous value parameter clause, it is still used in the following value parameter clauses where it does appear. 






\subsection{Function Parameters}

A value parameter clause $ps$ consists of zero or more formal parameter bindings, such as \lstinline@$x$: $T$@ or \lstinline@$x$: $T$ := $e$@, which bind value parameters and associate them with their types. Each value parameter declaration may optionally define a default value expression. The value expression is represented internally by an invisible function, which gets called when the function matched the function call and an explicit value for the parameter was not provided.

An operator declaration/definition is also a function declaration/definition, only it does not require backticks around the operator's name. 

Value parameters within a single parameter list (a parameter list is a parameter clause) are divided into three virtual sections, each of which may be empty:
\begin{enumerate}
  \item Positional parameters (\sref{sec:positional-parameters}): mandatory parameters (\sref{sec:mandatory-parameters}), optional parameters (\sref{sec:optional-parameters}), variadic parameters (\sref{sec:variadic-parameters}). 
  \item Purely named parameters (\sref{sec:named-parameters}). 
  \item Block capturing parameter. 
\end{enumerate}




The order in which different kinds of value parameters may appear is as follows:
\begin{enumerate}
  \item Positional parameters:
    \begin {enumerate}
      \item $n$ mandatory positional parameters (\sref{sec:positional-parameters}): \lstinline@$x$: $T$@, where $n \ge 0$.

      \item $n$ optional positional parameters (\sref{sec:optional-parameters}): \lstinline@$x$: $T$ := $e$@, where $n \ge 0$. 

      \item $n$ variadic parameters (\sref{sec:variadic-parameters}): \lstinline@*$x$: $T$@, where $0 \le n \le 1$. 

      \item $n$ post mandatory positional parameters (\sref{sec:positional-parameters}): \lstinline@$x$: $T$@, where $n \ge 0$.
      
    \end{enumerate}
  
  \item Purely named parameters:
    \begin{itemize}
      \item $n$ named parameters (\sref{sec:named-parameters}): ~\lstinline@~$x$: $T$@ and/or ~\lstinline@~$x$: $T$ := $e$@, where $n \ge 0$. 

      \item $n$ capturing named parameter (\sref{sec:capturing-named-parameter}): \lstinline@**$x$: $T$@, where $0 \le n \le 1$. 
      
    \end{itemize}

  \item $n$ captured block parameters (\sref{sec:captured-block-parameter}): \lstinline@&$x$: $T$@, where $0 \le n \le 1$.
\end{enumerate}

For every parameter $p_{i,j}$ with a default value expression, a function named 
\begin{lstlisting}[escapechar=`]
default`\$`$n$
\end{lstlisting}
is generated inside the function, inaccessible for user programs. Here, $n$ denotes the parameter's position in the method declaration. These methods are parameterized by the type parameter clause \lstinline@[$\tps$]@ and all value parameter clauses \lstinline@($ps_1$)$\ldots$($ps_{i-1}$)@ preceeding $p_{i,j}$.

The scope of a formal value parameter name $x$ comprises all subsequent parameter clauses, as well as the method return type and the function body, if they are given.

\example In the method
\begin{lstlisting}
def compare[T](a: T := 0)(b: T := a) := (a = b)
\end{lstlisting}
the default expression \code{0} is type-checked with an undefined expected type. When applying \lstinline@compare()@\footnote{Without any explicit arguments.}, the default value \code{0} is inserted and \code{T} is instantiated to \code{Number}. The functions computing the default arguments have the forms\footnote{See, at the moment \lstinline[mathescape=false]!default$2! is called, the parameter \code{a} is already computed and passed as an argument to it.}:
\begin{lstlisting}[escapechar=`]
def default`\$`1[T]: Number := 0
def default`\$`2[T](a: T): T := a
\end{lstlisting}

Parameters may be optionally flagged with \code{var} and \code{val} keywords, modifying their mutability inside the method. Some combinations are disallowed, as explained in the following sections. All parameters are implicitly \code{val}-flagged, unless the parameter kind implies a \code{var} flag, such as an output parameter (\sref{sec:io-parameters}).





\subsection{External \& Internal Parameter Names}
\label{sec:external-internal-parameter-names}

\syntax\begin{lstlisting}
Param ::= $\ldots$ id [id] $\ldots$
\end{lstlisting}

The {\em external parameter name} is the one which may be used in function applications (\sref{sec:function-applications}) to specify the target parameter. The {\em internal parameter name} is the one that the function body uses. If the parameter name appears as ~\lstinline!$a$ $b$!, then $a$ is the external parameter name and $b$ is the internal parameter name. If the parameter name appears as $a$, it is both the external and the internal parameter name. If the parameter name is prefixed with a tilde ``\lstinline!~!'', then such a parameter may only be specified by its external name in function applications, and is said to be a purely named parameter (\sref{sec:named-parameters}). 

If a function applies itself as a part of its own definition, then again, the external parameter name is effective, never the internal parameter name. 

Each internal parameter name may appear only once across every parameter list. Each external parameter name may only appear once per one parameter list, but may generally appear across multiple parameter lists, provided that its internal parameter name does not. 





\subsection{Parameter Evaluation Strategies}
\label{sec:param-eval-strategies}

Note: This section applies (from the other side of the wall) to function applications (\sref{sec:function-applications}) as well, but it's pointless to have it duplicated over there. 

Coral utilizes five parameter (resp. argument) evaluation strategies. Every strategy defers evaluation of argument values until the function application is resolved, using only arguments' expected types -- see (\sref{sec:overloading-resolution}). 

\paragraph{Call-by-value, strict}
Also known as {\em call-by-object}, {\em call-by-object-sharing} or {\em call-by-sharing}, is the default evaluation strategy, applied to all parameters, unless otherwise specified. Such arguments are evaluated prior function invocation and are not re-evaluated. This includes explicit parameter values (\sref{sec:explicit-parameters}).

\paragraph{Call-by-reference, strict}
Also known as {\em pass-by-reference}, the function can modify the original argument variable. Those are described in (\sref{sec:io-parameters}) as {\em output parameters}. 

\paragraph{Call-by-name, non-strict}
The argument is not evaluated until accessed, and is re-evaluated each time it is accessed, providing another tool to create DSLs. Those are described in (\sref{sec:by-name-parameters}). 

\paragraph{Call-by-need, non-strict}
Also known as {\em lazy evaluation}, this is a memoized version of {\em call-by-name} strategy. The difference is, {\em call-by-need} parameters are not re-evaluated, once they are evaluated. 

\paragraph{Call-by-future, non-deterministic}
This is a rather experimental feature of Coral, depending on whether the Coral VM is capable of parallelization and whether there are defined standard tools for ``system'' parallelization. These are described in (\sref{sec:by-future-parameters}).






\subsubsection{By-Name Parameters}
\label{sec:by-name-parameters}

\syntax\begin{lstlisting}
Param_Extra ::= ['lazy'] ['in'] ['val']
                ['*' | '~']
Param_Type  ::= '=>' (Type | id | '_')
\end{lstlisting}

The type of a value parameter may be prefixed by ``\lstinline@=>@'', e.g. \lstinline@$x$: => $T$@. This indicates that the corresponding argument is not evaluated at the point of function application, but instead is evaluated at each use within the function.

The by-name modifier is disallowed for output parameters (\sref{sec:io-parameters} \& \sref{sec:io-arguments}) and for implicit parameters (\sref{sec:implicit-parameters}). The by-name modifier implies \code{val} parameter and is disallowed for \code{var} parameters. 

A by-name parameter bound to a wildcard type ``\lstinline!_!'' matches any type of by-name argument. 

By-name parameters with default value expressions evaluate the default value expression each time the parameter is accessed, unlike optional parameters that evaluate the default value expression only once. 






\subsubsection{By-Need Parameters}
\label{sec:by-need-parameters}

\syntax\begin{lstlisting}
Param_Extra ::= 'lazy' ['in'] [Param_Rw]
                ['*' | '~']
\end{lstlisting}

The parameter definition may be preceded by \code{lazy} keyword. This indicates that the corresponding argument is not evaluated before function application, but instead is evaluated the first time used within the function. 

The by-need modifier is disallowed for output parameters (\sref{sec:io-parameters} \& \sref{sec:io-arguments}) and for implicit parameters (\sref{sec:implicit-parameters}). The by-need modifier implies \code{val} parameter and is allowed for \code{var} parameters. 

By-need parameters with default value expressions evaluate the default value expression the first time the parameter is accessed, like optional parameters that evaluate the default value expression only once. 






\subsubsection{By-Future Parameters}
\label{sec:by-future-parameters}

\syntax\begin{lstlisting}
Param_Extra ::= ['in'] ['val']
                ['*' | '~']
Param_Type  ::= '=>>' (Type | id | '_')
\end{lstlisting}

By-future uses a concurrent evaluation strategy: the value of a future expression is computed concurrently with the flow of the rest of the program (on a new thread/worker). When the value of the future is needed, the invoking thread blocks until the future finishes computing, if it has not already completed by then. 

This strategy is non-deterministic, as the evaluation can occur at any time between when the future is created (when the function is applied) and when the value of the future is used. 

The by-future modifier is disallowed for output parameters (\sref{sec:io-parameters} \& \sref{sec:io-arguments}) and for implicit parameters (\sref{sec:implicit-parameters}). The by-future modifier implies \code{val} parameter and is disallowed for \code{var} parameters. 

By-future parameters with default value expressions evaluate the default value also as a future value, if the argument is not explicitly given. 

By-future parameter prefix is omitted from examples of valid parameter definitions, but it's allowed occurrence is the same as of by-name parameters (\sref{sec:by-name-parameters}). 





\subsection{Explicit Parameters}
\label{sec:explicit-parameters}

\syntax\begin{lstlisting}
Param ::= Literal 
        | Stable_Id ['(' [Patterns] ')']
\end{lstlisting}

The parameter may be specified by its literal value. Such parameters may only appear where positional mandatory parameters (\sref{sec:mandatory-parameters}) may appear. The type of the parameter is the inferred type of the literal value. Methods with explicit parameters are considered more specific during overloading resolution to methods with the same parameter types (\sref{sec:function-applications}). 

The recommendation for usage of these parameters are: 
\begin{itemize}
  \item Use explicit parameters with unary methods only. 
  \item If the value is a collection, use an empty collection literal only. 
\end{itemize}

\example Sample methods that use explicit parameters:
\begin{lstlisting}
def factorial (0) := 1
def factorial (x) := x * factorial(x - 1)
\end{lstlisting}

Since the parameter has no name to bind to, it is not accessible inside the method body. 

The parameter's explicit value may also be specified as an enum value (\sref{sec:enums}). The type of the parameter is then the type of the enum value. Optionally, this may be followed by a pattern matching construct, for cases of enums with contained values, which are then extracted according to the pattern matching. It is an error if the value of such an explicit parameter is not of enum type.\footnote{Case classes may and likely will be allowed in the future versions.} % TODO: allow case classes along enums






\subsection{Input \& Output Parameters}
\label{sec:io-parameters}

\syntax\begin{lstlisting}
Param_Io ::= 'in' ['out'] | 'out'
\end{lstlisting}

If no input/output parameter specifier is explicitly available, then the parameter is implicitly an input parameter. Output parameters require a specific application (\sref{sec:io-arguments}).

Output parameters imply \code{var} parameter and is disallowed for \code{val} parameters. Input parameters that are not output parameters at the same time can be both \code{var} and \code{val}. 






\subsection{Positional Parameters}
\label{sec:positional-parameters}

Positional parameters are identified by their ordered position within their section. Each such parameter has an external name that can be used to pass an argument into it by its name. The external name might not be the same as the internal name of the parameter: if there are two identifiers for the parameter name, the first one is external, the second one is internal. If there is one identifier for the parameter name, it is both external and internal. An internal name is the name under which the parameter is made available inside the function body, external name is the name under which an argument may be passed into the parameter. It is an error if the function body references a parameter by it's external name, if its internal name is different. 

Positional parameters can optionally contain default values. Positional parameters with default values are {\em optional parameters} (the other without default values are {\em required parameters}), and may appear only in the middle of the parameters section. During application, they are picked from left to right, and are omitted in application from right to left and assigned default values from left to right.

\example Positional mandatory parameters vs. optional parameters. Consider the following function declaration:
\begin{lstlisting}
def f (a, b := 0, c := 0, d := 0, e): Unit end
\end{lstlisting}

Then, a minimal number of passed arguments is 2, one for each positional mandatory parameter. If 3 arguments are passed, the second is assigned to \code{b}, and \code{c} and \code{d} are assigned with their default values. If 4 arguments are passed, the second is assigned to \code{b} and the third is assigned to \code{c}. If 5 arguments are passed, the second is assigned to \code{b}, the third is assigned to \code{c} and the fourth is assigned to \code{d}.

Positional parameters may also contain a special parameter that captures all extra arguments: {\em variadic parameter}. It's only legal position is right before the last positional mandatory parameter, and after any optional parameters, due to the order in which arguments are assigned to parameters. 





\subsubsection{Mandatory Parameters}
\label{sec:mandatory-parameters}

Positional mandatory parameters are of the forms:
\begin{lstlisting}
$x$: $T$
var $x$: $T$
val $x$: $T$
in $x$: $T$
in var $x$: $T$
in val $x$: $T$
out $x$: $T$
out var $x$: $T$
in out $x$: $T$
in out var $x$: $T$
$x$: => $T$
val $x$: => $T$
in $x$: => $T$
in val $x$: => $T$
\end{lstlisting}

Positional mandatory parameters may not have any modifiers, except for input/output modifiers (\sref{sec:io-parameters}) and by-name (\sref{sec:by-name-parameters}). 






\subsubsection{Optional Parameters}
\label{sec:optional-parameters}

Optional parameters are of the forms:
\begin{lstlisting}
$x$: $T$ := $e$
var $x$: $T$ := $e$
val $x$: $T$ := $e$
in $x$: $T$ := $e$
in var $x$: $T$ := $e$
in val $x$: $T$ := $e$
$x$: => $T$ := $e$
val $x$: => $T$ := $e$
in $x$: => $T$ := $e$
in val $x$: => $T$ := $e$
\end{lstlisting}

Optional parameters may not have any modifiers, except for input/output modifiers (\sref{sec:io-parameters})\footnote{Optional parameters are always ``input'', so that declaration is always redundant.} and by-name modifier (\sref{sec:by-name-parameters}). Optional parameters have a {\em default value expressions} and may appear between positional parameters, being followed by any number of positional parameters (including no more positional parameters at all), or being followed by repeated parameters and then positional parameters (\sref{sec:named-optional-arguments}). Optional parameters are disallowed for output parameters and repeated parameters. 

Optional parameters add the annotation (\sref{sec:annotations}) \code{@[optional_param]} to the corresponding parameter type of the function trait. 

If a parameter has a nullable type $T$ (either by being a nullable type, or allowing otherwise \code{Nothing} with a union type), and appears where an optional parameter may appear, it is taken as an optional parameter with default value of \code{nil} implicitly. 






\subsubsection{Variadic Parameters}
\label{sec:variadic-parameters}

Variadic parameters are of the forms:
\begin{lstlisting}
*$x$: $T$
var *$x$: $T$
val *$x$: $T$
in *$x$: $T$
in var *$x$: $T$
in val *$x$: $T$
\end{lstlisting}

Between optional parameters and the tailing positional parameters may be a value parameter prefixed by ``\lstinline!*!'', e.g. \lstinline!($\ldots$, *$x$: $T$)!. The type of such a {\em variadic parameter} inside the method is then a list type ~\lstinline!Sequence[$T$]!. Methods with variadic parameters take a variable number of arguments of type $T$ between the optional parameters block and the last positional parameters block, including no arguments at all (an empty list is then its value). If the type $T$ is defined by a variadic type parameter, then the type of the parameter inside the method is $T$ (which is a tuple type -- \sref{sec:tuple-types}). 

If a variadic parameter is flagged with \code{val}, the parameter itself is immutable, not the elements of the list. Variadic parameters are \code{val}-flagged implicitly, unless explicitly flagged as \code{var}, to protect the captured elements from accidental overwrite. 

Variadic parameter may be passed in a function application by name iff the type of the named argument is compatible with \code{Sequence[$T$]}, or the variadic type parameter $T$, if it is variadic. 

\example The following method definition computes the sum of the squares of a variable number of integer arguments.
\begin{lstlisting}
def sum (*args: Integer): Integer
declare
  var result := 0
begin
  for arg in args loop
    result += arg ^ 2
  end loop
  
  result
end
\end{lstlisting}
The following applications of this method yield \code{0}, \code{1}, \code{14}, in that order.
\begin{lstlisting}
sum
sum 1
sum 1, 2, 3
\end{lstlisting}
Furthermore, assume the definition:
\begin{lstlisting}
val xs := %[1, 2, 3]
\end{lstlisting}
The following application of the method \code{sum} is not resolved:\footnote{Unless there is an overloaded version of the method that accepts a list of integers as its parameter.}
\begin{lstlisting}
sum xs // Error: method match not found, wrong arguments
\end{lstlisting}
By contrast, the following application is well-formed and yields again the result \code{14}:
\begin{lstlisting}
sum *xs
\end{lstlisting}






\subsection{Purely Named Parameters}
\label{sec:named-parameters}
\label{sec:capturing-named-parameter}

Purely named parameters are of the forms:
\begin{lstlisting}
~$x$: $T$
var ~$x$: $T$
val ~$x$: $T$
in ~$x$: $T$
in var ~$x$: $T$
in val ~$x$: $T$
out ~$x$: $T$
out var ~$x$: $T$
in out ~$x$: $T$
in out var ~$x$: $T$
~$x$: $T$ := $e$
var ~$x$: $T$ := $e$
val ~$x$: $T$ := $e$
in ~$x$: $T$ := $e$
in var ~$x$: $T$ := $e$
in val ~$x$: $T$ := $e$
~$x$: => $T$
val ~$x$: => $T$
in ~$x$: => $T$
in val ~$x$: => $T$
~$x$: => $T$ := $e$
val ~$x$: => $T$ := $e$
in ~$x$: => $T$ := $e$
in val ~$x$: => $T$ := $e$
\end{lstlisting}

Capturing named parameter are of the form: 
\begin{lstlisting}
**$x$: $T$
var **$x$: $T$
val **$x$: $T$
in **$x$: $T$
in var **$x$: $T$
in val **$x$: $T$
\end{lstlisting}

Purely named parameters are parameters that may only be assigned arguments using their external name, never by their position, which may be arbitrarily reordered by the language. 

Named parameters are a way of allowing users of the method to write down arguments in any order, provided that their name is given at function application (\sref{sec:function-applications} \& \sref{sec:named-optional-arguments}). Named parameters may have a default value expression and may be both input and output. Named parameters are disallowed for variadic parameters. Named parameters inside the method are then accessible the same way as a positional parameters. 

Purely named parameters have the same definition of external and internal parameter names as positional parameters: if there are two identifiers for the purely named parameter name, then the first one is the external and the second one is the internal parameter name. If there is only one identifier, it is both the external and internal parameter name. 

Purely named parameters do not impose any rules on the position where each of their kind may appear, exactly because their order of appearance is insignificant. Therefore, purely named parameters with default values may appear anywhere, just like the capturing named parameter (which may appear exactly once, or not at all). 

Capturing named parameter is capturing any other applied named parameters that were not captured by their explicit declaration (\sref{sec:named-optional-arguments}). It is usually declared after the section of purely named parameters, prefixed by ``\lstinline!**!'', e.g. \lstinline!($\ldots$, **$x$: $T$)!, but may generally appear among other purely named parameters, the language does not really care. The type of such a captured named parameter inside the method is then a dictionary type \lstinline!Dictionary[Symbol, $T$]!. Methods with capturing named parameter take a variable number of named arguments of type $T$ mixed with other named arguments and before the captured block parameter. capturing named parameter are disallowed for repeated parameters, output parameters and by-name parameters. 

If a captured named parameter is flagged with \code{val}, the parameter itself is immutable, not the elements of the dictionary. capturing named parameter are \code{val}-flagged implicitly, unless explicitly flagged as \code{var}, to protect the captured elements from accidental overwrite. 

If a capturing named parameter is supposed to capture arguments of multiple types, one can use union types (\sref{sec:unions}). This does not ensure any particular relation between the argument's key and value's type other than that provided by the union though.

If a purely named parameter has a nullable type $T$ (either by being a nullable type, or allowing otherwise \code{Nothing} with a union type), it is taken as having default value of \code{nil} implicitly. 





\subsection{Captured Block Parameter}
\label{sec:captured-block-parameter}

Captured block parameters are of the forms:
\begin{lstlisting}
&$x$
&$x$: $T$
in &$x$
in var &$x$
in val &$x$
in &$x$: $T$
in var &$x$: $T$
in val &$x$: $T$
\end{lstlisting}

Captured block parameter is a way to capture an applied block that is otherwise passed in implicitly as a function into \code{yield} expressions. The forms of captured block parameters explicitly denote the case without the block's function type, since block parameters receive any arguments and those missing are implicitly set to \code{nil}. The function type of the block may be used to further constrain the applied block argument, but is not used during method resolution (\sref{sec:function-applications}). The captured block parameter may be used also to capture function arguments, e.g. anonymous functions (\sref{sec:anonymous-functions}), then the type is used during method resolution. 

It is an error if a block parameter type $T$ is provided and it is not a function type (\sref{sec:function-types}). It is also an error if the applied block argument does not accept the arguments declared by the type $T$, or if the block would not return a value conforming to the return type required by the type $T$. The applied block argument may accept more arguments than required by $T$, however, these will be set implicitly to \code{nil}. Also, the applied block argument may itself require less constrained parameter types, in which case the arguments applied to it must (and will) always conform (\sref{sec:conformance}) to the block's parameter requirements. Whether the function type $T$ has a return type or not is irrelevant. 

If a block parameter type $T$ is given, then the applied block argument must accept parameters, such that the parameter constrains declared by the function type $T$ conform to the parameter constrains declared by the applied block: the parameters of the applied block must be the same or less restrictive than those declared by $T$ -- they must be pairwise contravariant or invariant, never covariant (\sref{sec:variance-of-type-parameters}). 

If a function has multiple parameter lists, the captured block parameter may only appear in the last one, unless the last one is an implicit parameters list, in which case the last allowed parameter list for a captured block parameter to appear in is the one directly preceding the implicit parameters list. 





\subsection{Method Signature}
\label{sec:method-signature}

Two methods $M$ and $N$ have the same signature, if they have the same name, the same type parameters (if any), the same parameters with equivalent types, and equivalent return type. 

The signature of a method $m_1$ is a {\em subsignature} of the signature of a method $m_2$ if either:
\begin{itemize}
\item $m_2$ has the same signature as $m_1$, or
\item the signature of $m_1$ has the same name, the same type parameters (if any), the same parameters with equivalent types, and a return type that conforms to return type of $m_2$. 
\end{itemize}

A method signature $m_1$ is {\em override-matching} $m_2$, if $m_1$ is a subsignature of $m_2$. Two method signatures $m_1$ and $m_2$ are {\em override-equivalent}, iff $m_1$ is the same as $m_2$. 






\section{Method Types Inference}
\label{sec:method-types-inference}

\paragraph{\em Parameter Type Inference}
Functions that are members of a class $C$ may define parameters without type annotations. The types of such parameters are inferred as follows. Say, a~method $m$ in a class $C$ has a parameter $p$ which does not have a type annotation. We first determine methods $m'$ in $C$ that might be overridden (\sref{sec:overriding}) by $m$, assuming that appropriate types are assigned to all parameters of $m$ whose types are missing. If there is exactly one such method, the type of the parameter corresponding to $p$ in that method---seen as a member of $C$---is assigned to $p$. It is an error if there are several such overridden methods $m'$. If there is none\footnote{Detected at compile-time. Dynamically added overridden methods are not used with type inference.} ($m$ does not override any $m'$ known at compile-time), then the parameters are inferred to be of type \code{Object}.

\example Assume the following definitions:
\begin{lstlisting}[escapechar=`]
protocol I[`\$`A]
  def f(x: `\$`A)(y: `\$`A): `\$`A
end
class C
  implements I[Integer]
  def f(x)(y) := x + y
end
\end{lstlisting}
Here, the parameter and return types of \lstinline@f@ in \lstinline@C@ are
inferred from the corresponding types of \lstinline@f@ in \lstinline@I@. The 
signature of \lstinline@f@ in \lstinline@C@ is thus inferred to be
\begin{lstlisting}
  def f(x: Integer)(y: Integer): Integer
\end{lstlisting}

\paragraph{\em Return Type Inference}
A class member definition $m$ that overrides some other function $m'$ in a base class of $C$ may leave out the return type, even if it is recursive. In this case, the return type $R'$ of the overridden function $m'$---seen as a member of $C$---is taken as the return type of $m$ for each recursive invocation of $m$. That way, a type $R$ for the right-hand side of $m$ can be determined, which is then taken as the return type of $m$. Note that $R$ may be different from $R'$, as long as $R$ conforms to $R'$. If $m$ does not override any $m'$, then its return type is inferred to be of type \code{Object}. 

\example Assume the following definitions:
\begin{lstlisting}
protocol I
  def factorial(x: Integer): Integer
end
class C 
  implements I
  def factorial(x: Integer) := {
    if x = 0 then 1 else x * factorial(x - 1) end
  }
end
\end{lstlisting}
Here, it is ok to leave out the return type of \lstinline@factorial@
in \lstinline@C@, even though the method is recursive. 

For any index $i$ let $fsig_i$ be a function signature consisting of a function
name, an optional type parameter section, and zero or more parameter
sections. Then a function declaration 
~\lstinline@def $fsig_1 \commadots fsig_n$: $T$@~ 
is a shorthand for the sequence of function
declarations ~\lstinline@def $fsig_1$: $T$; $\ldots$; def $fsig_n$: $T$@.  
A function definition ~\lstinline@def $fsig_1 \commadots fsig_n$ := $e$@~ is a
shorthand for the sequence of function definitions 
~\lstinline@def $fsig_1$ := $e$; $\ldots$; def $fsig_n$ := $e$@.  
A function definition
~\lstinline@def $fsig_1 \commadots fsig_n: T$ = $e$@~ is a shorthand for the
sequence of function definitions 
~\lstinline@def $fsig_1: T$ := $e$; $\ldots$; def $fsig_n: T$ := $e$@.






\section{Overloaded Declarations \& Definitions}
\label{sec:overloaded-definitions}

If two member or entity definitions bind to the same name, but do not override each other at the same time, the member or entity is said to be {\em overloaded}, each member or entity is said to be an {\em alternative}, and overloading resolution (\sref{sec:value-conversions}) needs to be applied to select a unique alternative. 

Overloaded members do not need to appear in the same scope, an overloading member may appear e.g. in a subclass and never in the parent class. Overloaded entities however need to appear in the same scope (e.g. two local function definitions -- because the names are shadowed in enclosing scopes). 





\section{Use Clauses}
\label{sec:use-clauses}

\syntax\begin{lstlisting}
Use             ::= 'use' ['lazy'] Use_Expr
Use_Expr        ::= (Container_Path | Stable_Id) '.' Import_Expr
Import_Expr     ::= Single_Import
                  | '{' Import_Exprs '}'
                  | '_'
Import_Exprs    ::= Single_Import {',' Single_Import} [',' '_']
Single_Import   ::= id ['as' [id | '_']]
Container_Path  ::= Module_Path ['.' Constant_Path]
                  | [Root] Constant_Path
Module_Path     ::= [Root] Module_Selector {'.' Module_Selector}
Constant_Path   ::= Const_Selector {('.' | '#') Const_Selector}
Module_Selector ::= id [Vendor_Arg]
Const_Selector  ::= id
Root            ::= 'Root' '~'
Vendor_Arg      ::= '~[' vendor_domain ']'
vendor_domain   ::= vendor_char {vendor_char}
vendor_char     ::= lower | '.' | '-' | '_'
\end{lstlisting}

A use clause has the form ~\lstinline!use $p$.$I$!, where $p$ is a path to the containing type of the imported entity, and $I$ is an import expression. The import expression determines a set of names (or just one name) of {\em importable members}\footnote{Dynamically created members are not importable, since the compiler has no way to predict their existence.} of $p$, which are made available without full qualification, e.g. as an unqualified name. A member $m$ of $p$ is {\em importable}, if it is {\em visible} from the import scope and not object-private (\sref{sec:modifiers}). The most general form of an import expression is a list of {\em import selectors}
\begin{lstlisting}
{ $x_1$ as $y_1$ $\commadots$ $x_n$ as $y_n$, _ }
\end{lstlisting}
for $n \ge 0$, where the final wildcard ``\lstinline!_!'' may be absent. It makes available each importable member \lstinline!$p$.$x_i$! under the unqualified name $y_i$. I.e. every import selector \lstinline!$x_i$ as $y_i$! renames (aliases) \lstinline!$p$.$x_i$! to $y_i$. If a final wildcard is present, all importable members $z$ of $p$ other than $x_1 \commadots x_n, y_1 \commadots y_n$ are also made available under their own unqualified names. 

Import selectors work in the same way for type and term members. For instance, a use clause \lstinline!use $p$.{$x$ as $y$}! renames the term name \lstinline!$p$.$x$! to the term name $y$ and the type name \lstinline!$p$.$x$! to the type name $y$. At least one of these two names must reference an importable member of $p$. 

If the target name in an import selector is a wildcard, the import selector hides access to the source member. For instance, the import selector \lstinline!$x_i$ as _! ``renames'' $x$ to the wildcard symbol, which basically means discarding the name, since \lstinline!_! is not a readable name\footnote{Meaning, it is not possible to use ``\lstinline!_!'' as a variable to read from, it never has any value.}, and thereby effectively prevents unqualified access to $x$. This is useful if there is a final wildcard in the same import selector list, which imports all members not mentioned in previous import selectors, to selectively not import some members. 

The scope of a binding introduced by an import-clause starts immediately after the import clause and extends to the end of the enclosing scope and all nested scopes. 

Several shorthands exists. An import selector may be just a simple name $x$, in which case, $x$ is imported without renaming, so the import selector is equivalent to \lstinline!$x$ as $y$!. Furthermore, it is possible to replace the whole import selector list by a single identifier of wildcard. The use clause \lstinline!use $p$.$x$! is equivalent to \lstinline!use $p$.{$x$}!, i.e. it makes available without qualification the member $x$ of $p$. The use clause \lstinline!use $p$._! is equivalent to \lstinline!use $p$.{_}!, i.e. it makes available without qualification all importable members of $p$ (this is analogous to \lstinline[language=Java]!import $p$.*! in Java or \lstinline[language=Java]!import $p$._! in Scala). 

\example Consider the object definition:
\begin{lstlisting}
object M
  def z := 0
  def one := 1
  def add (x: Integer, y: Integer): Integer := x + y
end
\end{lstlisting}
Then the block
\begin{lstlisting}
{ use M.{one, z as zero, _}; add (zero, one) }
\end{lstlisting}
is equivalent to the block
\begin{lstlisting}
{ M.add (M.z, M.one) } .
\end{lstlisting}

A dynamic use clause has the form ~\lstinline!use lazy $p$.$I$!, where $p$ is a path to the containing type of the imported entity, and $I$ is an import expression. The difference from regular use clauses is that a dynamic use clause can import anything, including dynamically created members. In case of multiple dynamic imports providing the same name, the last one to be provided is preferred, and has to be type-compatible with any possibly previously provided name, i.e., it has to override the previously provided name as if it were a regular member. Dynamic use clause can also import a name that does not exist yet in compile time (by not using wildcard import). 

Note that when importing names via use clauses (or dynamic use clauses), the prefix $p$ of it is always a selection, but never an application. If a name in selection denotes several possible members, there is no way to use overloading resolution on it, other than that provided by type application. 



