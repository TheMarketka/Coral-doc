%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\section*{Preface}

Coral is a Ruby-like programming language which enhances advanced object-oriented programming with elements of functional programming. Everything is an object, in this sense it's a pure object-oriented language. Object blueprints are described by classes. Classes can be composed in multiple ways – classic inheritance and/or mixin composition, along with prototype-oriented inheritance.

Coral is also a functional language in the sense that every function is also an object, and generally, everything is a value. Therefore, function definitions can be nested and higher-order functions are supported out-of-the-box. Coral also has a limited support for pattern matching, which can emulate the algebraic types used in other functional languages.

Coral has been developed since 2012 in a home environment out of pure enthusiasm for programming and out of a desire for a truly versatile language. This document is a work in progress and will stay that way forever. It acts as a reference for the language definition and some core library classes.

Some of the languages that had major influence on the development of Coral, including syntax and behavior patterns, are Ruby, Ada, Scala, Java, C\#, F\# and Clojure. Coral tries to inherit their good parts and put them together in its own way.

The vast majority of Coral's syntax is inspired by \emph{Ruby}. Coral uses keyword program parentheses in Ruby fashion. There is \lstinline@class@ … \lstinline@end@, \lstinline@def@ … \lstinline@end@, \lstinline@do@ … \lstinline@end@, \lstinline@loop@ … \lstinline@end@. Ruby itself is inspired by other languages, so this relation is transitive and Coral is inspired by those languages as well (for example, Ada). 

Coral is inspired by \emph{Ada} in the way that user identifiers are formatted: \lstinline@Some_Constant_Name@ and — unlike in Ada, but quite similar to it — \lstinline@some_method_name@. Also, some control structures are inspired by Ada, such as loops, named loops, return expressions and record types. Pretty much like in Ada, Coral's control structures can be usually ended the same way: \lstinline@class@ … \lstinline@end class@ etc. 

\emph{Scala} influenced the type system in Coral. Syntax for existential types comes almost directly from it. However, Coral is a rather dynamically typed language, so the type checks are made eventually in runtime (but some limited type checks can be made during compile time as well). Moreover, the structure of this mere specification is inspired by Scala's specification. 

From \emph{F\#}, Coral borrows some functional syntax (like function composition) and F\# also inspired the feature of~\nameref{sec:unitsofmeasuresyntax}. 

\emph{Clojure} inspired Coral in the way functions can get their names. Coral realizes that turning function names into sentences does not always work, so it is possible to use dashes, plus signs and slashes inside of function names. Therefore, \lstinline@call/cc@ is a legit function identifier. Indeed, binary operators are required to be properly surrounded by whitespace or other non-identifier characters. 

\chapter{Lexical Syntax}

Coral programs are written using the Unicode character set; Unicode supplementary characters are supported as well. Coral programs are preferably encoded with the UTF-8 character encoding. While every Unicode character is supported, usage of Unicode escapes is encouraged, since fonts that IDEs might use may not support the full Unicode character set.

\newpage

\section{Identifiers}\label{sec:identifiers}

\syntax\begin{lstlisting}
simple_id   ::= lower [id_rest]
variable_id ::= simple_id | '_'
constant_id ::= upper [id_rest]
function_id ::= simple_id [id_rest_ext]
id_rest     ::= {letter | digit | '_'}
id_rest_ext ::= id_rest [id_rest_mid] ['?' | '!' | '=']
id_rest_mid ::= id_rest {('/' | '+' | '-') id_rest}
\end{lstlisting}

There are three kinds of identifiers.

First, \textit{variable identifiers}, which are simply a lower-case letter followed by arbitrary sequence of letters (any-case), digits and underscores, or just one underscore (which has special meaning).

Second, \textit{constant identifiers}, which are just like variable identifiers, but starting with an upper-case letter and never just an underscore.

And third, \textit{function identifiers}, which are the most complicated ones. They can start as a variable identifier, then optionally followed by one of ``/'', ``+'' and ``-'', and then optionally ended with ``?'' or ``!''.

Coral programs are parsed greedily, so that a longest match rule applies. Letters from the syntax may be any Unicode letters, but English alphabet letters are recommended, along with English names.

\section{Keywords}\label{sec:keywords}

A set of identifiers is reserved for language features instead of for user identifiers. However, unlike in most other languages, keywords are not being recognized inside of paths, except for a few specific cases.

The following names are the reserved words.

\begin{lstlisting}
alias        annotation  as           begin        bitfield
break        case        cast         catch        class
clone        constant    constructor  declare      def
destructor   do          else         elsif        end
ensure       enum        for          for-some     function
goto         if          implements   in           include
interface    is          let          loop         match
memoize      message     method       mixin        module
native       next        nil          no           of
opaque       operator    out          prepend      property
protocol     raise       range        record       redo
refine       rescue      retry        return       self
skip         struct      super        template     test
then         this        throw        transparent  type
undef        unless      until        union        unit-of-measure
use          val         var          void         yes
when         while       with         yield

\end{lstlisting}

Not every reserved word is a keyword in every context, this behavior will be further explained. For example, the bitfield reserved word is only recognized as a keyword inside an enumeration definition context, in a specific place. Every reserved word may be used as a function identifier, with a little work-around when used with an implicit receiver.

\section{Newline Characters}\label{sec:newlinecharacters}

\syntax\begin{lstlisting}

semi ::= nl {nl} | ';'

\end{lstlisting}

Coral is a line-oriented language, in which statements are expressions and may be terminated by newlines, as well as by semi-colon operator. A newline in a Coral source file is treated as the special separator token \lstinline@nl@ if the following criterion is satisfied:

\begin{enumerate}
\item The token immediately preceding the newline can terminate an expression.
\end{enumerate}

Since Coral may be interpreted in a REPL\footnote{Read-Eval-Print Loop} fashion, there are no other suitable criteria. Such a token that can terminate an expression is, for instance, not a binary operator or a message sending operator, which both require further tokens to create an expression. Keywords that expect any following tokens also can not terminate expressions. Coral interpreters and compilers do not look-ahead beyond newlines.

If the token immediately preceding the newline can not terminate an expression and is followed by more than one newline, Coral still sees that as only a one significant newline, to prevent any confusion.

Keywords that can terminate an expression are: \lstinline@break@, \lstinline@end@, \lstinline@opaque@, \lstinline@native@, \lstinline@next@, \lstinline@nil@, \lstinline@no@, \lstinline@redo@, \lstinline@retry@, \lstinline@return@, \lstinline@self@, \lstinline@skip@, \lstinline@super@, \lstinline@this@, \lstinline@transparent@, \lstinline@void@, \lstinline@yes@, \lstinline@yield@.

\section{Operators}\label{sec:operators}

A set of identifiers is reserved for language features, some of which may be overridden by user space implementations. Operators have language-defined precedence rules that are supposed to usually comply to user expectations (principle of least surprise), and another desired precedence may be obtained by putting expressions with operators inside of parenthesis pairs. 

The following character sequences are the operators recognized by Coral. 

\begin{lstlisting}

:=     +=     -=     *=     **=    /=     %=     ||=    &&=    ^^= 
|=     &=     |=     &=     ^=     ~=     <<     >>     <<<    >>> 
<<=    >>=    <<<=   >>>=   ;      =      !=     ==     !==    === 
!===   =~     !~     <>     <      >      <=     >=     <=>    + 
-      *      **     /      div    %      mod    ||     or     && 
and    !      not    ^^     xor    |      &      ^      ~      .. 
...    ,      ->     <-     ~>     <~     =>     ::     :      <: 
:>     <<|    |>>    <|     |>     (      )      [      ]      { 
}      .

\end{lstlisting}

Some of these operators have multiple meanings, usually up to two. Some are binary, some are unary, none is ternary. 

Binary (infix) operators have to be separated by whitespace or non-letter characters on both sides, unary operators on left side – the right side is what they are bound to. 

Unary operators are: \lstinline@+@, \lstinline@-@, \lstinline@&@, \lstinline@not@, \lstinline@!@ and \lstinline@~@. The first three of these are binary as well. The \lstinline@;@ operator is used to separate expressions (see \nameref{sec:newlinecharacters}). Parentheses are postcircumfix operators. Coral has no postfix operators. 

Coral allows for custom user-defined operators, but those have the lowest precedence and need to be parenthesized in order to express any precedence. Such custom operators can't be made of letter characters. 

\section{Literals}\label{sec:literals}

There are literals for numbers (including integer, floating point and complex), characters, booleans, strings, symbols, regular expressions and collections (including tuples, lists, dictionaries and bags). 

\syntax\begin{lstlisting}

literal ::= integer_literal
	| floating_point_literal
	| complex_literal
	| character_literal
	| string_literal
	| symbol_literal
	| regular_expression_literal
	| collection_literal
	| 'nil'

\end{lstlisting}

\subsection{Integer Literals}\label{sec:integerliterals}

\syntax\begin{lstlisting}

integer_literal     ::= ['+' | '-'] (decimal_numeral
	| hexadecimal_numeral
	| octal_numeral
	| binary_numeral)
decimal_numeral     ::= '0' | non_zero_digit {['_'] digit}
hexadecimal_numeral ::= '0x' | hex_digit {['_'] hex_digit}
digit               ::= '0' | non_zero_digit
non_zero_digit      ::= '1' | … | '9'
hex_digit           ::= '1' | … | '9' | 'a' | … | 'f'
octal_numeral       ::= '0' oct_digit {'_' oct_digit}
oct_digit           ::= '0' | … | '7'
binary_numeral      ::= '0b' bin_digit {['_'] bin_digit}
bin_digit           ::= '0' | '1'

\end{lstlisting}

Integers are usually of type \lstinline@Number@, which is a class cluster of all classes that can represent numbers. Unlike Java, Coral supports both signed and unsigned integers directly. Usually integer literals that are obviously unsigned integers are automatically represented internally by a class that stores the integer unsigned, like \lstinline@Integer_64_Unsigned@. Math operations on numbers are handled internally in such a way that the user does't need to worry about the actual types of the numbers — when an integer overflow would occur, the result is stored in a larger container type. 

Underscores used in integer literals have no special meaning, other than to improve readability of larger literals, i.e., to separate thousands.

Integral members of the \lstinline@Number@ class cluster include the following container types. 

\begin{enumerate}

\item \lstinline@Integer_8@ ($-2^{7}$ to $2^{7}-1$), alias \lstinline@Byte@

\item \lstinline@Integer_8_Unsigned@ ($0$ to $2^{8}$), alias \lstinline@Byte_Unsigned@

\item \lstinline@Integer_16@ ($-2^{15}$ to $2^{15}-1$), alias \lstinline@Short@

\item \lstinline@Integer_16_Unsigned@ ($0$ to $2^{16}$), alias \lstinline@Short_Unsigned@

\item \lstinline@Integer_32@ ($-2^{31}$ to $2^{31}-1$)

\item \lstinline@Integer_32_Unsigned@ ($0$ to $2^{32}$)

\item \lstinline@Integer_64@ ($-2^{63}$ to $2^{63}-1$), alias \lstinline@Long@

\item \lstinline@Integer_64_Unsigned@ ($0$ to $2^{64}$), alias \lstinline@Long_Unsigned@

\item \lstinline@Integer_128@ ($-2^{127}$ to $2^{127}-1$), alias \lstinline@Double_Long@

\item \lstinline@Integer_128_Unsigned@ ($0$ to $2^{128}$), alias \lstinline@Double_Long_Unsigned@

\item \lstinline@Decimal@ ($-\infty$ to $\infty$)

\item \lstinline@Decimal_Unsigned@ ($0$ to $\infty$)

\end{enumerate}

The special \lstinline@Decimal@ \& \lstinline@Decimal_Unsigned@ container types are also for storing arbitrary precision floating point numbers. All the container types are constants defined in the \lstinline@Number@ class and can be imported into scope if needed. 

Moreover, a helper type \lstinline@Number::Unsigned@ exists, which can be used for type casting in cases where an originally signed number needs to be treated as unsigned. 

Weak conformance applies to the inner members of \lstinline@Number@ class. 

For use with range types, \lstinline@Number::Integer@ and \lstinline@Number::Integer_Unsigned@ exist, to allow constraining of the range types to integral numbers.

\subsection{Floating Point Literals}\label{sec:floatliterals}

\subsection{Imaginary Number Literals}\label{sec:imaginaryliterals}

\subsection{Units of Measure}\label{sec:unitsofmeasuresyntax}

\subsection{Character Literals}\label{sec:characterliterals}

\syntax\begin{lstlisting}

character_literal ::= '%'' (character | unicode_escape) '''

\end{lstlisting}

\subsection{Boolean Literals}\label{sec:booleanliterals}

\subsection{String Literals}\label{sec:stringliterals}

\subsection{Symbol Literals}\label{sec:symbolliterals}

\subsection{Type Parameters}\label{sec:typeparameterliterals}

\subsection{Regular Expression Literals}\label{sec:regexpliterals}

\subsection{Collection Literals}\label{sec:collectionliterals}

\section{Whitespace \& Comments}\label{sec:whitespacecomments}

\section{Preprocessor Macros}\label{sec:preprocessormacros}

\chapter{Identifiers, Names \& Scopes}

\chapter{Types}

\section{Paths}

\section{Value Types}

\subsection{Value Type}

\subsection{Type Projection}

\subsection{Type Designators}

\subsection{Parametrized Types}

\subsection{Tuple Types}

\subsection{Annotated Types}

\subsection{Compound Types}

\subsection{Function Types}

\subsection{Existential Types}

\section{Non-Value Types}

\subsection{Method Types}

\subsection{Polymorphic Method Types}

\subsection{Type Constructors}

\section{Relations Between Types}

\subsection{Type Equivalence}

\subsection{Conformance}

\chapter{Basic Declarations \& Definitions}

\section{Variable Declarations \& Definitions}

\section{Property Declarations \& Definitions}

\section{Instance Variable Definitions}

\section{Type Declarations \& Aliases}

\section{Type Parameters}

\section{Variance of Type Parameters}

\section{Function Declarations \& Definitions}

\subsection{Positional Parameters}

\subsection{Optional Parameters}

\subsection{Repeated Parameters}

\subsection{Named Parameters}

\subsection{Procedures}

\subsection{Method Return Type Inference}

\section{Use Clauses}

\chapter{Classes \& Objects}

\section{Class Definitions}

\subsection{Class Linearization}

\subsection{Constructor \& Destructor Definitions}

\subsection{Class Block}

\subsection{Class Members}

\subsection{Overriding}

\subsection{Inheritance Closure}

\subsection{Modifiers}

\section{Mixins}

\section{Unions}

\section{Enums}

\section{Compound Types}

\section{Range Types}

\section{Units of Measure}

\section{Record Types}

\section{Struct Types}

\section{Object Definitions}

\chapter{Expressions}

\section{Expression Typing}

\section{Literals}

\section{The Nil Value}

\section{Designators}

\section{Self, This \& Super}

\section{Function Applications}

\subsection{Named and Optional Arguments}

\subsection{Input \& Output Arguments}

\subsection{Function Compositions \& Pipelines}

\section{Method Values}

\section{Type Applications}

\section{Tuples}

\section{Instance Creation Expressions}

\section{Blocks}

\section{Prefix \& Infix Operations}

\subsection{Prefix Operations}

\subsection{Infix Operations}

\subsection{Assignment Operators}

\section{Typed Expressions}

\section{Annotated Expressions}

\section{Assignments}

\section{Conditional Expressions}

\section{Loop Expressions}

\subsection{Classic For Expressions}

\subsection{Iterable For Expressions}

\subsection{Basic Loop Expressions}

\subsection{While \& Until Loop Expressions}

\subsection{Conditions in Loop Expressions}

\section{Collection Comprehensions}

\section{Return Expressions}

\subsection{Implicit Return Expressions}

\subsection{Explicit Return Expressions}

\subsection{Structured Return Expressions}

\section{Raise Expressions}

\section{Rescue \& Ensure Expressions}

\section{Throw \& Catch Expressions}

\section{Anonymous Functions}

\section{Conversions}

\subsection{Type Casting}

\chapter{Implicit Parameters \& Views}

\chapter{Pattern Matching}

\section{Patterns}

\subsection{Variable Patterns}

\subsection{Typed Patterns}

\subsection{Literal Patterns}

\subsection{Constructor Patterns}

\subsection{Tuple Patterns}

\subsection{Extractor Patterns}

\subsection{Pattern Alternatives}

\subsection{Regular Expression Patterns}

\section{Type Patterns}

\section{Pattern Matching Expressions}

\section{Pattern Matching Anonymous Functions}

\chapter{Top-Level Definitions}

\section{Compilation Units}

\section{Modules}

\section{Module Objects}

\section{Module References}

\section{Top-Level Classes}

\section{Programs}

\chapter{Annotations}

\chapter{Naming Guidelines}

\chapter{The Coral Standard Library}

\section{Root Classes}

\subsection{The Object Class}

\subsection{The Nothing Class}

\section{Value Classes}

\section{Standard Reference Classes}



















