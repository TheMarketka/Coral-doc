%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\section*{Preface}

Coral is a Ruby-like programming language which enhances advanced object-oriented programming with elements of functional programming. Everything is an object, in this sense it's a pure object-oriented language. Object blueprints are described by classes. Classes can be composed in multiple ways – classic inheritance and/or mixin composition, along with prototype-oriented inheritance.

Coral is also a functional language in the sense that every function is also an object, and generally, everything is a value. Therefore, function definitions can be nested and higher-order functions are supported out-of-the-box. Coral also has a limited support for pattern matching, which can emulate the algebraic types used in other functional languages.

Coral has been developed since 2012 in a home environment out of pure enthusiasm for programming and out of a desire for a truly versatile language. This document is a work in progress and will stay that way forever. It acts as a reference for the language definition and some core library classes.

Some of the languages that had major influence on the development of Coral, including syntax and behavior patterns, are Ruby, Ada, Scala, Java, C\#, F\# and Clojure. Coral tries to inherit their good parts and put them together in its own way.

The vast majority of Coral's syntax is inspired by \emph{Ruby}. Coral uses keyword program parentheses in Ruby fashion. There is \lstinline@class@ \ldots \lstinline@end@, \lstinline@def@ \ldots \lstinline@end@, \lstinline@do@ \ldots \lstinline@end@, \lstinline@loop@ \ldots \lstinline@end@. Ruby itself is inspired by other languages, so this relation is transitive and Coral is inspired by those languages as well (for example, Ada). 

Coral is inspired by \emph{Ada} in the way that user identifiers are formatted: \lstinline@Some_Constant_Name@ and — unlike in Ada, but quite similar to it — \lstinline@some_method_name@. Also, some control structures are inspired by Ada, such as loops, named loops, return expressions and record types. Pretty much like in Ada, Coral's control structures can be usually ended the same way: \lstinline@class@ \ldots \lstinline@end class@ etc. 

\emph{Scala} influenced the type system in Coral. Syntax for existential types comes almost directly from it. However, Coral is a rather dynamically typed language, so the type checks are made eventually in runtime (but some limited type checks can be made during compile time as well). Moreover, the structure of this mere specification is inspired by Scala's specification. 

From \emph{F\#}, Coral borrows some functional syntax (like function composition) and F\# also inspired the feature of~\nameref{sec:unitsofmeasuresyntax}. 

\emph{Clojure} inspired Coral in the way functions can get their names. Coral realizes that turning function names into sentences does not always work, so it is possible to use dashes, plus signs and slashes inside of function names. Therefore, \lstinline@call/cc@ is a legit function identifier. Indeed, binary operators are required to be properly surrounded by whitespace or other non-identifier characters. 

\chapter{Lexical Syntax}

Coral programs are written using the Unicode character set; Unicode supplementary characters are supported as well. Coral programs are preferably encoded with the UTF-8 character encoding. While every Unicode character is supported, usage of Unicode escapes is encouraged, since fonts that IDEs might use may not support the full Unicode character set.

Grammar of lexical tokens is given in the following sections. These tokens are then used as terminal symbols of the semantical grammar. 

\newpage

\section{Identifiers}\label{sec:identifiers}

\syntax\begin{lstlisting}
simple_id   ::= lower [id_rest]
variable_id ::= simple_id | '_'
ivar_id     ::= '@' simple_id
cvar_id     ::= '@@' simple_id
function_id ::= simple_id [id_rest_fun]
constant_id ::= upper [id_rest_con]
id_rest     ::= {letter | digit | '_'}
id_rest_con ::= id_rest [id_rest_mid]
id_rest_fun ::= id_rest [id_rest_mid] ['?' | '!' | '=']
id_rest_mid ::= id_rest {('/' | '+' | '-') id_rest}
\end{lstlisting}

There are three kinds of identifiers.

First, \textit{variable identifiers}, which are simply a lower-case letter followed by arbitrary sequence of letters (any-case), digits and underscores, or just one underscore (which has special meaning). Additionally, \textit{instance variable identifiers} are just prepended with a ``\lstinline|@|'' sign and \textit{class instance variable identifiers} are just prepended with ``\lstinline|@@|''. 

Second, \textit{function identifiers}, which are the most complicated ones. They can start as a variable identifier, then optionally followed by one of ``\lstinline@/@'', ``+'' and ``\lstinline@-@'', and then optionally ended with ``\lstinline@?@'', ``\lstinline@!@'' or ``\lstinline@=@''. Furthermore, function identifiers ending with ``\lstinline@=@'' are never used at call site with this last character, but without it and as a target of an assignment expression (they are naming simple setters). 

And third, \textit{constant identifiers}, which are just like function identifiers, but starting with an upper-case letter, never just an underscore and never ending with ``\lstinline@?@'', ``\lstinline@!@'' or ``\lstinline@=@''.

Coral programs are parsed greedily, so that a longest match rule applies. Letters from the syntax may be any Unicode letters, but English alphabet letters are recommended, along with English names.

\section{Keywords}\label{sec:keywords}

A set of identifiers is reserved for language features instead of for user identifiers. However, unlike in most other languages, keywords are not being recognized inside of paths, except for a few specific cases.

The following names are the reserved words.

\begin{lstlisting}
alias        annotation  as           begin        bitfield
break        case        cast         catch        class
clone        constant    constructor  declare      def
destructor   do          else         elsif        end
ensure       enum        for          for-some     function
goto         if          implements   in           include
interface    is          let          loop         match
memoize      message     method       mixin        module
native       next        nil          no           of
opaque       operator    out          prepend      property
protocol     raise       range        record       redo
refine       rescue      retry        return       self
skip         struct      super        template     test
then         this        throw        transparent  type
undef        unless      until        union        unit-of-measure
use          val         var          void         yes
when         while       with         yield

\end{lstlisting}

Not every reserved word is a keyword in every context, this behavior will be further explained. For example, the bitfield reserved word is only recognized as a keyword inside an enumeration definition context, in a specific place. Every reserved word may be used as a function identifier, with a little work-around when used with an implicit receiver.

\section{Newline Characters}\label{sec:newlinecharacters}

\syntax\begin{lstlisting}

semi ::= nl {nl} | ';'

\end{lstlisting}

Coral is a line-oriented language, in which statements are expressions and may be terminated by newlines, as well as by semi-colon operator. A newline in a Coral source file is treated as the special separator token \lstinline@nl@ if the following criterion is satisfied:

\begin{enumerate}
\item The token immediately preceding the newline can terminate an expression.
\end{enumerate}

Since Coral may be interpreted in a REPL\footnote{Read-Eval-Print Loop} fashion, there are no other suitable criteria. Such a token that can terminate an expression is, for instance, not a binary operator or a message sending operator, which both require further tokens to create an expression. Keywords that expect any following tokens also can not terminate expressions. Coral interpreters and compilers do not look-ahead beyond newlines.

If the token immediately preceding the newline can not terminate an expression and is followed by more than one newline, Coral still sees that as only a one significant newline, to prevent any confusion.

Keywords that can terminate an expression are: \lstinline@break@, \lstinline@end@, \lstinline@opaque@, \lstinline@native@, \lstinline@next@, \lstinline@nil@, \lstinline@no@, \lstinline@redo@, \lstinline@retry@, \lstinline@return@, \lstinline@self@, \lstinline@skip@, \lstinline@super@, \lstinline@this@, \lstinline@transparent@, \lstinline@void@, \lstinline@yes@, \lstinline@yield@.

\section{Operators}\label{sec:operators}

A set of identifiers is reserved for language features, some of which may be overridden by user space implementations. Operators have language-defined precedence rules that are supposed to usually comply to user expectations (principle of least surprise), and another desired precedence may be obtained by putting expressions with operators inside of parenthesis pairs. 

The following character sequences are the operators recognized by Coral. 

\begin{lstlisting}

:=     +=     -=     *=     **=    /=     %=     ||=    &&=    ^^= 
|=     &=     |=     &=     ^=     ~=     <<     >>     <<<    >>> 
<<=    >>=    <<<=   >>>=   ;      =      !=     ==     !==    === 
!===   =~     !~     <>     <      >      <=     >=     <=>    + 
-      *      **     /      div    %      mod    ||     or     && 
and    !      not    ^^     xor    |      &      ^      ~      .. 
...    ,      ->     <-     ~>     <~     =>     ::     :      <: 
:>     <<|    |>>    <|     |>     (      )      [      ]      { 
}      .

\end{lstlisting}

Some of these operators have multiple meanings, usually up to two. Some are binary, some are unary, none is ternary. 

Binary (infix) operators have to be separated by whitespace or non-letter characters on both sides, unary operators on left side – the right side is what they are bound to. 

Unary operators are: \lstinline@+@, \lstinline@-@, \lstinline@&@, \lstinline@not@, \lstinline@!@ and \lstinline@~@. The first three of these are binary as well. The \lstinline@;@ operator is used to separate expressions (see \nameref{sec:newlinecharacters}). Parentheses are postcircumfix operators. Coral has no postfix operators. 

Coral allows for custom user-defined operators, but those have the lowest precedence and need to be parenthesized in order to express any precedence. Such custom operators can't be made of letter characters. 

\section{Literals}\label{sec:literals}

There are literals for numbers (including integer, floating point and complex), characters, booleans, strings, symbols, regular expressions and collections (including tuples, lists, dictionaries and bags). 

\syntax\begin{lstlisting}

literal ::= integer_literal
	| floating_point_literal
	| complex_literal
	| character_literal
	| string_literal
	| symbol_literal
	| regular_expression_literal
	| collection_literal
	| 'nil'

\end{lstlisting}

\subsection{Integer Literals}\label{sec:integerliterals}

\syntax\begin{lstlisting}

integer_literal     ::= ['+' | '-'] (decimal_numeral
	| hexadecimal_numeral
	| octal_numeral
	| binary_numeral)
decimal_numeral     ::= '0' | non_zero_digit {['_'] digit}
hexadecimal_numeral ::= '0x' | hex_digit {['_'] hex_digit}
digit               ::= '0' | non_zero_digit
non_zero_digit      ::= '1' | … | '9'
hex_digit           ::= '1' | … | '9' | 'a' | … | 'f'
octal_numeral       ::= '0' oct_digit {'_' oct_digit}
oct_digit           ::= '0' | … | '7'
binary_numeral      ::= '0b' bin_digit {['_'] bin_digit}
bin_digit           ::= '0' | '1'

\end{lstlisting}

Integers are usually of type \lstinline@Number@, which is a class cluster of all classes that can represent numbers. Unlike Java, Coral supports both signed and unsigned integers directly. Usually integer literals that are obviously unsigned integers are automatically represented internally by a class that stores the integer unsigned, like \lstinline@Integer_64_Unsigned@. Math operations on numbers are handled internally in such a way that the user does't need to worry about the actual types of the numbers — when an integer overflow would occur, the result is stored in a larger container type. 

Underscores used in integer literals have no special meaning, other than to improve readability of larger literals, i.e., to separate thousands.

Integral members of the \lstinline@Number@ class cluster include the following container types. 

\begin{enumerate}

\item \lstinline@Integer_8@ ($-2^{7}$ to $2^{7}-1$), alias \lstinline@Byte@

\item \lstinline@Integer_8_Unsigned@ ($0$ to $2^{8}$), alias \lstinline@Byte_Unsigned@

\item \lstinline@Integer_16@ ($-2^{15}$ to $2^{15}-1$), alias \lstinline@Short@

\item \lstinline@Integer_16_Unsigned@ ($0$ to $2^{16}$), alias \lstinline@Short_Unsigned@

\item \lstinline@Integer_32@ ($-2^{31}$ to $2^{31}-1$)

\item \lstinline@Integer_32_Unsigned@ ($0$ to $2^{32}$)

\item \lstinline@Integer_64@ ($-2^{63}$ to $2^{63}-1$), alias \lstinline@Long@

\item \lstinline@Integer_64_Unsigned@ ($0$ to $2^{64}$), alias \lstinline@Long_Unsigned@

\item \lstinline@Integer_128@ ($-2^{127}$ to $2^{127}-1$), alias \lstinline@Double_Long@

\item \lstinline@Integer_128_Unsigned@ ($0$ to $2^{128}$), alias \lstinline@Double_Long_Unsigned@

\item \lstinline@Decimal@ ($-\infty$ to $\infty$)

\item \lstinline@Decimal_Unsigned@ ($0$ to $\infty$)

\end{enumerate}

The special \lstinline@Decimal@ \& \lstinline@Decimal_Unsigned@ container types are also for storing arbitrary precision floating point numbers. All the container types are constants defined in the \lstinline@Number@ class and can be imported into scope if needed. 

Moreover, a helper type \lstinline@Number::Unsigned@ exists, which can be used for type casting in cases where an originally signed number needs to be treated as unsigned. 

Weak conformance applies to the inner members of \lstinline@Number@ class. 

For use with range types, \lstinline@Number::Integer@ and \lstinline@Number::Integer_Unsigned@ exist, to allow constraining of the range types to integral numbers.

\subsection{Floating Point Literals}\label{sec:floatliterals}

\syntax\begin{lstlisting}

float_literal ::= ['+' | '-'] non_zero_digit 
		{['_'] digit} '.' digit {['_'] digit}
		[exponent_part] [float_type]
	| ['+' | '-'] digit {['_'] digit} exponent_part [float_type]
	| ['+' | '-'] digit {['_'] digit} [exponent_part] [float_type]
	| ['+' | '-'] '0x' hex_digit
		{['_'] hex_digit} '.' hex_digit {['_'] hex_digit}
		[float_type]
	| ['+' | '-'] '0b' bin_digit
		{['_'] bin_digit} '.' bin_digit {['_'] bin_digit}
		[float_type]
exponent_part ::= 'e' ['+' | '-'] digit {['_'] digit}
float_type    ::= 'f' | 'd' | 'q'

\end{lstlisting}

Floating point literals are of type \lstinline@Number@ as well as integral literals, and have fewer container types. Compiler infers the precision automatically, unless the \lstinline@float_type@ part is present. 

\begin{enumerate}

\item \lstinline@Float_32@ (IEEE 754 32-bit precision), alias \lstinline@Float@. 

\item \lstinline@Float_64@ (IEEE 754 64-bit precision), alias \lstinline@Double@.

\item \lstinline@Float_128@ (IEEE 754 128-bit precision).

\item \lstinline@Decimal@ ($-\infty$ to $\infty$).

\item \lstinline@Decimal_Unsigned@ ($0$ to $\infty$).

\end{enumerate}

Letters in the exponent type and float type literals have to be lower-case in Coral sources, but functions that parse floating point numbers do support them being upper-case for compatibility. 

\subsection{Imaginary Number Literals}\label{sec:imaginaryliterals}

\syntax\begin{lstlisting}

imaginary_literal ::= real_number_literal 'i'
complex_literal ::= real_number_literal ('+' | '-') imaginary_literal
	| imaginary_literal ('+' | '-') real_number_literal
real_number_literal ::= integer_literal | float_literal
number_literal ::= real_number_literal
	| imaginary_literal
	| complex_literal

\end{lstlisting}

\subsection{Units of Measure}\label{sec:unitsofmeasuresyntax}

Coral has an addition to number handling, called \textit{units of measure}. Number instances can be annotated with a unit of measure to ensure correctness of arithmetic operations. 

\syntax\begin{lstlisting}

annotated_number ::= number_literal '[<' units_of_measure_expr '>]'

\end{lstlisting}

\subsection{Character Literals}\label{sec:characterliterals}

\syntax\begin{lstlisting}

character_literal ::= '%'' (character | unicode_escape) '''

\end{lstlisting}

\subsection{Boolean Literals}\label{sec:booleanliterals}

\syntax\begin{lstlisting}

boolean_literal ::= 'yes' | 'no'

\end{lstlisting}

Both literals are members of type \lstinline@Boolean@. The \lstinline@no@ literal has also a special behavior when being compared to \lstinline@nil@: \lstinline@no@ equals to \lstinline@nil@, while not actually being \lstinline@nil@. Identity equality is indeed different. The implication is that both \lstinline@nil@ and \lstinline@no@ are false conditions in \lstinline@if@-expressions. 

\subsection{String Literals}\label{sec:stringliterals}

\syntax\begin{lstlisting}

string_literal              ::= simple_string_literal 
                              | interpolable_string_literal
simple_string_literal       ::= ''' {string_element} '''
string_element              ::= printable_char | char_escape_seq
interpolable_string_literal ::= '"' {int_string_element} '"'
int_string_element          ::= string_element | interpolated_expr
interpolated_expr           ::= '#{' expr '}'

\end{lstlisting}

String literals are members of the type \lstinline@String@. Single quotes in simple string literals have to be escaped (\lstinline@\'@) and double quotes in interpolable string literals have to be escaped (\lstinline@\"@). Interpolated expression can be preceded only by an even number of escape characters (backslashes, \lstinline@\@), so that the \lstinline@#@ does't get escaped. This is a special \textit{requirement} for any Coral compiler. 

\subsection{Symbol Literals}\label{sec:symbolliterals}

\syntax\begin{lstlisting}

symbol_literal       ::= simple_symbol | quoted_symbol
simple_symbol        ::= ':' simple_id
quoted_symbol        ::= simple_quoted_symbol | interpolable_symbol
simple_quoted_symbol ::= ':'' {string_element} '''
interpolable_symbol  ::= ':"' {int_string_element} '"'

Symbol literals are members of the type \lstinline@Symbol@. They differ from \nameref{sec:stringliterals} in the way runtime handles them: while there may be multiple instances of the same string, there is always up to one instance of the same symbol. Unlike in Ruby, they do get released from memory when no code references to them anymore, so their object id (sometimes) varies with time. Coral does not require their ids to be constant in time. 

\end{lstlisting}

\subsection{Type Parameters}\label{sec:typeparameterliterals}

\syntax\begin{lstlisting}[mathescape=false]

type_param ::= '$' (simple_id | constant_id)

\end{lstlisting}

Type parameters are not members of any type, rather they stand-in for a real type, like a variable which only holds types. 

\subsection{Regular Expression Literals}\label{sec:regexpliterals}

\syntax\begin{lstlisting}

regexp_literal ::= '%/' regexp_content_int '/' [regexp_flags]
	| '%r/' regexp_content_int '/' [regexp_flags]
	| '%r#' regexp_content '#' [regexp_flags]
	| '%r~' regexp_content_int '~' [regexp_flags]
regexp_content_int ::= regexp_element_int {regexp_element_int}
regexp_element_int ::= string_element | int_string_element
regexp_content ::= string_element {string_element}

\end{lstlisting}

Regular expression literals are members of the type \lstinline@Regular_Expression@ with alias of \lstinline@Regexp@. 

\subsection{Collection Literals}\label{sec:collectionliterals}

Collection literals are paired syntax tokens and as such, they are a kind of parentheses in Coral sources. 

\syntax\begin{lstlisting}

collection_literal ::= tuple_literal
	| list_literal
	| dictionary_literal
	| bag_literal
tuple_literal ::= '(' exprs ')'
list_literal ::= '%' collection_flags '[' exprs ']'
dictionary_literal ::= '%' collection_flags '{' dict_exprs '}'
bag_literal ::= '%' collection_flags '(' exprs ')'
exprs ::= expr {',' expr}
dict_exprs ::= dict_expr {',' dict_expr}
dict_expr ::= expr '=>' expr
	| simple_id ':' expr
collection_flags ::= printable_char {printable_char}

\end{lstlisting}

Tuple literals are members of the \lstinline@Tuple@ type family. List literals are members of the \lstinline@List@ type, usually \lstinline@Array_List@ with alias of \lstinline@Array@. Dictionary literals are members of the \lstinline@Dictionary@ type with alias of \lstinline@Map@, usually \lstinline@Hash_Dictionary@ with alias of \lstinline@Hash_Map@. Bag literals are members of the \lstinline@Bag@ type, usually \lstinline@Hash_Bag@ or \lstinline@Hash_Set@. Collection flags may change the actual class of the literal, along with some other properties, described in the following text. 

List literal collection flags: 

\begin{enumerate}
\item Flag \lstinline@i@ = \textbf{i}mmutable, makes the list frozen. 
\item Flag \lstinline@l@ = \textbf{l}inked, makes the list a member of \lstinline@Linked_List@. 
\item Flag \lstinline@w@ = \textbf{w}ords, the following expressions are treated as words, converted to strings for each word separated by whitespace. 
\end{enumerate}

Dictionary literals collection flags:

\begin{enumerate}
\item Flag \lstinline@i@ = \textbf{i}mmutable, makes the dictionary frozen. 
\item Flag \lstinline@l@ = \textbf{l}inked, makes the dictionary a member of \lstinline@Linked_Hash_Dictionary@ (also has alias \lstinline@Linked_Hash_Map@).
\item Flag \lstinline@m@ = \textbf{m}ulti-map, the dictionary items are then either the items themselves, if there is only one for a particular key, or a set of items, if there is more than one item for a particular key. The dictionary is then a member of \lstinline@Multi_Hash_Dictionary@ (alias \lstinline@Multi_Hash_Map@) or \lstinline@Linked_Multi_Hash_Dictionary@ (alias \lstinline@Linked_Multi_Hash_Map@). 
\end{enumerate}

Bag literal collection flags:

\begin{enumerate}
\item Flag \lstinline@i@ = \textbf{i}mmutable, makes the bag frozen. 
\item Flag \lstinline@s@ = \textbf{s}et, the collection is a set instead of a bag (a specific bag, such that for each item, its tally is always $0$ or $1$, thus each item is in the collection up to once). 
\item Flag \lstinline@l@ = \textbf{l}inked, makes the collection linked, so either a member of \lstinline@Linked_Hash_Bag@ in case of a regular bag, or \lstinline@Linked_Hash_Set@ in case of a set. 
\end{enumerate}

Linked collections have a predictable iteration order in case of bags and dictionaries, or are simply stored differently in case of lists.  

\section{Whitespace \& Comments}\label{sec:whitespacecomments}

Tokens may be separated by whitespace characters and/or comments. Comments come in two forms: 

A single-line comment is a sequence of characters that starts with \lstinline@//@ and extends to the end of the line. 

A multi-line comment is a sequence of characters between \lstinline@/*@ and \lstinline@*/@. Multi-line comments may be nested. 

Documentation comments are multi-line comments that start with \lstinline@/*!@. 

\section{Preprocessor Macros}\label{sec:preprocessormacros}

\emph{TBD}

\chapter{Identifiers, Names \& Scopes}

Names in Coral identify various types, values, methods and constants, which are the \emph{entities}. Names are introduced by local definitions and declarations, inheritance, use clauses or module clauses, which are the \emph{bindings}. 

Bindings of different kinds have a different precedence defined on them: 

\begin{enumerate}
\item Definitions and declarations that are local have the highest precedence. 
\item Explicit \lstinline@use@ clauses (imports) have the next highest precedence.\footnote{Explicit imports have such high precedence in order to allow binding of different names than those that would be otherwise inherited.} 
\item Inherited definitions and declarations have the next highest precedence. 
\item Definitions and declarations made available by module clause have the next highest precedence. 
\item Definitions and declarations that are not in the same compilation unit (a different script or a different module) have the next highest precedence. 
\item Definitions and declarations that are not bound have the lowest precedence. This happens when the binding simply can't be found anywhere, and probably will result in a name error (if not resolved dynamically), while being inferred to be of type \lstinline@Object@. 
\end{enumerate}

There is only one root name space, in which a single fully-qualified binding designates always up to one entity. 

Every binding has a \emph{scope} in which the bound entity can be referenced using a simple name (unqualified). Scopes are nested, inner scopes inherit the same bindings, unless shadowed. A binding in an inner scope \emph{shadows} bindings of lower precedence in the same scope (and nested scopes) as well as bindings of the same or lower precedence in outer scopes. Shadowing is a partial order, and bindings can become ambiguous -- fully qualified names can be used to resolve binding conflicts. This restriction is checked in limited scope during compilation\footnote{This is due to the hybrid typing system in Coral, to make use of all the available information as soon as possible.} and fully in runtime. 

If at any point of the program execution a binding would change (ie., by introducing a new type in a superclass that is closer in the inheritance tree to the actual class than the previous binding), and such a change would be incompatible with the previous binding, then a warning\footnote{TBD -- shouldn't that be an error?} will be issued by the runtime. Also, if a new binding would be ambiguous\footnote{Coral runtime actually checks for bindings until the binding-candidate would not be able to shadow the already found binding-candidates and caches the result.}, then it is an error. 

As shadowing is only a partial order, in a situation like

\begin{lstlisting}
var x := 1
use p::x
x
\end{lstlisting}

neither binding of $x$ shadows the other. Consequently, the reference to $x$ on the third line above is ambiguous and the compiler will happily refuse to proceed. 

A reference to an unqualified identifier $x$ is bound by a unique binding, which

\begin{enumerate}
\item defines an entity with name $x$ in the same scope as the identifier $x$, and
\item shadows all other bindings that define entities with name $x$ in that name scope.
\end{enumerate}

It is syntactically not an error if no such binding exists, thanks to the dynamic features of the language (unbound references are implicitly bound to the same scope and are resolved by dynamic method callbacks). The same applies to fully qualified bindings that don't resolve into any entity. However, it is an error if a binding is ambiguous or fails to get resolved dynamically.

If $x$ is bound by explicit \lstinline@use@ import clause, then the simple name $x$ is consided to be equivalent to the fully-qualified name to which $x$ is mapped by the import clause. If $x$ is bound by a definition or declaration, then $x$ refers to the entity introduced by that binding, thus the type of $x$ is the type of the referenced entity. 

\chapter{Types}


\section{Value Types}

\subsection{Value Type}

\subsection{Type Projection}

\subsection{Type Designators}

\subsection{Parametrized Types}

\subsection{Tuple Types}

\subsection{Annotated Types}

\subsection{Compound Types}

\subsection{Function Types}

\subsection{Existential Types}

\section{Non-Value Types}

\subsection{Method Types}

\subsection{Polymorphic Method Types}

\subsection{Type Constructors}

\section{Relations Between Types}

\subsection{Type Equivalence}

\subsection{Conformance}

\chapter{Basic Declarations \& Definitions}

\section{Variable Declarations \& Definitions}

\section{Property Declarations \& Definitions}

\section{Instance Variable Definitions}

\section{Type Declarations \& Aliases}

\section{Type Parameters}

\section{Variance of Type Parameters}

\section{Function Declarations \& Definitions}

\subsection{Positional Parameters}

\subsection{Optional Parameters}

\subsection{Repeated Parameters}

\subsection{Named Parameters}

\subsection{Procedures}

\subsection{Method Return Type Inference}

\section{Use Clauses}

\chapter{Classes \& Objects}

\section{Class Definitions}

\subsection{Class Linearization}

\subsection{Constructor \& Destructor Definitions}

\subsection{Class Block}

\subsection{Class Members}

\subsection{Overriding}

\subsection{Inheritance Closure}

\subsection{Modifiers}

\section{Mixins}

\section{Unions}

\section{Enums}

\section{Compound Types}

\section{Range Types}

\section{Units of Measure}

\section{Record Types}

\section{Struct Types}

\section{Object Definitions}

\chapter{Expressions}

\section{Expression Typing}

\section{Literals}

\section{The Nil Value}

\section{Designators}

\section{Self, This \& Super}

\section{Function Applications}

\subsection{Named and Optional Arguments}

\subsection{Input \& Output Arguments}

\subsection{Function Compositions \& Pipelines}

\section{Method Values}

\section{Type Applications}

\section{Tuples}

\section{Instance Creation Expressions}

\section{Blocks}

\section{Prefix \& Infix Operations}

\subsection{Prefix Operations}

\subsection{Infix Operations}

\subsection{Assignment Operators}

\section{Typed Expressions}

\section{Annotated Expressions}

\section{Assignments}

\section{Conditional Expressions}

\section{Loop Expressions}

\subsection{Classic For Expressions}

\subsection{Iterable For Expressions}

\subsection{Basic Loop Expressions}

\subsection{While \& Until Loop Expressions}

\subsection{Conditions in Loop Expressions}

\section{Collection Comprehensions}

\section{Return Expressions}

\subsection{Implicit Return Expressions}

\subsection{Explicit Return Expressions}

\subsection{Structured Return Expressions}

\section{Raise Expressions}

\section{Rescue \& Ensure Expressions}

\section{Throw \& Catch Expressions}

\section{Anonymous Functions}

\section{Conversions}

\subsection{Type Casting}

\chapter{Implicit Parameters \& Views}

\chapter{Pattern Matching}

\section{Patterns}

\subsection{Variable Patterns}

\subsection{Typed Patterns}

\subsection{Literal Patterns}

\subsection{Constructor Patterns}

\subsection{Tuple Patterns}

\subsection{Extractor Patterns}

\subsection{Pattern Alternatives}

\subsection{Regular Expression Patterns}

\section{Type Patterns}

\section{Pattern Matching Expressions}

\section{Pattern Matching Anonymous Functions}

\chapter{Top-Level Definitions}

\section{Compilation Units}

\section{Modules}

\section{Module Objects}

\section{Module References}

\section{Top-Level Classes}

\section{Programs}

\chapter{Annotations}

\chapter{Naming Guidelines}

\chapter{The Coral Standard Library}

\section{Root Classes}

\subsection{The Object Class}

\subsection{The Nothing Class}

\section{Value Classes}

\section{Standard Reference Classes}



















