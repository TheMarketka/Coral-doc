%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\section*{Preface}

Coral is a Ruby-like programming language which enhances advanced object-oriented programming with elements of functional programming. Every value is an object, in this sense it is a pure object-oriented language. Object blueprints are described by classes. Classes can be composed in multiple ways â€“ classic inheritance and/or mixin composition, along with prototype-oriented inheritance.

Coral is also a functional language in the sense that every function is also an object. Therefore, function definitions can be nested and higher-order functions are supported out-of-the-box. Coral also has a limited support for pattern matching, which can emulate the algebraic types used in other functional languages.

Coral has been developed from 2012 in a home environment out of pure enthusiasm for programming and out of a desire for a truly versatile language. This document is a work in progress and will stay that way forever. It acts as a reference for the language definition and some core library classes.

Some of the languages that had major influence on the development of Coral, including syntax and behavior patterns, are Ruby, Ada, Scala, Java, C\# and F\#. Coral tries to inherit their good parts and put them together in its own way.

\chapter{Lexical Syntax}

Coral programs are written using the Unicode character set; Unicode supplementary characters are supported as well. Coral programs are preferably encoded with the UTF-8 character encoding. While every Unicode character is supported, usage of Unicode escapes is encouraged, since fonts that IDEs might use may not support the full Unicode character set.

\newpage

\section{Identifiers}\label{sec:identifiers}

\section{Keywords}\label{sec:keywords}

\section{Newline Characters}\label{sec:newlinecharacters}

\section{Operators}\label{sec:operators}

\section{Literals}\label{sec:literals}

\subsection{Integer Literals}\label{sec:integerliterals}

\subsection{Floating Point Literals}\label{sec:floatliterals}

\subsection{Imaginary Number Literals}\label{sec:imaginaryliterals}

\subsection{Units of Measure}

\subsection{Boolean Literals}\label{sec:booleanliterals}

\subsection{String Literals}\label{sec:stringliterals}

\subsection{Symbol Literals}\label{sec:symbolliterals}

\subsection{Type Parameters}\label{sec:typeparameterliterals}

\subsection{Regular Expression Literals}\label{sec:regexpliterals}

\subsection{Collection Literals}\label{sec:collectionliterals}

\section{Whitespace \& Comments}\label{sec:whitespacecomments}

\section{Preprocessor Macros}\label{sec:preprocessormacros}

\chapter{Identifiers, Names \& Scopes}

\chapter{Types}

\section{Paths}

\section{Value Types}

\subsection{Value Type}

\subsection{Type Projection}

\subsection{Type Designators}

\subsection{Parametrized Types}

\subsection{Tuple Types}

\subsection{Annotated Types}

\subsection{Compound Types}

\subsection{Function Types}

\subsection{Existential Types}

\section{Non-Value Types}

\subsection{Method Types}

\subsection{Polymorphic Method Types}

\subsection{Type Constructors}

\section{Relations Between Types}

\subsection{Type Equivalence}

\subsection{Conformance}

\chapter{Basic Declarations \& Definitions}

\section{Variable Declarations \& Definitions}

\section{Property Declarations \& Definitions}

\section{Instance Variable Definitions}

\section{Type Declarations \& Aliases}

\section{Type Parameters}

\section{Variance of Type Parameters}

\section{Function Declarations \& Definitions}

\subsection{Positional Parameters}

\subsection{Optional Parameters}

\subsection{Repeated Parameters}

\subsection{Named Parameters}

\subsection{Procedures}

\subsection{Method Return Type Inference}

\section{Use Clauses}

\chapter{Classes \& Objects}

\section{Class Definitions}

\subsection{Class Linearization}

\subsection{Constructor \& Destructor Definitions}

\subsection{Class Block}

\subsection{Class Members}

\subsection{Overriding}

\subsection{Inheritance Closure}

\subsection{Modifiers}

\section{Mixins}

\section{Unions}

\section{Enums}

\section{Compound Types}

\section{Range Types}

\section{Units of Measure}

\section{Record Types}

\section{Struct Types}

\section{Object Definitions}

\chapter{Expressions}

\section{Expression Typing}

\section{Literals}

\section{The Nil Value}

\section{Designators}

\section{Self, This \& Super}

\section{Function Applications}

\subsection{Named and Optional Arguments}

\subsection{Input \& Output Arguments}

\subsection{Function Compositions \& Pipelines}

\section{Method Values}

\section{Type Applications}

\section{Tuples}

\section{Instance Creation Expressions}

\section{Blocks}

\section{Prefix \& Infix Operations}

\subsection{Prefix Operations}

\subsection{Infix Operations}

\subsection{Assignment Operators}

\section{Typed Expressions}

\section{Annotated Expressions}

\section{Assignments}

\section{Conditional Expressions}

\section{Loop Expressions}

\subsection{Classic For Expressions}

\subsection{Iterable For Expressions}

\subsection{Basic Loop Expressions}

\subsection{While \& Until Loop Expressions}

\subsection{Conditions in Loop Expressions}

\section{Collection Comprehensions}

\section{Return Expressions}

\subsection{Implicit Return Expressions}

\subsection{Explicit Return Expressions}

\subsection{Structured Return Expressions}

\section{Raise Expressions}

\section{Rescue \& Ensure Expressions}

\section{Throw \& Catch Expressions}

\section{Anonymous Functions}

\section{Conversions}

\subsection{Type Casting}

\chapter{Implicit Parameters \& Views}

\chapter{Pattern Matching}

\section{Patterns}

\subsection{Variable Patterns}

\subsection{Typed Patterns}

\subsection{Literal Patterns}

\subsection{Constructor Patterns}

\subsection{Tuple Patterns}

\subsection{Extractor Patterns}

\subsection{Pattern Alternatives}

\subsection{Regular Expression Patterns}

\section{Type Patterns}

\section{Pattern Matching Expressions}

\section{Pattern Matching Anonymous Functions}

\chapter{Top-Level Definitions}

\section{Compilation Units}

\section{Modules}

\section{Module Objects}

\section{Module References}

\section{Top-Level Classes}

\section{Programs}

\chapter{Annotations}

\chapter{Naming Guidelines}

\chapter{The Coral Standard Library}

\section{Root Classes}

\subsection{The Object Class}

\subsection{The Nothing Class}

\section{Value Classes}

\section{Standard Reference Classes}



















