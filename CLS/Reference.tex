%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\section*{Preface}

Coral is a Ruby-like programming language which enhances advanced object-oriented programming with elements of functional programming. Every value is an object, in this sense it is a pure object-oriented language. Object blueprints are described by classes. Classes can be composed in multiple ways â€“ classic inheritance and/or mixin composition, along with prototype-oriented inheritance.

Coral is also a functional language in the sense that every function is also an object. Therefore, function definitions can be nested and higher-order functions are supported out-of-the-box. Coral also has a limited support for pattern matching, which can emulate the algebraic types used in other functional languages.

Coral has been developed from 2012 in a home environment out of pure enthusiasm for programming and out of a desire for a truly versatile language. This document is a work in progress and will stay that way forever. It acts as a reference for the language definition and some core library classes.

Some of the languages that had major influence on the development of Coral, including syntax and behavior patterns, are Ruby, Ada, Scala, Java, C\# and F\#. Coral tries to inherit their good parts and put them together in its own way.

\chapter{Lexical Syntax}

Coral programs are written using the Unicode character set; Unicode supplementary characters are supported as well. Coral programs are preferably encoded with the UTF-8 character encoding. While every Unicode character is supported, usage of Unicode escapes is encouraged, since fonts that IDEs might use may not support the full Unicode character set.

\newpage

\section{Identifiers}\label{sec:identifiers}

\syntax\begin{lstlisting}
simple_id   ::= lower [id_rest]
variable_id ::= simple_id | '_'
constant_id ::= upper [id_rest]
function_id ::= simple_id [id_rest_ext]
id_rest     ::= {letter | digit | '_'}
id_rest_ext ::= id_rest [id_rest_mid] ['?' | '!' | '=']
id_rest_mid ::= id_rest {('/' | '+' | '-') id_rest}
\end{lstlisting}

There are three kinds of identifiers.
First, \textit{variable identifiers}, which are simply a lower-case letter followed by arbitrary sequence of letters (any-case), digits and underscores, or just one underscore (which has special meaning).
Second, \textit{constant identifiers}, which are just like variable identifiers, but starting with an upper-case letter and never just an underscore.
And third, \textit{function identifiers}, which are the most complicated ones. They can start as a variable identifier, then optionally followed by one of ``/'', ``+'' and ``-'', and then optionally ended with ``?'' or ``!''.

Coral programs are parsed greedily, so that a longest match rule applies. Letters from the syntax may be any Unicode letters, but English alphabet letters are recommended, along with English names.

\section{Keywords}\label{sec:keywords}

A set of identifiers is reserved for language features instead of for user identifiers. However, unlike in most other languages, keywords are not being recognized inside of paths, except for a few specific cases.

The following names are the reserved words.

\begin{lstlisting}
alias        annotation  as           begin        bitfield
break        case        cast         catch        class
clone        constant    constructor  declare      def
destructor   do          else         elsif        end
ensure       enum        for          for-some     function
goto         if          implements   in           include
interface    is          let          loop         match
memoize      message     method       mixin        module
native       next        nil          no           of
opaque       operator    out          prepend      property
protocol     raise       range        record       redo
refine       rescue      retry        return       self
skip         struct      super        template     test
then         this        throw        transparent  type
undef        unless      until        union        unit-of-measure
use          val         var          void         yes
when         while       with         yield

\end{lstlisting}

Not every reserved word is a keyword in every context, this behavior will be further explained. For example, the bitfield reserved word is only recognized as a keyword inside an enumeration definition context, in a specific place. Every reserved word may be used as a function identifier, with a little work-around when used with an implicit receiver.

\section{Newline Characters}\label{sec:newlinecharacters}

\syntax\begin{lstlisting}

semi ::= nl {nl} | ';'

\end{lstlisting}

Coral is a line-oriented language, in which statements are expressions and may be terminated by newlines, as well as by semi-colon operator. A newline in a Coral source file is treated as the special separator token \lstinline@nl@ if the following criterion is satisfied:

\begin{enumerate}
\item The token immediately preceding the newline can terminate an expression.
\end{enumerate}

Since Coral may be interpreted in a REPL\footnote{Read-Eval-Print Loop} fashion, there are no other suitable criteria. Such a token that can terminate an expression is, for instance, not a binary operator or a message sending operator, which both require further tokens to create an expression. Keywords that expect any following tokens also can not terminate expressions. Coral interpreters and compilers do not look-ahead beyond newlines.

If the token immediately preceding the newline can not terminate an expression and is followed by more than one newline, Coral still sees that as only a one significant newline, to prevent any confusion.

Keywords that can terminate an expression are: \lstinline@break@, \lstinline@end@, \lstinline@opaque@, \lstinline@native@, \lstinline@next@, \lstinline@nil@, \lstinline@no@, \lstinline@redo@, \lstinline@retry@, \lstinline@return@, \lstinline@self@, \lstinline@skip@, \lstinline@super@, \lstinline@this@, \lstinline@transparent@, \lstinline@void@, \lstinline@yes@, \lstinline@yield@.

\section{Operators}\label{sec:operators}

\section{Literals}\label{sec:literals}

\subsection{Integer Literals}\label{sec:integerliterals}

\subsection{Floating Point Literals}\label{sec:floatliterals}

\subsection{Imaginary Number Literals}\label{sec:imaginaryliterals}

\subsection{Units of Measure}

\subsection{Boolean Literals}\label{sec:booleanliterals}

\subsection{String Literals}\label{sec:stringliterals}

\subsection{Symbol Literals}\label{sec:symbolliterals}

\subsection{Type Parameters}\label{sec:typeparameterliterals}

\subsection{Regular Expression Literals}\label{sec:regexpliterals}

\subsection{Collection Literals}\label{sec:collectionliterals}

\section{Whitespace \& Comments}\label{sec:whitespacecomments}

\section{Preprocessor Macros}\label{sec:preprocessormacros}

\chapter{Identifiers, Names \& Scopes}

\chapter{Types}

\section{Paths}

\section{Value Types}

\subsection{Value Type}

\subsection{Type Projection}

\subsection{Type Designators}

\subsection{Parametrized Types}

\subsection{Tuple Types}

\subsection{Annotated Types}

\subsection{Compound Types}

\subsection{Function Types}

\subsection{Existential Types}

\section{Non-Value Types}

\subsection{Method Types}

\subsection{Polymorphic Method Types}

\subsection{Type Constructors}

\section{Relations Between Types}

\subsection{Type Equivalence}

\subsection{Conformance}

\chapter{Basic Declarations \& Definitions}

\section{Variable Declarations \& Definitions}

\section{Property Declarations \& Definitions}

\section{Instance Variable Definitions}

\section{Type Declarations \& Aliases}

\section{Type Parameters}

\section{Variance of Type Parameters}

\section{Function Declarations \& Definitions}

\subsection{Positional Parameters}

\subsection{Optional Parameters}

\subsection{Repeated Parameters}

\subsection{Named Parameters}

\subsection{Procedures}

\subsection{Method Return Type Inference}

\section{Use Clauses}

\chapter{Classes \& Objects}

\section{Class Definitions}

\subsection{Class Linearization}

\subsection{Constructor \& Destructor Definitions}

\subsection{Class Block}

\subsection{Class Members}

\subsection{Overriding}

\subsection{Inheritance Closure}

\subsection{Modifiers}

\section{Mixins}

\section{Unions}

\section{Enums}

\section{Compound Types}

\section{Range Types}

\section{Units of Measure}

\section{Record Types}

\section{Struct Types}

\section{Object Definitions}

\chapter{Expressions}

\section{Expression Typing}

\section{Literals}

\section{The Nil Value}

\section{Designators}

\section{Self, This \& Super}

\section{Function Applications}

\subsection{Named and Optional Arguments}

\subsection{Input \& Output Arguments}

\subsection{Function Compositions \& Pipelines}

\section{Method Values}

\section{Type Applications}

\section{Tuples}

\section{Instance Creation Expressions}

\section{Blocks}

\section{Prefix \& Infix Operations}

\subsection{Prefix Operations}

\subsection{Infix Operations}

\subsection{Assignment Operators}

\section{Typed Expressions}

\section{Annotated Expressions}

\section{Assignments}

\section{Conditional Expressions}

\section{Loop Expressions}

\subsection{Classic For Expressions}

\subsection{Iterable For Expressions}

\subsection{Basic Loop Expressions}

\subsection{While \& Until Loop Expressions}

\subsection{Conditions in Loop Expressions}

\section{Collection Comprehensions}

\section{Return Expressions}

\subsection{Implicit Return Expressions}

\subsection{Explicit Return Expressions}

\subsection{Structured Return Expressions}

\section{Raise Expressions}

\section{Rescue \& Ensure Expressions}

\section{Throw \& Catch Expressions}

\section{Anonymous Functions}

\section{Conversions}

\subsection{Type Casting}

\chapter{Implicit Parameters \& Views}

\chapter{Pattern Matching}

\section{Patterns}

\subsection{Variable Patterns}

\subsection{Typed Patterns}

\subsection{Literal Patterns}

\subsection{Constructor Patterns}

\subsection{Tuple Patterns}

\subsection{Extractor Patterns}

\subsection{Pattern Alternatives}

\subsection{Regular Expression Patterns}

\section{Type Patterns}

\section{Pattern Matching Expressions}

\section{Pattern Matching Anonymous Functions}

\chapter{Top-Level Definitions}

\section{Compilation Units}

\section{Modules}

\section{Module Objects}

\section{Module References}

\section{Top-Level Classes}

\section{Programs}

\chapter{Annotations}

\chapter{Naming Guidelines}

\chapter{The Coral Standard Library}

\section{Root Classes}

\subsection{The Object Class}

\subsection{The Nothing Class}

\section{Value Classes}

\section{Standard Reference Classes}



















