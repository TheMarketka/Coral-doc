%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\section*{Preface}

Coral is a Ruby-like programming language which enhances advanced object-oriented programming with elements of functional programming. Everything is an object, in this sense it's a pure object-oriented language. Object blueprints are described by classes. Classes can be composed in multiple ways – classic inheritance and/or mixin composition, along with prototype-oriented inheritance.

Coral is also a functional language in the sense that every function is also an object, and generally, everything is a value. Therefore, function definitions can be nested and higher-order functions are supported out-of-the-box. Coral also has a limited support for pattern matching, which can emulate the algebraic types used in other functional languages.

Coral has been developed since 2012 in a home environment out of pure enthusiasm for programming and out of a desire for a truly versatile language. This document is a work in progress and will stay that way forever. It acts as a reference for the language definition and some core library classes.

Some of the languages that had major influence on the development of Coral, including syntax and behavior patterns, are Ruby, Ada, Scala, Java, C\#, F\# and Clojure. Coral tries to inherit their good parts and put them together in its own way.

The vast majority of Coral's syntax is inspired by \emph{Ruby}. Coral uses keyword program parentheses in Ruby fashion. There is \lstinline@class@ \ldots \lstinline@end@, \lstinline@def@ \ldots \lstinline@end@, \lstinline@do@ \ldots \lstinline@end@, \lstinline@loop@ \ldots \lstinline@end@. Ruby itself is inspired by other languages, so this relation is transitive and Coral is inspired by those languages as well (for example, Ada). 

Coral is inspired by \emph{Ada} in the way that user identifiers are formatted: \lstinline@Some_Constant_Name@ and — unlike in Ada, but quite similar to it — \lstinline@some_method_name@. Also, some control structures are inspired by Ada, such as loops, named loops, return expressions and record types. Pretty much like in Ada, Coral's control structures can be usually ended the same way: \lstinline@class@ \ldots \lstinline@end class@ etc. 

\emph{Scala} influenced the type system in Coral. Syntax for existential types comes almost directly from it. However, Coral is a rather dynamically typed language, so the type checks are made eventually in runtime (but some limited type checks can be made during compile time as well). Moreover, the structure of this mere specification is inspired by Scala's specification. 

From \emph{F\#}, Coral borrows some functional syntax (like function composition) and F\# also inspired the feature of~\nameref{sec:unitsofmeasuresyntax}. 

\emph{Clojure} inspired Coral in the way functions can get their names. Coral realizes that turning function names into sentences does not always work, so it is possible to use dashes, plus signs and slashes inside of function names. Therefore, \lstinline@call/cc@ is a legit function identifier. Indeed, binary operators are required to be properly surrounded by whitespace or other non-identifier characters. 

\chapter{Lexical Syntax}

Coral programs are written using the Unicode character set; Unicode supplementary characters are supported as well. Coral programs are preferably encoded with the UTF-8 character encoding. While every Unicode character is supported, usage of Unicode escapes is encouraged, since fonts that IDEs might use may not support the full Unicode character set.

Grammar of lexical tokens is given in the following sections. These tokens are then used as terminal symbols of the semantical grammar. 

\newpage

\section{Identifiers}\label{sec:identifiers}

\syntax\begin{lstlisting}
simple_id   ::= (lower | '_') [id_rest]
variable_id ::= simple_id | '_'
ivar_id     ::= '@' simple_id
cvar_id     ::= '@@' simple_id
function_id ::= simple_id [id_rest_fun]
constant_id ::= upper [id_rest_con]
id_rest     ::= {letter | digit | '_'}
id_rest_con ::= id_rest [id_rest_mid]
id_rest_fun ::= id_rest [id_rest_mid] ['?' | '!' | '=']
id_rest_mid ::= id_rest {('/' | '+' | '-') id_rest}
\end{lstlisting}

There are three kinds of identifiers.

First, \textit{variable identifiers}, which are simply a lower-case letter followed by arbitrary sequence of letters (any-case), digits and underscores, or just one underscore (which has special meaning). Additionally, \textit{instance variable identifiers} are just prepended with a ``\lstinline|@|'' sign and \textit{class instance variable identifiers} are just prepended with ``\lstinline|@@|''. 

Second, \textit{function identifiers}, which are the most complicated ones. They can start as a variable identifier, then optionally followed by one of ``\lstinline@/@'', ``+'' and ``\lstinline@-@'', and then optionally ended with ``\lstinline@?@'', ``\lstinline@!@'' or ``\lstinline@=@''. Furthermore, function identifiers ending with ``\lstinline@=@'' are never used at call site with this last character, but without it and as a target of an assignment expression (they are naming simple setters). 

And third, \textit{constant identifiers}, which are just like function identifiers, but starting with an upper-case letter, never just an underscore and never ending with ``\lstinline@?@'', ``\lstinline@!@'' or ``\lstinline@=@''.

Coral programs are parsed greedily, so that a longest match rule applies. Letters from the syntax may be any Unicode letters, but English alphabet letters are recommended, along with English names.

\section{Keywords}\label{sec:keywords}

A set of identifiers is reserved for language features instead of for user identifiers. However, unlike in most other languages, keywords are not being recognized inside of paths, except for a few specific cases.

The following names are the reserved words.

\begin{lstlisting}
alias        annotation  as           begin        bitfield
break        case        cast         catch        class
clone        constant    constructor  declare      def
destructor   do          else         elsif        end
ensure       enum        for          for-some     function
goto         if          implements   in           include
interface    is          lazy         let          loop
match        memoize     message      method       mixin
module       native      next         nil          no           
of           opaque      operator     out          prepend
property     protocol    raise        range        record
redo         refine      rescue       retry        return
self         skip        struct       super        template
test         then        this         throw        transparent
type         undef       unless       until        union
unit-of-measure          use          val          var
yes          when        while        with         yield
\end{lstlisting}

Not every reserved word is a keyword in every context, this behavior will be further explained. For example, the bitfield reserved word is only recognized as a keyword inside an enumeration definition context, in a specific place. Every reserved word may be used as a function identifier, with a little work-around when used with an implicit receiver.

\section{Newline Characters}\label{sec:newlinecharacters}

\syntax\begin{lstlisting}
semi ::= nl {nl} | ';'
\end{lstlisting}

Coral is a line-oriented language, in which statements are expressions and may be terminated by newlines, as well as by semi-colon operator. A newline in a Coral source file is treated as the special separator token \lstinline@nl@ if the following criterion is satisfied:

\begin{enumerate}
\item The token immediately preceding the newline can terminate an expression.
\end{enumerate}

Since Coral may be interpreted in a REPL\footnote{Read-Eval-Print Loop} fashion, there are no other suitable criteria. Such a token that can terminate an expression is, for instance, not a binary operator or a message sending operator, which both require further tokens to create an expression. Keywords that expect any following tokens also can not terminate expressions. Coral interpreters and compilers do not look-ahead beyond newlines.

If the token immediately preceding the newline can not terminate an expression and is followed by more than one newline, Coral still sees that as only a one significant newline, to prevent any confusion.

Keywords that can terminate an expression are: \lstinline@break@, \lstinline@end@, \lstinline@opaque@, \lstinline@native@, \lstinline@next@, \lstinline@nil@, \lstinline@no@, \lstinline@redo@, \lstinline@retry@, \lstinline@return@, \lstinline@self@, \lstinline@skip@, \lstinline@super@, \lstinline@this@, \lstinline@transparent@, \lstinline@yes@, \lstinline@yield@.

\section{Operators}\label{sec:operators}

A set of identifiers is reserved for language features, some of which may be overridden by user space implementations. Operators have language-defined precedence rules that are supposed to usually comply to user expectations (principle of least surprise), and another desired precedence may be obtained by putting expressions with operators inside of parenthesis pairs. 

The following character sequences are the operators recognized by Coral. 

\begin{lstlisting}
:=     +=     -=     *=     **=    /=     %=     ||=    &&=    ^^= 
|=     &=     |=     :[     ^=     ~=     <<     >>     <<<    >>> 
<<=    >>=    <<<=   >>>=   ;      =      !=     ==     !==    === 
!===   =~     !~     <>     <      >      <=     >=     <=>    + 
-      *      **     /      div    %      mod    ||     or     && 
and    !      not    ^^     xor    |      &      ^      ~      .. 
...    ,      ->     <-     ~>     <~     =>     ::     :      <: 
:>     <<|    |>>    <|     |>     (      )      [      ]      { 
}      .      [<     >]     >:     .?     .!
\end{lstlisting}

Some of these operators have multiple meanings, usually up to two. Some are binary, some are unary, none is ternary. 

Binary (infix) operators have to be separated by whitespace or non-letter characters on both sides, unary operators on left side – the right side is what they are bound to. 

Unary operators are: \lstinline@+@, \lstinline@-@, \lstinline@&@, \lstinline@not@, \lstinline@!@ and \lstinline@~@. The first three of these are binary as well. The \lstinline@;@ operator is used to separate expressions (see \nameref{sec:newlinecharacters}). Parentheses are postcircumfix operators. Coral has no postfix operators. 

Coral allows for custom user-defined operators, but those have the lowest precedence and need to be parenthesized in order to express any precedence. Such custom operators can't be made of letter characters. 

\section{Literals}\label{sec:literals}

There are literals for numbers (including integer, floating point and complex), characters, booleans, strings, symbols, regular expressions and collections (including tuples, lists, dictionaries and bags). 

\syntax\begin{lstlisting}
literal ::= integer_literal
	| floating_point_literal
	| complex_literal
	| character_literal
	| string_literal
	| symbol_literal
	| regular_expression_literal
	| collection_literal
	| 'nil'
\end{lstlisting}

\subsection{Integer Literals}\label{sec:integerliterals}

\syntax\begin{lstlisting}
integer_literal     ::= ['+' | '-'] (decimal_numeral
	| hexadecimal_numeral
	| octal_numeral
	| binary_numeral)
decimal_numeral     ::= '0' | non_zero_digit {['_'] digit}
hexadecimal_numeral ::= '0x' | hex_digit {['_'] hex_digit}
digit               ::= '0' | non_zero_digit
non_zero_digit      ::= '1' | … | '9'
hex_digit           ::= '1' | … | '9' | 'a' | … | 'f'
octal_numeral       ::= '0' oct_digit {'_' oct_digit}
oct_digit           ::= '0' | … | '7'
binary_numeral      ::= '0b' bin_digit {['_'] bin_digit}
bin_digit           ::= '0' | '1'
\end{lstlisting}

Integers are usually of type \lstinline@Number@, which is a class cluster of all classes that can represent numbers. Unlike Java, Coral supports both signed and unsigned integers directly. Usually integer literals that are obviously unsigned integers are automatically represented internally by a class that stores the integer unsigned, like \lstinline@Integer_64_Unsigned@. Math operations on numbers are handled internally in such a way that the user does't need to worry about the actual types of the numbers — when an integer overflow would occur, the result is stored in a larger container type. 

Underscores used in integer literals have no special meaning, other than to improve readability of larger literals, i.e., to separate thousands.

Integral members of the \lstinline@Number@ class cluster include the following container types. 

\begin{enumerate}

\item \lstinline@Integer_8@ ($-2^{7}$ to $2^{7}-1$), alias \lstinline@Byte@

\item \lstinline@Integer_8_Unsigned@ ($0$ to $2^{8}$), alias \lstinline@Byte_Unsigned@

\item \lstinline@Integer_16@ ($-2^{15}$ to $2^{15}-1$), alias \lstinline@Short@

\item \lstinline@Integer_16_Unsigned@ ($0$ to $2^{16}$), alias \lstinline@Short_Unsigned@

\item \lstinline@Integer_32@ ($-2^{31}$ to $2^{31}-1$)

\item \lstinline@Integer_32_Unsigned@ ($0$ to $2^{32}$)

\item \lstinline@Integer_64@ ($-2^{63}$ to $2^{63}-1$), alias \lstinline@Long@

\item \lstinline@Integer_64_Unsigned@ ($0$ to $2^{64}$), alias \lstinline@Long_Unsigned@

\item \lstinline@Integer_128@ ($-2^{127}$ to $2^{127}-1$), alias \lstinline@Double_Long@

\item \lstinline@Integer_128_Unsigned@ ($0$ to $2^{128}$), alias \lstinline@Double_Long_Unsigned@

\item \lstinline@Decimal@ ($-\infty$ to $\infty$)

\item \lstinline@Decimal_Unsigned@ ($0$ to $\infty$)

\end{enumerate}

The special \lstinline@Decimal@ \& \lstinline@Decimal_Unsigned@ container types are also for storing arbitrary precision floating point numbers. All the container types are constants defined in the \lstinline@Number@ class and can be imported into scope if needed. 

Moreover, a helper type \lstinline@Number::Unsigned@ exists, which can be used for type casting in cases where an originally signed number needs to be treated as unsigned. 

Weak conformance applies to the inner members of \lstinline@Number@ class. 

For use with range types, \lstinline@Number::Integer@ and \lstinline@Number::Integer_Unsigned@ exist, to allow constraining of the range types to integral numbers.

\subsection{Floating Point Literals}\label{sec:floatliterals}

\syntax\begin{lstlisting}
float_literal ::= ['+' | '-'] non_zero_digit 
		{['_'] digit} '.' digit {['_'] digit}
		[exponent_part] [float_type]
	| ['+' | '-'] digit {['_'] digit} exponent_part [float_type]
	| ['+' | '-'] digit {['_'] digit} [exponent_part] [float_type]
	| ['+' | '-'] '0x' hex_digit
		{['_'] hex_digit} '.' hex_digit {['_'] hex_digit}
		[float_type]
	| ['+' | '-'] '0b' bin_digit
		{['_'] bin_digit} '.' bin_digit {['_'] bin_digit}
		[float_type]
exponent_part ::= 'e' ['+' | '-'] digit {['_'] digit}
float_type    ::= 'f' | 'd' | 'q'
\end{lstlisting}

Floating point literals are of type \lstinline@Number@ as well as integral literals, and have fewer container types. Compiler infers the precision automatically, unless the \lstinline@float_type@ part is present. 

\begin{enumerate}

\item \lstinline@Float_32@ (IEEE 754 32-bit precision), alias \lstinline@Float@. 

\item \lstinline@Float_64@ (IEEE 754 64-bit precision), alias \lstinline@Double@.

\item \lstinline@Float_128@ (IEEE 754 128-bit precision).

\item \lstinline@Decimal@ ($-\infty$ to $\infty$).

\item \lstinline@Decimal_Unsigned@ ($0$ to $\infty$).

\end{enumerate}

Letters in the exponent type and float type literals have to be lower-case in Coral sources, but functions that parse floating point numbers do support them being upper-case for compatibility. 

\subsection{Imaginary Number Literals}\label{sec:imaginaryliterals}

\syntax\begin{lstlisting}
imaginary_literal ::= real_number_literal 'i'
complex_literal ::= real_number_literal ('+' | '-') imaginary_literal
	| imaginary_literal ('+' | '-') real_number_literal
real_number_literal ::= integer_literal | float_literal
number_literal ::= real_number_literal
	| imaginary_literal
	| complex_literal
\end{lstlisting}

\subsection{Units of Measure}\label{sec:unitsofmeasuresyntax}

Coral has an addition to number handling, called \textit{units of measure}. Number instances can be annotated with a unit of measure to ensure correctness of arithmetic operations. 

\syntax\begin{lstlisting}
annotated_number ::= number_literal '[<' units_of_measure_expr '>]'
\end{lstlisting}

\subsection{Character Literals}\label{sec:characterliterals}

\syntax\begin{lstlisting}
character_literal ::= '%'' (character | unicode_escape) '''
\end{lstlisting}

\subsection{Boolean Literals}\label{sec:booleanliterals}

\syntax\begin{lstlisting}
boolean_literal ::= 'yes' | 'no'
\end{lstlisting}

Both literals are members of type \lstinline@Boolean@. The \lstinline@no@ literal has also a special behavior when being compared to \lstinline@nil@: \lstinline@no@ equals to \lstinline@nil@, while not actually being \lstinline@nil@. Identity equality is indeed different. The implication is that both \lstinline@nil@ and \lstinline@no@ are false conditions in \lstinline@if@-expressions. 

\subsection{String Literals}\label{sec:stringliterals}

\syntax\begin{lstlisting}
string_literal              ::= simple_string_literal 
                              | interpolable_string_literal
simple_string_literal       ::= ''' {string_element} '''
string_element              ::= printable_char | char_escape_seq
interpolable_string_literal ::= '"' {int_string_element} '"'
int_string_element          ::= string_element | interpolated_expr
interpolated_expr           ::= '#{' expr '}'
\end{lstlisting}

String literals are members of the type \lstinline@String@. Single quotes in simple string literals have to be escaped (\lstinline@\'@) and double quotes in interpolable string literals have to be escaped (\lstinline@\"@). Interpolated expression can be preceded only by an even number of escape characters (backslashes, \lstinline@\@), so that the \lstinline@#@ does't get escaped. This is a special \textit{requirement} for any Coral compiler. 

\subsection{Symbol Literals}\label{sec:symbolliterals}

\syntax\begin{lstlisting}
symbol_literal       ::= simple_symbol | quoted_symbol
simple_symbol        ::= ':' simple_id
quoted_symbol        ::= simple_quoted_symbol | interpolable_symbol
simple_quoted_symbol ::= ':'' {string_element} '''
interpolable_symbol  ::= ':"' {int_string_element} '"'
\end{lstlisting}

Symbol literals are members of the type \lstinline@Symbol@. They differ from \nameref{sec:stringliterals} in the way runtime handles them: while there may be multiple instances of the same string, there is always up to one instance of the same symbol. Unlike in Ruby, they do get released from memory when no code references to them anymore, so their object id (sometimes) varies with time. Coral does not require their ids to be constant in time. 

\subsection{Type Parameters}\label{sec:typeparameterliterals}

\syntax\begin{lstlisting}[mathescape=false]
type_param ::= '$' (simple_id | constant_id)
\end{lstlisting}

Type parameters are not members of any type, rather they stand-in for a real type, like a variable which only holds types. 

\subsection{Regular Expression Literals}\label{sec:regexpliterals}

\syntax\begin{lstlisting}
regexp_literal ::= '%/' regexp_content_int '/' [regexp_flags]
	| '%r/' regexp_content_int '/' [regexp_flags]
	| '%r#' regexp_content '#' [regexp_flags]
	| '%r~' regexp_content_int '~' [regexp_flags]
regexp_content_int ::= regexp_element_int {regexp_element_int}
regexp_element_int ::= string_element | int_string_element
regexp_content ::= string_element {string_element}
\end{lstlisting}

Regular expression literals are members of the type \lstinline@Regular_Expression@ with alias of \lstinline@Regexp@. 

\subsection{Collection Literals}\label{sec:collectionliterals}

Collection literals are paired syntax tokens and as such, they are a kind of parentheses in Coral sources. 

\syntax\begin{lstlisting}
collection_literal ::= tuple_literal
	| list_literal
	| dictionary_literal
	| bag_literal
tuple_literal ::= '(' exprs ')'
list_literal ::= '%' collection_flags '[' exprs ']'
dictionary_literal ::= '%' collection_flags '{' dict_exprs '}'
bag_literal ::= '%' collection_flags '(' exprs ')'
exprs ::= expr {',' expr}
dict_exprs ::= dict_expr {',' dict_expr}
dict_expr ::= expr '=>' expr
	| simple_id ':' expr
collection_flags ::= printable_char {printable_char}
\end{lstlisting}

Tuple literals are members of the \lstinline@Tuple@ type family. List literals are members of the \lstinline@List@ type, usually \lstinline@Array_List@ with alias of \lstinline@Array@. Dictionary literals are members of the \lstinline@Dictionary@ type with alias of \lstinline@Map@, usually \lstinline@Hash_Dictionary@ with alias of \lstinline@Hash_Map@. Bag literals are members of the \lstinline@Bag@ type, usually \lstinline@Hash_Bag@ or \lstinline@Hash_Set@. Collection flags may change the actual class of the literal, along with some other properties, described in the following text. 

List literal collection flags: 

\begin{enumerate}
\item Flag \lstinline@i@ = \textbf{i}mmutable, makes the list frozen. 
\item Flag \lstinline@l@ = \textbf{l}inked, makes the list a member of \lstinline@Linked_List@. 
\item Flag \lstinline@w@ = \textbf{w}ords, the following expressions are treated as words, converted to strings for each word separated by whitespace. 
\end{enumerate}

Dictionary literals collection flags:

\begin{enumerate}
\item Flag \lstinline@i@ = \textbf{i}mmutable, makes the dictionary frozen. 
\item Flag \lstinline@l@ = \textbf{l}inked, makes the dictionary a member of \lstinline@Linked_Hash_Dictionary@ (also has alias \lstinline@Linked_Hash_Map@).
\item Flag \lstinline@m@ = \textbf{m}ulti-map, the dictionary items are then either the items themselves, if there is only one for a particular key, or a set of items, if there is more than one item for a particular key. The dictionary is then a member of \lstinline@Multi_Hash_Dictionary@ (alias \lstinline@Multi_Hash_Map@) or \lstinline@Linked_Multi_Hash_Dictionary@ (alias \lstinline@Linked_Multi_Hash_Map@). 
\end{enumerate}

Bag literal collection flags:

\begin{enumerate}
\item Flag \lstinline@i@ = \textbf{i}mmutable, makes the bag frozen. 
\item Flag \lstinline@s@ = \textbf{s}et, the collection is a set instead of a bag (a specific bag, such that for each item, its tally is always $0$ or $1$, thus each item is in the collection up to once). 
\item Flag \lstinline@l@ = \textbf{l}inked, makes the collection linked, so either a member of \lstinline@Linked_Hash_Bag@ in case of a regular bag, or \lstinline@Linked_Hash_Set@ in case of a set. 
\end{enumerate}

Linked collections have a predictable iteration order in case of bags and dictionaries, or are simply stored differently in case of lists.  

\section{Whitespace \& Comments}\label{sec:whitespacecomments}

Tokens may be separated by whitespace characters and/or comments. Comments come in two forms: 

A single-line comment is a sequence of characters that starts with \lstinline@//@ and extends to the end of the line. 

A multi-line comment is a sequence of characters between \lstinline@/*@ and \lstinline@*/@. Multi-line comments may be nested. 

Documentation comments are multi-line comments that start with \lstinline@/*!@. 

\chapter{Identifiers, Names \& Scopes}

Names in Coral identify various types, values, methods and constants, which are the \emph{entities}. Names are introduced by local definitions and declarations, inheritance, use clauses or module clauses, which are the \emph{bindings}. 

Bindings of different kinds have a different precedence defined on them: 

\begin{enumerate}
\item Definitions and declarations that are local have the highest precedence. 
\item Explicit \lstinline@use@ clauses (imports) have the next highest precedence.\footnote{Explicit imports have such high precedence in order to allow binding of different names than those that would be otherwise inherited.} 
\item Inherited definitions and declarations have the next highest precedence. 
\item Definitions and declarations made available by module clause have the next highest precedence. 
\item Definitions and declarations that are not in the same compilation unit (a different script or a different module) have the next highest precedence. 
\item Definitions and declarations that are not bound have the lowest precedence. This happens when the binding simply can't be found anywhere, and probably will result in a name error (if not resolved dynamically), while being inferred to be of type \lstinline@Object@. 
\end{enumerate}

There is only one root name space, in which a single fully-qualified binding designates always up to one entity. 

Every binding has a \emph{scope} in which the bound entity can be referenced using a simple name (unqualified). Scopes are nested, inner scopes inherit the same bindings, unless shadowed. A binding in an inner scope \emph{shadows} bindings of lower precedence in the same scope (and nested scopes) as well as bindings of the same or lower precedence in outer scopes. Shadowing is a partial order, and bindings can become ambiguous -- fully qualified names can be used to resolve binding conflicts. This restriction is checked in limited scope during compilation\footnote{This is due to the hybrid typing system in Coral, to make use of all the available information as soon as possible.} and fully in runtime. 

If at any point of the program execution a binding would change (e.g., by introducing a new type in a superclass that is closer in the inheritance tree to the actual class than the previous binding), and such a change would be incompatible with the previous binding, then a warning\footnote{TBD -- shouldn't that be an error?} will be issued by the runtime. Also, if a new binding would be ambiguous\footnote{Coral runtime actually checks for bindings until the binding-candidate would not be able to shadow the already found binding-candidates and caches the result.}, then it is an error. 

As shadowing is only a partial order, in a situation like

\begin{lstlisting}
var x := 1
use p::x
x
\end{lstlisting}

neither binding of $x$ shadows the other. Consequently, the reference to $x$ on the third line above is ambiguous and the compiler will happily refuse to proceed. 

A reference to an unqualified identifier $x$ is bound by a unique binding, which

\begin{enumerate}
\item defines an entity with name $x$ in the same scope as the identifier $x$, and
\item shadows all other bindings that define entities with name $x$ in that name scope.
\end{enumerate}

It is syntactically not an error if no such binding exists, thanks to the dynamic features of the language (unbound references are implicitly bound to the same scope and are resolved by dynamic method callbacks). The same applies to fully qualified bindings that don't resolve into any entity. However, it is an error if a binding is ambiguous or fails to get resolved dynamically.

If $x$ is bound by explicit \lstinline@use@ import clause, then the simple name $x$ is consided to be equivalent to the fully-qualified name to which $x$ is mapped by the import clause. If $x$ is bound by a definition or declaration, then $x$ refers to the entity introduced by that binding, thus the type of $x$ is the type of the referenced entity. 

\chapter{Types}

When we say \textit{type} in the context of Coral, we are talking about a blueprint of an entity, while the type itself is an entity. Every type in Coral is backed by a \textit{class}, which is an instance of the type \lstinline@Class@. 

We distinguish a few different properties of types in Coral. There are first-order types and type constructors, which take type parameters and yield new types. A subset of first-order types called \textit{value types} represents set of first-class values. Value types are either \textit{concrete} or \textit{abstract}. 

Concrete value types can be either a \textit{class type} (e.g. referenced with a type designator, referencing a class or maybe a mixin), or a \textit{compound type} representing an intersection of types, possibly with a refinement that further constrains the types of its members. Both class types and compound types may be bound to a constant, but only class types referencing a concrete class can be blueprints of values -- \textit{objects}. Compound types can only constrain bindings to a subset of other types. 

Non-value types capture properties of identifiers that are not values. For instance, a type constructor does not directly specify a type of values, but a type constructor, when applied to the correct type arguments, yields a first-order type, which may be a value type. Non-value types are expressed indirectly in Coral. In example, a method type is described by writing down a method signature, which is not a real type itself, but it creates a corresponding method type. 

\section{About Coral's Type System}

There are two main streams of typing systems out there -- statically typed and dynamically typed. Static typing in a language usually means that the language is compiled into an executable with a definite set of types and every operation is type checked. Dynamic typing means that these checks are deferred until needed, in runtime. 

Let's talk about Java. Java uses static typing -- but, in a very limited and unfriendly way, you may use class loaders and a lot of type casts to dynamically load a new class. And then possibly endure a lot of pain using it. 

Let's talk about Ruby. Ruby uses dynamic typing -- but, using types blindly can possibly lead to some confusion. Ruby is amazing though, because you can write programs with it really fast and enjoy the process at the same time. But when it comes to type safety, you need to be careful. 

And now, move on to Coral. Coral uses hybrid typing. In its core, it uses dynamic typing all the way. But, it allows to opt-in for some limited static typing\footnote{This feature is expected to be gradually improved and un-limited.}. Unlike in Ruby, you can overload methods (not just override!). You can constrain variables, constants, properties, arguments and return types to particular types. But you don't have to. Types in Coral were heavily inspired by Scala's type system, but modified for this dynamic environment that Coral provides. Unlike in Ruby, you can have pure interfaces (called protocols\footnote{Interfaces in Coral are used to extract the \textit{public interface} of classes in modules, so that only a small amount of code may be distributed along with the module to allow binding to it.}), or interfaces with default method implementations (similar to Java 8). Unlike in Java, you can have mixins, union types and much more. Unlike in Java, you may easily modify classes, even from other modules (\textit{pimp my library!}). You may even easily add more classes if needed, and possibly shadow existing ones. In face of static typing in Coral, \textit{no type} specified is saying that the value is of any type. 

While Coral is so dynamic, it also needs to maintain stability and performance. Therefore, it ``caches'' its bindings and tracks versions of each type\footnote{Versions are simply integers that are incremented with each significant change to the type and distributed among its subtypes.}. If a \textit{cached binding} would change, it is ok -- as long as the new binding would conform to the old one. Practically, the code that executes first initiates the binding -- first to come, first to bind. Bindings are also cached, so that the Coral interpreter does not need to traverse types all the time -- it only does so if the needed binding does not exist (initial state), or if the cached version does not match the actual version of the bound type. This mechanism is also used for caching methods, not only types. Moreover, this mechanism ensures that type projections (\sref{sec:type-projection}) are valid at any time of execution, even if their binding changes. 

Types in Coral are represented by objects that are members of the \code{Class} type. 

\section{Paths}
\label{sec:type-paths}

\syntax\begin{lstlisting}
Path             ::= Stable_Id
                   | 'this'
                   | [constant_id '#'] 'self'
Stable_Id        ::= constant_id
                   | ['::'] Path '::' constant_id
                   | [constant_id '#'] 'super' [Class_Qualifier] 
                      '::' constant_id
Class_Qualifier  ::= '[' constant_id ']'
\end{lstlisting}

Paths are not types themselves, but they can be a part of named types and in that function form a role in Coral's type system. 

A path is one of the following: \footnote{This section might need a review of what a path is, since we claim that the referenced entity is a member, yet the syntax only mentions \code{constant_id}.}

\begin{itemize}
\item 
The empty path $\epsilon$ (which can not be written explicitly in user programs). 

\item 
\code{this}, which references the directly enclosing class. 

\item 
\lstinline@$C$#self@, where $C$ references a class or a mixin. The path \code{self} is taken as a shorthand for \lstinline@$C$#self@, where $C$ is the name of the class directly enclosing the reference. 

\item 
\lstinline@$p$::$x$@, where $p$ is a path and $x$ is a member of $p$. Additionally, $p$ allows modules to appear instead of references to classes or mixins, but no module reference can follow a class or a mixin reference: \lstinline@{module_ref '::'} {(class_ref|mixin_ref) '::'} …@. 

\item
\lstinline@$C$#super::$x$@ or \lstinline@$C$#super[$M$]::$x$@, where $C$ references a class or a mixin and $x$ references a member of the superclass or designated parent class $M$ of $C$. The prefix \code{super} is taken as a shorthand for \lstinline@$C$#super@, where $C$ is the name of the class directly enclosing the reference, and \lstinline@super[$M$]@ as a shorthand for \lstinline@$C$#super[$M$]@, where $C$ is yet again the name of the class directly enclosing the reference. 
\end{itemize}

\section{Value Types}

Every value in Coral has a type which is of one of the following forms. 

\subsection{Value \& Singleton Type}
\label{sec:value-types}
\label{sec:singleton-types}

\syntax\begin{lstlisting}
Simple_Type ::= Path '#' 'type'
Simple_Type ::= Path '#' 'singleton-type'
\end{lstlisting}

A singleton type is of the form \lstinline@$p$#singleton-type@ and a special type that denotes the set of values consisting of \code{nil} and the value denoted by $p$. A value type, on the other hand, is a special type that denotes the set of values consisting of \code{nil} and every value that conforms to the type of value denoted by $p$.\footnote{This is useful when using a value as prototype of new values.}

\subsection{Type Projection}
\label{sec:type-projection}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type '#' constant_id
\end{lstlisting}

A type projection \lstinline@$T$#$x$@ references type member named $x$ of type $T$. \footnote{Type projection operator \lstinline@#@ is a language construct and can't be overridden by user programs. There is a similarity between this construct and the \lstinline@::@ scope operator. The difference is, type projection operator is expected to be rarely needed, but it does provide a type projection and can refer in a stable way to a type of anything. Scope operator, on the other hand, does not care about types, it merely resolves a member of a particular expression at runtime.}

\subsection{Type Designators}

\syntax\begin{lstlisting}
Simple_Type ::= Stable_Id
\end{lstlisting}

A type designator refers to a named value type. It can be simple or qualified. All such type designators are shorthands for type projections. 

Specifically, the unqualified type name $t$ where $t$ is bound in some class, object or module $C$ is taken as a shorthand for \lstinline@$C$#self#type#$t$@. If $t$ is not bound in a class, object or module, then $t$ is taken as a shorthand for \lstinline@$\epsilon$#type#$t$@. 

A qualified type designator has the form \lstinline@$p$::$t$@, where $p$ is a path (\sref{sec:type-paths}) and $t$ is a type name. Such a type designator is equivalent to the type projection \lstinline@$p$#type#$t$@. 

\subsection{Parameterized Types}
\label{sec:parameterized-types}

\syntax\begin{lstlisting}
Simple_Type ::= Simple_Type Type_Args
Type_Args   ::= ':[' Types ']'
Types       ::= Type {',' Type}
\end{lstlisting}

A parameterized type\footnote{The `\lstinline@:[@' and `\lstinline@]@' token pairs were selected after many considerations. The original idea was to use the same pair as Java or C\#: `\lstinline@<@' and `\lstinline@>@', but this has the drawback of injecting an exception into the parser. Then Scala's `\lstinline@[@' and `\lstinline@]@' were considered, but they kind of collide with an operator that uses the same pair and therefore expressions could become ambiguous. Finally an idea emerged to use `\lstinline@:[@' and `\lstinline@]@', since the `\lstinline@:@' in it hints that it is related to the type system, and `\lstinline@[@' and `\lstinline@]@' lack the drawbacks of `\lstinline@<@' and `\lstinline@>@' (collision with comparison operators).} $T:[T_1 \commadots T_n]$ consists of a type designator $T$ and type parameters $T_1 \commadots T_n$, where $n \geq 1$. $T$ must refer to a type constructor which takes exactly $n$ type parameters $a_1 \commadots a_n$. 

Say the type parameters have lower bounds $L_1 \commadots L_n$ and upper bounds $U_1 \commadots U_n$. The parameterized type is well-formed if each actual type parameter {\em conforms to its bounds}, so that $L_i <: \sigma a_i <: U_i$, where $\sigma$ is the substitution $[a_1 := T_1 \commadots a_n := T_n]$. Also, $U_i$ must never be a subtype of $L_i$, since no other type ever would be able to fulfil the bounds ($U_i$ and $L_i$ may be the exact same type though, but in that case the type parameter would be invariant and the whole point of having a parameterized type would be useless). 

\example
\label{example:parameterized-types}
Given the generic type definitions: 

\begin{lstlisting}[escapechar=@]
class Tree_Map:[@\$@A <: Comparable:[@\$@A], @\$@B] $\ldots$ end
class List:[@\$@A] $\ldots$ end
class I; implements Comparable:[I]; $\ldots$ end

class F:[@\$@M:[_], @\$@X] $\ldots$ end
class S:[@\$@K <: String] $\ldots$ end
class G:[@\$@M:[@\$@Z <: @\$@I], @\$@I] $\ldots$ end
\end{lstlisting}

the following parameterized types are well-formed: 

\begin{lstlisting}
Tree_Map:[I, String]
List:[I]
List:[List:[Boolean]]

F:[List, Number]
G:[S, String]
\end{lstlisting}

\example
\label{example:parameterized-types-mal}

Given the type definitions of the previous example, the following types are malformed: 

\begin{lstlisting}
Tree_Map:[I]               // wrong number of parameters
Tree_Map:[List:[I], Number] // type parameter List not within bound

F:[Number, Boolean]        // Number is not a type constructor
F:[Tree_Map, Number]       // Tree_Map takes two parameters, 
                          //   F expects a type constructor taking one

G:[S, Number]              // type S constrains its parameter to
                          //   conform to String, 
                          // G expects type constructor with a parameter
                          //   that conforms to Number
\end{lstlisting}

\subsection{Tuple Types}

\syntax\begin{lstlisting}
Simple_Type ::= '(' Types ')'
\end{lstlisting}

A tuple type ($T_1 \commadots T_n$) is an alias for the class \lstinline@Tuple_$n$:[$T_1 \commadots T_n$]@, where $n \geq 2$. 

Tuple classes are available as patterns for pattern matching. The properties can be accessed as methods \lstinline@[1]$ \commadots $[$n$]@ (using an ``offset'' that is outside of the tuple's size results in a method-not-found error, not offset-out-of-bounds -- tuple classes do not implement the operator \lstinline@[i]@ for arbitrary $i$). 

Tuple classes are generated lazily by the runtime as needed, so that the language does not constrain users to tuples of only limited sizes, but allows any size. 

An effort will be made to introduce a simple enough syntax for variable parameterized types, if possible, until then, \lstinline@Tuple_$i$@ are the only such types. 

\subsection{Annotated Types}

\syntax\begin{lstlisting}
Annot_Type ::= {Annotation} Simple_Type
\end{lstlisting}

An annotated type $a_1 \ldots a_n T$ attaches annotations $a_1 \commadots a_n$ to the type $T$. % TBD: add ref to a chapter about annotations.

\subsection{Compound Types}
\label{sec:compound-types}

\syntax\begin{lstlisting}
Compound_Type ::= Annot_Type {'with' Annot_Type} [Refinement]
                | Refinement
Refinement    ::= 'refine' '{' Refine_Stat {semi Refine_Stat} '}'
\end{lstlisting} % TBD: define Refine_Stat syntax

A compound type \lstinline@$T_1$ with $\ldots$ with $T_n$ {$R$}@ represents values with members as given in the component types $T_1 \commadots T_n$ and the refinement \lstinline@{$R$}@. A refinement \lstinline@{$R$}@ contains declarations and type definitions. 

If no refinement is given, the type is implicitly equivalent to the same type having an empty refinement. 

A compound type may also consist of just a refinement \lstinline@{$R$}@ with no preceding component types -- such a type has an implicit component type \code{Object} and describes the member values as ``any value, as long as it has what the refinement requires'', thus it works like an anonymous protocol. 

\subsection{Function Types}
\label{sec:function-types}

\syntax\begin{lstlisting}
Type ::= Function_Args {'->' Function_Args} '->' Return_Type
Function_Args ::= '(' [Type {',' Type}] ')'
Return_Type ::= Type | '(' ')'
\end{lstlisting}

The type \lstinline@($T_1 \commadots T_n$) -> $R$@ represents the set of function values that take arguments of types $T_1 \commadots T_n$ and yield results of type $R$. Empty arguments list is indeed also possible as \lstinline@() -> $R$@, representing e.g. a call-by-name parameter of type $T$.

Function types associate to the right, e.g. \lstinline@($S$) -> ($T$) -> $R$@ is the same as \lstinline@($S$) -> (($T$) -> $R$)@. 

Function types are shorthands for class types that conform to the \lstinline@Function_$i$@ protocol -- i.e. having an \code{apply} function or simply {\em being} a function. The $n$-ary function type \lstinline@($T_1 \commadots T_n$) -> $R$@ is a shorthand for the protocol \lstinline@Function_$n$:[$T_1 \commadots T_n,R$]@. Such protocols are defined in the Coral library for any $n$. 

Function types are covariant in their result type and contravariant in their argument types. 

\subsection{Existential Types}
\label{sec:existential-types}

\syntax\begin{lstlisting}[escapechar=@]
Type                ::= Compound_Type Existential_Clauses
Existential_Clauses ::= {'for-some' '{' Existential_Dcl
                        {semi Existential_Dcl} '}'}
Existential_Dcl     ::= 'type' Type_Dcl
\end{lstlisting}

An existential type has the form \lstinline@$T$ for-some {$Q$}@, where $Q$ is a sequence of type declarations. Let \lstinline@$t_1$:[$tps_1$] >: $L_1$ <: $U_1$ $\commadots$ $t_n$:[$tps_n$] >: $L_n$ <: $U_n$@ be the types declared in $Q$. 

A {\em type instance} of \lstinline@$T$ for-some {$Q$}@ is a type $\sigma T$, where $\sigma$ is a substitution over $t_1 \commadots t_n$, such that for each $i$, \lstinline@$L_i$ <: $t_i$ <: $U_i$@. The set of values denoted by the existential type \lstinline@$T$ for-some {$Q$}@ is the union of the set of values of all its type instances. 

\section{Non-Value Types}

The types explained in the following paragraphs do not appear explicitly in programs, they are internal and do not represent any type of value directly. 

\subsection{Method Types}
\label{sec:method-types}

A method type is denoted internally as $(Ps) \mapsto R$, where $(Ps)$ is a sequence of parameter names, types and extra properties $(ep_1 : T_1 \commadots ep_n : T_n)$ for some $n \geq 0$ and $R$ is a (value or method) type. This type represents named or anonymous methods that take arguments named $p_1 \commadots p_n$ of types $T_1 \commadots T_n$, have extra properties $e$ and return a result of type $R$. Names of parameters are either simple identifiers (for positional argument passing) or symbol literals (\sref{sec:symbolliterals}, for named arguments passing -- they make difference between method types with possibly same parameter types, therefore the name is a part of the method type along with the associated parameter type\footnote{This means that, for simplicity, if we have a method with one parameter, which is a named parameter, represented by having its name expressed with a symbol literal, and the parameters have an equivalent type, but different names, the method types are not equivalent.}). 

Method types associate to the right:\footnote{Like in Haskell or Scala.} \newline
$(Ps_1) \mapsto (Ps_2) \mapsto R$ is treated as $(Ps_1) \mapsto ((Ps_2) \mapsto R)$. 

A special case are types of methods without any parameters. They are written here as $() \mapsto R$. 

Another special case are types of methods without any return type. They are written here as $(Ps) \mapsto ()$. Methods that have this return type do not have an implicit return expressions and an attempt to return a value from it results in a compile-time error.\footnote{A compile-time error like this may happen during a runtime evaluation as well.}

Method types do not exist as types of values. If a method name is used as a value, its type is implicitly converted to a corresponding function type (\sref{sec:function-types}). 

Extra properties of parameters are as follows: a \lstinline@*@ for variable arguments, \lstinline@**@ for any named arguments and \lstinline@&@ for a captured block argument, or nothing for regular parameters. 

\example The declarations
\begin{lstlisting}
def a -> Integer // or def a () -> Integer
def b (x : Integer) -> Boolean
def c (x : Integer) -> (y : String, z : String) -> String
def d (:x : Integer) -> Integer
def e (*x : Integer) -> Integer
def f (Integer) -> ()
\end{lstlisting}
produce the typings
\begin{lstlisting}
a : () $\mapsto$ Integer
b : (Integer) $\mapsto$ Boolean
c : (Integer) $\mapsto$ (String, String) $\mapsto$ String
d : (:x Integer) $\mapsto$ Integer
e : (*Integer) $\mapsto$ Integer
f : (Integer) $\mapsto$ ()
\end{lstlisting}

\subsection{Polymorphic Method Types}
\label{sec:polymorphic-method-types}

A polymorphic method type is the same as a regular method type, but enhanced with a type parameters section. It is denoted internally as \lstinline@:[$tps$]$ \mapsto T$@, where \lstinline@:[$tps$]@ is a type parameter section \lstinline@:[$a_1$ >: $L_1$ <: $U_1$ $\commadots$ $a_n$ >: $L_n$ <: $U_n$]@ for some $n \geq 0$ and $T$ is a (value or method) type. This type represents (only\footnote{Not anonymous.}) named methods that take type arguments $S_1 \commadots S_n$, for which the lower bounds $L_1 \commadots L_n$ conform (\sref{sec:conformance}) to the type arguments and the type arguments conform and the upper bounds $U_1 \commadots U_n$ and that yield results of type $T$. No explicit lower bound implies \code{Nothing} to be the corresponding lower bound, no explicit upper bound implies \code{Object} to be the corresponding upper bound. As usual, lower bound must conform to the corresponding upper bound. 

\example The declarations
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
def empty:[@\$@A] -> List:[@\$@A]
def union:[@\$@A <: Comparable:[@\$@A]] (x : Set:[@\$@A], 
         xs : Set:[@\$@A]) -> Set:[@\$@A]
\end{lstlisting}
produce the typings
\begin{lstlisting}[escapechar=@,deletekeywords={union}]
empty : :[@\$@A >: Nothing <: Object] () $\mapsto$ List:[@\$@A]
union : :[@\$@A >: Nothing <: Comparable:[@\$@A]] (Set:[@\$@A], 
        Set:[@\$@A]) $\mapsto$ Set:[@\$@A]
\end{lstlisting}

\subsection{Type Constructors}
\label{sec:type-constructors}

A type constructor is in turn represented internally much like a polymorphic method type. \lstinline@:[$\pm a_1$ >: $L_1$ <: $U_1 \commadots \pm a_n$ >: $L_n$ <: $U_n$] $\mapsto T$@ represents a type that is expected by a type constructor parameter. The difference is that the represented internal entity is not a method, but a type, creating higher-kinded types. 

\section{Relations Between Types}

We define two relations between types. 
\begin{quote}\begin{tabular}{l@{\gap}l@{\gap}l}
\em Type equivalence & $T \equiv U$ & $T$ and $U$ are interchangeable
in all contexts.
\\
\em Conformance & $T \conforms U$ & Type $T$ conforms to type $U$.
\end{tabular}\end{quote}

\subsection{Type Equivalence}

Equivalence ($\equiv$) between types is the smallest congruence, such that the following statements are true:

\begin{itemize}
\item
If $t$ is defined by a type alias \lstinline@type t is T@, then $t$ is equivalent to $T$. 

\item
If a path $p$ has a singleton type \lstinline@$q$#singleton-type@, then \lstinline@$p$#singleton-type $\equiv$ $q$#singleton-type@. 

\item
Two compound types (\sref{sec:compound-types}) are equivalent, if the sequences of their components are pairwise equivalent, occur in the same order and their refinements are equivalent.

\item 
Two refinements (\sref{sec:compound-types} \& TBD: named refinements) are equivalent, if they bind the same names and the modifiers, types and bounds of every declared entity are equivalent in both refinements. Two equivalent refinements, both or one attached to a compound type, do not imply the compound types to be equivalent. This applies to both anonymous and named refinements. 

\item
Two method types (\sref{sec:method-types}) are equivalent, if they have equivalent return types, both have the same number of parameters and corresponding parameters have equivalent types and extra properties. Names of parameters matter for method type equivalence only with named parameters. 

\item
Two polymorphic method types (\sref{sec:polymorphic-method-types}) are equivalent, if they have the same number of type parameters, the return types are equivalent as well as lower and upper bounds of corresponding type parameters. 

\item
Two existential types (\sref{sec:existential-types}) are equivalent, if they have the same number of quantifiers and the quantified types as well as lower and upper bounds of corresponding quantifiers are equivalent. 

\item
Two type constructors (\sref{sec:type-constructors}) are equivalent, if they have the same number of type parameters, the return types are equivalent as well as variances, lower and upper bounds of corresponding type parameters. 

\end{itemize}

\subsection{Conformance}
\label{sec:conformance}

The conformance relation $(\conforms)$ is the smallest transitive relation that satisfies the following conditions:

\begin{itemize}

\item
Conformance includes equivalence, therefore if $T \equiv U$, then \lstinline@$T \conforms U$@. 

\item
For every value type $T$, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
For every type constructor $T$ with any number of type parameters, \lstinline@Nothing $\conforms T \conforms$ Object@. 

\item
A type variable $t$ conforms to its upper bound and its lower bound conforms to $t$. 

\item
A class type or a parameterized type conforms to any of its base types. 

\end{itemize}

\subsection{Weak Conformance}

For now, {\em weak conformance} is a relation defined on members of the \code{Number} type as a relaxation of conformance. The relation is simple: a type $t$ weakly conforms to another type $u$ when $u$'s size contains all values of $t$ (we say that $t$ can be converted to $u$ without precision loss). 

Whether weak conformance will be available to be defined by users is up to further investigation. 

\chapter{Basic Declarations \& Definitions}

\syntax\begin{lstlisting}
Dcl         ::= [Val_Mod] 'val' Val_Dcl
              | 'var' Var_Dcl
              | 'def' Def_Dcl
              | 'type' Type_Dcl
Pat_Var_Def ::= [Val_Mod] 'val' Pat_Def
              | 'var' Var_Def
              | 'let' ['!'] Let_Def
Def         ::= Pat_Var_Def
              | 'def' Fun_Def
              | 'type' Type_Def
\end{lstlisting}

A {\em declaration} introduces names and assigns them types. Using another words, declarations are abstract members, working sort of like header files in C. 

A {\em definition} introduces names that denote terms or types. Definitions are the implementations of declarations. 

Both declarations and definitions produce {\em bindings} that associate type names with type definitions or bounds, and that associate term names with types. 

Even more simply put, declarations declare a binding with a type (or type-less), and definition defines the term behind that binding (along with the binding). 

% TBD: differences between val, var, def, type, let
% val: values, immutable variables, patterns, lazy values, constant values, parameterless functions that return a value
% var: mutable variables, patterns
% def: functions
% type: types, aliases
% let: immutable values, patterns
% let!: immutable values (see async...)

\section{Value Declarations \& Definitions}
\label{sec:value-dcl-def}

A value declaration \lstinline@val $x$ : $T$@ introduces $x$ as a name of a value of type $T$. May appear in any block of code and an attempt to use it prior to initialisation with a value is an error. More specifically, a value declaration \lstinline+val @$x$ : $T$+ introduces $x$ as a name of an instance value of type $T$, and a value declaration \lstinline+val @@$x$ : $T$+ introduces $x$ as a name of a class instance value of type $T$. 

A value definition \lstinline@val $x$ : $T$ := $e$@ defines $x$ as a name of the value that results from evaluation of expression $e$.

A value in this sense\footnote{Everything in Coral is a value -- remember, Coral is also a functional language, to some extent.} is an immutable variable. A declared value can be assigned just once\footnote{A similar way that \lstinline[language=Java]@final@ variables or members in Java can be assigned just once, but Java furthermore requires that this assignment will happen in every code path, Coral does not impose such requirement.}, a defined value is already assigned from its definition. 

The value type $T$ may be always omitted, in that case the type is inferred and bound to the name. If a type $T$ is omitted, the type of expression $e$ is assumed. If a type $T$ is given, then $e$ is expected to conform to it (\sref{sec:conformance}). 

Evaluation of the value definition implies evaluation of its right-hand side $e$, unless it has a modifier \code{lazy} -- in that case, evaluation is deferred to the first time the value is accessed. 

A {\em lazy value} is of the form
\begin{quote}\begin{lstlisting}
lazy val $x$ : $T$ := $e$
\end{lstlisting}\end{quote}

A lazy value may only be defined, and a value of the same name (binding) may be declared prior to the value definition, but never as a lazy value. 

The effect of the value definition is to bind $x$ to the value of $e$ converted to type $T$. 

A {\em constant value definition} is of the form 
\begin{quote}\begin{lstlisting}
let $x$ : $T$ := $e$
\end{lstlisting}\end{quote}
where $e$ is an expression that is supposed to be treated as constant in the same block from its occurrence on. Values defined with \code{let} have certain limitations and properties:

\begin{enumerate}
\item They can't use patterns as a name. 
\item They can't be lazy. 
\item They can't be used in a declaration, only in a definition. 
\item They can be used to redefine a variable (the name is then treated as a new binding in the scope). 
\item They can't define (class) instance variables. 
\item They can be used in workflows (\sref{sec:workflows}).\footnote{A pragma that would turn all values into lazy values might exist, and lazy values should never appear in workflows, so that's why \code{val} should not be allowed in workflows.}
\end{enumerate}

The type $T$ may be omitted. 

Value declarations \& definitions with the type $T$ omitted are of the form
\begin{quote}\begin{lstlisting}
val $x$
val @$x$
val @@$x$
val $x$ := $e$
val @$x$ := $e$
val @@$x$ := $e$
let $x$ := $e$
\end{lstlisting}\end{quote}

A value declaration without any type is basically only declaring the name, so that a binding is introduced and the actual value is for another code to define.\footnote{Usually, that another code should be a \code{constructor} or the class-level block in another file, maybe.}

A value definition can alternatively have a pattern (\sref{sec:patterns}) as left-hand side (the name). If $p$ is a pattern other than a simple name or a name followed by a colon and a type, then the value definition \lstinline@val $p$ := $e$@ is expanded as follows: 

\begin{enumerate}
\item
If the pattern $p$ has bound variables $x_1 \commadots x_n$ for some $n > 1$:
\begin{lstlisting}[escapechar=@]
val $x$@\$@ := match $e$
  when $p$ then ($x_1 \commadots x_n$)
end match
val $x_1$ := $x$@\$@[$1$]
$\ldots$
val $x_n$ := $x$@\$@[$n$]
\end{lstlisting}

\item
If $p$ has exactly one unique bound variable $x$:
\begin{lstlisting}
val $x$ := match $e$
  when $p$ then $x$
end match
\end{lstlisting}

\item
If $p$ has no bound variables:
\begin{lstlisting}
match $e$
  when $p$ then ()
end match
\end{lstlisting}
\end{enumerate}

\example The following are examples of value definitions. 

\begin{lstlisting}
val pi := 3.14159
val pi : Double := 3.14159
val Some(x) := f()
val x ~> xs := my_list
\end{lstlisting}

The last two definitions have the following expansions:

\begin{lstlisting}[escapechar=@]
val x := match f()
  when Some(x) then x
end match

val x@\$@ := match my_list
  when x ~> xs then (x, xs)
end match
val x := x@\$@[1]
val xs := x@\$@[2]
\end{lstlisting}

The name of any declared or defined value must not end with \lstinline@=@. 

A value declaration ~\lstinline@val $x_1 \commadots x_n$ : $T$@~ is a shorthand for the sequence of value declarations ~\lstinline@val $x_1$ : $T$; $\ldots$; val $x_n$ : $T$@. A value definition ~\lstinline@val $p_1 \commadots p_n$ := $e$@~ is a shorthand for the sequence of value definitions ~\lstinline@val $p_1$ := $e$; $\ldots$; val $p_n$ := $e$@. A value definition ~\lstinline@val $p_1 \commadots p_n : T$ := $e$@~ is a shorthand for the sequence of value definitions ~\lstinline@val $p_1 : T$ := $e$; $\ldots$; val $p_n : T$ := $e$@.

\section{Variable Declarations \& Definitions}
\label{sec:variable-dcl-def}

A variable declaration \lstinline@var $x$ : $T$@ introduces a mutable variable without a defined initial value of type $T$. More specifically, \lstinline+var @$x$ : $T$+ introduces a mutable instance variable of type $T$ and \lstinline+var @@$x$ : $T$+ introduces a mutable class instance variable of type $T$. 

A variable definition \lstinline@val $x$ : $T$ := $e$@ defines $x$ as a name of the value that results from evaluation of expression $e$. The type $T$ can be omitted, in that case the type of expression $e$ is assumed, but not bound to the variable -- the variable is only bound to \code{Object} then. If the type $T$ is given, then $e$ is expected to conform to it (\sref{sec:conformance}), as well as every future value of the variable. 

Variable definitions can alternatively have a pattern (\sref{sec:patterns}) as their left-hand side. A variable definition \lstinline@var $p$ := $e$@, where $p$ is a pattern other than a simple name followed by a colon and a type, is expanded in the same way (\sref{sec:value-dcl-def}) as a value definition \lstinline@val $p$ := $e$@, except that the free names in $p$ are introduced as mutable variables instead of values. 

The name of any declared or defined variable must not end with \lstinline@=@. 

A variable declaration ~\lstinline@var $x_1 \commadots x_n$ : $T$@~ is a
shorthand for the sequence of variable declarations ~\lstinline@var $x_1$ : $T$; $\ldots$; var $x_n$ : $T$@. A variable definition ~\lstinline@var $x_1 \commadots x_n$ = $e$@~ is a shorthand for the sequence of variable definitions ~\lstinline@var $x_1$ := $e$; $\ldots$; var $x_n$ := $e$@. A variable definition ~\lstinline@var $x_1 \commadots x_n : T$ := $e$@~ is a shorthand for the sequence of variable definitions ~\lstinline@var $x_1 : T$ := $e$; $\ldots$; var $x_n : T$ := $e$@.

\section{Property Declarations \& Definitions}
\label{sec:property-dec-dfn}

\syntax\begin{lstlisting}
Prop_Dcl   ::= 'property' ['(' Prop_Specs ')'] simple_id 
             [':' Type]
Prop_Specs ::= Prop_Spec {',' Prop_Spec}
Prop_Spec  ::= ([Access_Modifier] ('get' | 'set')) | 'weak'
Prop_Def   ::= 'property' ['(' Prop_Specs ')'] simple_id 
             [':' Type]
             '{' Prop_Impl {semi Prop_Impl} '}'
Prop_Impl  ::= ('get' [Prop_Get_Impl])
             | ('set' [Prop_Set_Impl])
             | ('val' ':=' Expr)
             | ('var' ':=' Expr)
\end{lstlisting} % TBD: syntax of property implementations

A property declaration \lstinline@property $x$ : $T$@ introduces a property without a defined initial value of type $T$. Property declaration does not specify any actual implementation details of how or where the declared value is stored.

A property definition \lstinline@property $x$ : $T$ {get $\ldots$; set $\ldots$}@ introduces a property with a possibly defined initial value of type $T$. Property definition may specify implementation details of the behavior and storage of a property, but may as well opt-in for auto-generated implementation, which is: 

\begin{enumerate}
\item 
Storage of the property's value is in an instance variable (or a class instance variable in case of class properties) of the same name as is the name of the property: \lstinline@property $x$@ is stored in an instance variable \lstinline+@$x$+. 

\item
Properties defined with only \code{get} are stored in immutable instance variables (\sref{sec:value-dcl-def}). 

\item
Properties defined with \code{set}\footnote{It is also possible to declare/define properties that are \code{set}-only. That makes them {\em write-only}, as opposed to {\em read-only} properties with \code{get}-only.} are stored in mutable instance variables (\sref{sec:variable-dcl-def}). 

\item
Properties defined with \code{weak} are stored as weak references. A property \lstinline@property $x$ : $T$@ is stored in an instance of type \lstinline@Weak_Reference:[$T$]@. 

\end{enumerate}

Declaring a property $x$ of type $T$ is equivalent to declarations of a {\em getter function} $x$ and a {\em setter function} \lstinline@$x=$@, declared as follows:

\begin{lstlisting}
def $x$ () -> $T$; end
def $x$= (y : $T$) -> (); end
\end{lstlisting}

Assignment to properties is translated automatically into a setter function call and reading of properties does not need any translation. 

\section{Type Declarations \& Aliases}

\syntax\begin{lstlisting}
Dcl      ::= 'type' Type_Dcl
Type_Dcl ::= constant_id [Type_Param_Clause] ['>:' Type] 
           ['<:' Type]
Def      ::= 'type' Type_Def
Type_Def ::= constant_id [Type_Param_Clause] ':=' Type
\end{lstlisting}

A {\em type declaration} \lstinline@type $t$:[$tps$] >: $L$ <: $U$@ declares $t$ to be an abstract type with lower bound type $L$ and upper bound type $U$. If the type parameter clause \lstinline@:[$tps$]@ is omitted, $t$ abstracts over first-order type, otherwise $t$ stands for a type constructor that accepts type arguments as described by the type parameter clause. 

A {\em type alias} \lstinline@type $t$ := $T$@ defines $t$ to be an alias name for the type $T$. Since for type safety reasons, types are constant and can not be replaced by another type when bound to a constant name, type aliases are permanent. A type remembers the first given constant name, no alias can change that. The left hand side of a type alias may have a type parameter clause, e.g. \lstinline@type $t$:[$tps$] := $T$@. The scope of a type parameter extends over to the right hand side $T$ and the type parameter clause $tps$ itself. 

It is an error if a type alias refers recursively to the defined type constructor itself. 

\example The following are legal type declarations and aliases:
\begin{lstlisting}[escapechar=@]
type Integer_List := List:[Integer]
type T <: Comparable:[T]
type Two:[@\$@A] := Tuple_2:[@\$@A, @\$@A]
type My_Collection:[+@\$@X] <: Iterable:[@\$@X]
\end{lstlisting}

\section{Type Parameters}

\section{Variance of Type Parameters}

\section{Function Declarations \& Definitions}

\subsection{Positional Parameters}

\subsection{Optional Parameters}

\subsection{Repeated Parameters}

\subsection{Named Parameters}

\subsection{Procedures}

\subsection{Method Return Type Inference}

\section{Use Clauses}

\chapter{Classes \& Objects}

\section{Class Definitions}

\subsection{Class Linearization}

\subsection{Constructor \& Destructor Definitions}

\subsection{Class Block}

\subsection{Class Members}

\subsection{Overriding}

\subsection{Inheritance Closure}

\subsection{Modifiers}

\section{Mixins}

\section{Unions}

\section{Enums}

\section{Compound Types}

\section{Range Types}

\section{Units of Measure}

\section{Record Types}

\section{Struct Types}

\section{Object Definitions}

\chapter{Expressions}

\section{Expression Typing}

\section{Literals}

\section{The Nil Value}

\section{Designators}

\section{Self, This \& Super}

\section{Function Applications}

\subsection{Named and Optional Arguments}

\subsection{Input \& Output Arguments}

\subsection{Function Compositions \& Pipelines}

\section{Method Values}

\section{Type Applications}

\section{Tuples}

\section{Instance Creation Expressions}

\section{Blocks}

\section{Prefix \& Infix Operations}

\subsection{Prefix Operations}

\subsection{Infix Operations}

\subsection{Assignment Operators}

\section{Typed Expressions}

\section{Annotated Expressions}

\section{Assignments}

\section{Conditional Expressions}

\section{Loop Expressions}

\subsection{Classic For Expressions}

\subsection{Iterable For Expressions}

\subsection{Basic Loop Expressions}

\subsection{While \& Until Loop Expressions}

\subsection{Conditions in Loop Expressions}

\section{Collection Comprehensions}

\section{Return Expressions}

\subsection{Implicit Return Expressions}

\subsection{Explicit Return Expressions}

\subsection{Structured Return Expressions}

\section{Raise Expressions}

\section{Rescue \& Ensure Expressions}

\section{Throw \& Catch Expressions}

\section{Anonymous Functions}

\section{Conversions}

\subsection{Type Casting}

\section{Workflows}
\label{sec:workflows}

\chapter{Implicit Parameters \& Views}

\chapter{Pattern Matching}

\section{Patterns}
\label{sec:patterns}

\subsection{Variable Patterns}

\subsection{Typed Patterns}

\subsection{Literal Patterns}

\subsection{Constructor Patterns}

\subsection{Tuple Patterns}

\subsection{Extractor Patterns}

\subsection{Pattern Alternatives}

\subsection{Regular Expression Patterns}

\section{Type Patterns}

\section{Pattern Matching Expressions}

\section{Pattern Matching Anonymous Functions}

\chapter{Top-Level Definitions}

\section{Compilation Units}

\section{Modules}

\section{Module Objects}

\section{Module References}

\section{Top-Level Classes}

\section{Programs}

\chapter{Annotations}

\chapter{Naming Guidelines}

\chapter{The Coral Standard Library}

\section{Root Classes}

\subsection{The Object Class}

\subsection{The Nothing Class}

\section{Value Classes}

\section{Standard Reference Classes}



















