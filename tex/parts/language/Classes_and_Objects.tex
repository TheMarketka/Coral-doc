%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Classes \& Objects}

\minitoc

\newpage

\syntax\begin{lstlisting}
Tmpl_Def             ::= Class_Definition
                       | Object_Definition
                       | Trait_Definition
                       | Protocol_Definition
                       | Interface_Definition
                       | Refinement_Definition
                       | Aspect_Definition
                       | Annotation_Definition
                       | Type_Definition
Class_Definition     ::= [Mutability] ['case'] 'class' Class_Def
Object_Definition    ::= [Mutability] ['case'] 'object' Object_Def
Trait_Definition     ::= [Mutability] 'trait' Trait_Def
Protocol_Definition  ::= 'protocol' Pro_Def
Interface_Definition ::= [Mutability] ['case'] 'interface' Ifc_Def
\end{lstlisting}

Classes (\sref{sec:class-definitions}) \& objects (\sref{sec:object-definitions}) are both defined in terms of {\em templates}. 





\section{Templates}
\label{sec:templates}

\syntax\begin{lstlisting}
Class_Parents  ::= Constr {['prepend'] 'with' Annot_Type} 
Trait_Parents  ::= Annot_Type {['prepend'] 'with' Annot_Type}
Template_Body  ::= [Self_Type] Template_Stat {semi Template_Stat}
Self_Type      ::= 'requires' 'self' ':' Type semi
                 | 'requires' [id ':'] Type semi
                 | 'use' ['self'] 'as' id [':' Type] semi
\end{lstlisting}

A template defines the type signature, behaviour and initial state of a trait, class of objects or of a single object. Templates for part of instance creation expressions (constructors, see \sref{sec:constructor-invocations} \& \sref{sec:constructor-destructor-def}), class definitions and object definitions. A template ~\lstinline!$sc$ with $mt_1$ with $\ldots$ with $mt_n$ { $\stats$ }!~ consists of constructor invocation $sc$, which defines the template's {\em superclass}, trait references $mt_1 \commadots mt_n$ $(n \geq 0)$, which statically define the template's included traits\footnote{Including protocols, which are also traits.}, and a statement sequence $\stats$, which contains initialization code and additional member definitions \& declarations for the template. Unlike in Scala, all trait references in class/trait parents need not to be exhaustive, as more prepended/included traits may be defined as a part of the template body. Trait references declared using \code{prepend with} are prepended to the template body instead of included (\sref{sec:include-classes}). 

Each trait reference $mt_i$ that is not prepended must denote a trait (\sref{sec:traits}). By contrast, the superclass constructor $sc$ normally refers to a class which is not a trait. It is possible to write a list of parents that starts with a trait reference, e.g. ~\lstinline!$mt_1$ with $\ldots$ with $mt_n$!~. In that case, the list of parents is implicitly extended to include the supertype of $mt_1$ as first parent type. This new supertype must have at least one constructor that does not take parameters and is accessible to the subclass (\sref{sec:modifiers}). 

The list of parents of a template must be well-formed, i.e. the class denoted by the superclass constructor $sc$ must be a subclass (or the superclass itself) of the superclasses of all the traits $mt_1 \commadots mt_n$. 

The {\em least proper supertype} of a template is the class type or compound type (\sref{sec:compound-types}) consisting of all its parent class types. 

The statement sequence $\stats$ contain member definitions that define new members or overwrite members in the parent classes. It is called also the {\em class-level block}, as it does not need to contain only member definitions for the template, but also arbitrary other expressions that construct the class object and that are executed while the class is being loaded, in the context of the class. If the template forms part of an abstract class or trait definition, the statement part $\stats$ may also contain declarations of abstract members. If the template forms part of a concrete class definition, $\stats$ may still contain declarations of abstract type members, but not of abstract term members. Unlike in Scala, the expressions in $\stats$ are not forming the primary constructor of the class, but a multi-constructor\footnote{The classes are open in Aml, a single class may have its statements spread across multiple source files (\sref{sec:open-templates}).} of the class itself. 

The sequence of template statements may be prefixed with a formal parameter definition prefixed with \code{requires} or \code{use}, i.e. ~\lstinline!use self as $x$!, ~\lstinline!use self as $x$: $T$!, ~\lstinline!requires $T$!~ or ~\lstinline!requires $x$: $T$!. If a formal parameter $x$ is given, it can be used as an alias for the reference \code{self} throughout the body of the template, including any nested types. If the formal parameter $x$ comes with a type $T$, this definition affects the {\em self type} $S$ of the underlying class or objects as follows: Let $C$ be the type of the class or trait or object defining the template. If a type $T$ is given for the formal self parameter, $S$ is the greatest lower bound of $T$ and $C$. If no type $T$ is given, $S$ is simply $C$. Inside the template, the type of \code{self} is assumed to be $S$. 

The self type of a class or object must conform to the self types of all classes which are inherited by the template $t$. 

A second form of self type definition reads just ~\lstinline!requires self: $S$!~. It prescribes the type $S$ for \code{self} without introducing an alias name for it. 

% TBD: add distinction between use/requires to Aml naming guidelines (use-rename, requires-affect self type)

\example Consider the following class definitions:
\begin{lstlisting}
class Base extends Object; $\ldots$ end
trait Mixin extends Base; $\ldots$ end
object O extends Mixin; $\ldots$ end
\end{lstlisting}
In this case, the definition of \code{O} is expanded to be:
\begin{lstlisting}
object O extends Base with Mixin; $\ldots$ end
\end{lstlisting}





\subsection{Open Templates}
\label{sec:open-templates}

Unlike in Java, Scala or any other language that does not feature open classes, and similar to Ruby's open classes or C\#'s partial classes, Aml has a feature of open templates. This means that a single template (be it a class or a trait) can have its definition spread across several source files. 

An open template has a {\em main template}, which is the template that specifies the base class -- a property that can't be changed once set, and any number of {\em auxiliary templates}, which have only the limitation of not being able to define the base class (and a primary constructor, including the parent constructor invocation). However, it is possible for the auxiliary templates to define additional traits applied or prepended to the template. 

Auxiliary templates do not need to be eager loaded. There are basically three major ways to make use of an auxiliary template:
\begin{itemize}
  \item Eager loaded auxiliary template, using a file name scheme ~\lstinline!$t$.aux/$a$.aml!, where $t$ is the name of the template and $a$ is arbitrary auxiliary name. This way the auxiliary template is loaded along with the leading template, on-demand, without incrementing the template's version.
  \item Autoload (\sref{sec:autoloading}) of the auxiliary template. 
  \item On-demand load of the auxiliary template via independent ~\lstinline[deletekeywords={to}]!VM.load 'path/to/file'!, after the leading template is defined.
\end{itemize}





\subsection{Autoloading}
\label{sec:autoloading}

Autoloading is a mechanism of putting code from different source files and source directories together in runtime. There are two kinds of autoloading.

\paragraph{Implicit autoloading}
This kind of autoloading is basically the expected layout of source files, source directories and terms inside of a directory. Given that a root directory represents a module sources root, each template definition is expected to appear in a file that directly appears in this directory, preferably with a name of the included template. If multiple templates appear in one source file, then the implicit autoloading uses the mechanism of template index to track location of these templates. However, if the name of the template is generated dynamically in runtime (i.e. not via template definition or a constant initialization), then it needs to be loaded using explicit autoloading. 

\paragraph{Explicit autoloading}
This kind of autoloading is basically a custom definition of the layout of source files, source directories and terms inside of a directory. Explicit autoloading happens every time a member is accessed in a template and it is not defined. Explicit autoloading is defined in means of using the \code{autoload} method, provided by the \code{Class} class, and therefore available inside of any template definition. The method has the following overloaded declarations: 
\begin{lstlisting}
type Autoloaded_Term is Symbol or Regexp 
end type
def autoload (term: Autoloaded_Term, 
              path: String): Unit
end def
def autoload (term: Autoloaded_Term := nil, 
              callback: (t: Autoloaded_Term) -> Boolean): Unit
end def
\end{lstlisting}
The first overloaded variant generates an autoloading record that will autoload the source file from the given path. The second overloaded variant expects a callback that will return a boolean indicating whether the term was successfully autoloaded or not, also having the actual autoloaded term as an optional argument -- if the argument is omitted, then the callback is registered for every autoloading attempt.

With explicit autoloading, the runtime is allowed to keep track of templates that make use of explicit autoloading to optimize member resolution. If an explicit autoloading is added in runtime, the version number of the template has to be updated to invalidate member caches. 







\subsection{Constructor Invocations}
\label{sec:constructor-invocations}

\syntax\begin{lstlisting}
Constr ::= Annot_Type {'(' [Exprs] ')'}
         | '(' ')'
\end{lstlisting}

Constructor invocations define the type, members and initial state of objects created by an instance creation expression, or of parts of an object's definition, which are inherited by a class or object definition. A constructor invocation is a function application ~\lstinline!$c$[$\targs$]($\args_1$)$\ldots$($\args_n$)!~, where $c$ is a path to the superclass or an alias for the superclass, $\targs$ is a type argument list, $\args_1 \commadots \args_n$ are argument lists, and there is a constructor of that class which is applicable to the given arguments. 

A type argument list can be only given if the class $c$ takes type parameters. If no explicit arguments are given, an empty list ~\lstinline!()!~ is implicitly supplied if a superclass has a designated parameterless constructor, unless an explicit primary constructor definition is given, calling explicitly a super-constructor -- in that case, the constructor invocation only defines the superclass, and the invocation itself is deferred to the explicit primary constructor. 

A constructor invocation may choose any immediate superclass constructor, including designated and convenience constructors. In any case, such constructor must exist. The only exception to this rule is presented by the \code{Object} class, which does not have a superclass, and therefore no superclass constructor to invoke. 

Primary constructor evaluation happens in the following order in respect to the constructor invocation: 
\begin{enumerate}
  \item Default values are evaluated. 
  \item Early definitions are evaluated. Up to this point, this is true for any constructor. 
  \item Instance variables defined by the primary constructor are evaluated. 
  \item Superclass constructor is invoked. 
  \item Explicit primary constructor body---if one exists---is evaluated. 
\end{enumerate}





\subsection{Metaclasses \& Eigenclasses}
\label{sec:metaclasses}
\label{sec:eigenclasses}

\paragraph{\em Metaclasses}
A {\em metaclass} is a class whose instances are classes. Just as an ordinary class defines the behavior and properties of its instances, a metaclass defines the behavior of its class. Classes are first-class citizens in Aml. 

Everything is an object in Aml. Every object has a class that defines the structure (i.e. the instance variables) and behavior of that object (i.e. the messages the object can receive and the way it responds to them). Together this implies that a class is an object and therefore a class needs to be an instance of a class (called metaclass). 

Class methods actually belong to the metaclass, just as instance methods actually belong to the class. All metaclasses are instances of only one class called \code{Metaclass}, which is a subclass of the class \code{Class}. 

In Aml, every class (except for the root class \code{Object}) has a superclass. The base superclass of all metaclasses is the class \code{Class}, which describes the general nature of classes. 

The superclass hierarchy for metaclasses parallels that for classes, except for the class \code{Object}. The following holds for the class \code{Object}:
\begin{lstlisting}[deletekeywords={class}]
Object.class = Class[Object]
Object.superclass = nil
\end{lstlisting}

Classes and metaclasses are ``born together''. Every \code{Metaclass} instance has a method \code{this_class}, which returns the conjoined class. 

\paragraph{\em Eigenclasses}
Aml further purifies the concept of metaclasses by introducing {\em eigenclasses}, borrowed from Ruby, but keeping the \code{Metaclass} known from Smalltalk-80. Every metaclass is an eigenclass, either to a class, to a terminal object, or to another eigenclass\footnote{Eigenclasses of eigenclasses (``higher-order'' eigenclasses) are supposed to be rarely needed, but are there for conceptual integrity, establishing infinite regress.}. 

\begin{table}[ht]
  \centering
  \caption{Of objects, classes \& eigenclasses}
  \renewcommand{\arraystretch}{1.7}
  \begin{tabular}{ | >{\centering}m{3.5cm} | >{\centering}m{3.5cm} | >{\centering\arraybackslash}m{6cm} | }
  	\hline
    Classes & Eigenclasses of classes & \multirow{2}{*}{Eigenclasses of eigenclasses} \\ \cline{1-2}
    Terminal objects & Eigenclasses of terminal objects & \\
    \hline
  \end{tabular}
\end{table}

Eigenclasses are manipulated indirectly through various syntax features of Aml, or directly using the \code{eigenclass} method. This method can possibly trigger creation of an eigenclass, if the receiver of the \code{eigenclass} message did not previously have its own (singleton) eigenclass (because it was a terminal object whose eigenclass was a regular class, or the reciever was an eigenclass itself). 

Another way to access an eigenclass is to use the \lstinline!class << obj; $\ldots$; end! construct. The block of code inside runs is evaluated in the scope of the eigenclass of \code{obj}. 

\paragraph{\em Metaclass Access}
Metaclasses of classes may be accessed using the following language construct. 

\syntax\begin{lstlisting}
Metaclass_Access ::= 'class' '<<' Metaclass_Obj semi 
                     [Template_Body] 'end'
Metaclass_Obj    ::= Type | Path | 'self' | id
\end{lstlisting}

\example The following code shows how metaclasses are nested in case of \code{Object} type. Don't try this at home though. 
\begin{lstlisting}
class << Object
  self = Metaclass[Object]
  class << self
    self = Metaclass[Metaclass[Object]]
    class << self
      self = Metaclass[Metaclass[Metaclass[Object]]]
    end
  end
end
\end{lstlisting}

\example The following code shows what \code{self} references when inside of a class definition, but outside of any defined methods. 
\begin{lstlisting}
class Object extends ()
  self = Class[Object]
  class << self
    self = Metaclass[Object]
  end
end
\end{lstlisting}

\example Direct access to the eigenclass of any object, here a class' eigenclass:
\begin{lstlisting}
class A
begin
  class << self
    def a_class_method
      "A.a_class_method"
    end def
  end
end class
\end{lstlisting}
Class \code{A} uses the \lstinline!class << obj; $\ldots$; end! construct to get direct access to the eigenclass. The keyword \code{self} inside the block is bound to the eigenclass object. 

\example Alternative direct access to the eigenclass of any object, here a class' eigenclass:
\begin{lstlisting}
class B
begin
  self.eigenclass do
    def a_class_method
      "B.a_class_method"
    end def
  end
end class
\end{lstlisting}
Class \code{B} uses the \code{eigenclass} method, which---given a block---evaluates the block in the scope of the eigenclass of \code{self}, which is bound to the class \code{B}. The keyword \code{self} inside the block is again bound directly to the eigenclass object. 

\example Indirect access to the eigenclass using a singleton method definition:
\begin{lstlisting}
class C
begin
  def self.a_class_method
    "C.a_class_method"
  end def
end class
\end{lstlisting}
Class \code{C} uses singleton method definition to add methods to the eigenclass of the class \code{C}. The keyword \code{self} is bound to the class object in the class-level block and in the new method as well, but the eigenclass is accessed only indirectly. 

\example Indirect access to the eigenclass using a class object definition:
\begin{lstlisting}
class D
begin
  object D
    def a_class_method
      "D.a_class_method"
    end def
  end object
end class
\end{lstlisting}
Class \code{D} uses the recommended approach, utilizing standard ways of adding methods to the eigenclass of the class \code{D}. Here, the eigenclass instance itself is not accessed directly.  

\example Alternative indirect access to the eigenclass using a class object definition:
\begin{lstlisting}
object E
  def a_class_method
    "E.a_class_method"
  end def
end object
\end{lstlisting}
Class \code{E} uses a similar recommended approach, utilizing standard ways of adding methods to the eigenclass of the class \code{E} and neither declaring nor defining anything for its own instances. Here, the eigenclass instance itself is not accessed directly. 

\paragraph{Note}
If a metaclass of an object is edited, and such an object is returned from a function, then it might be a good idea to add the edits to its metaclass to the result type of such function, if appropriate, so that outside code may be able to non-dynamically use the edits. 





\subsection{Class Linearization}
\label{sec:class-linearization}

The classes reachable through transitive closure of the direct inheritance relation from a class $C$ are called the {\em base classes} of $C$. Because of traits, the inheritance relationship on base classes forms in general a directed acyclic graph. A linearization of this graph is defined as follows. 

\newcommand{\uright}{\;\vec +\;}
\newcommand{\lin}[1]{{\cal L}(#1)}

\begin{definition}
Let base classes of a class $C$ be the list of every superclass of $C$ with every trait that these classes include and/or prepend and every protocol that these classes implement. Let $C$ be a class with base classes ~\lstinline!$C_1$ with $C_2$ with $\ldots$ with $C_n$!. The {\em linearization} of $C$, $\lin C$ is defined as follows:
\bda{rcl}
\lin C &=& C\ , \ \lin{C_n} \uright \ldots \uright \lin{C_1}
\eda
Here $\uright$ denotes concatenation, where elements of the right operand replace identical elements of the left operand:
\bda{lcll}
\{a, A\} \uright B &=& a, (A \uright B)  &{\bf if}~a \not\in B \\
                 &=& A \uright B       &{\bf if}~a \in B
\eda
\end{definition}

\example Consider the following class definitions.\footnote{Here we say ``class'', but that term includes now traits as well.}
\begin{lstlisting}
class Abstract_Iterator extends Object; $\ldots$ end
trait Rich_Iterator extends Abstract_Iterator; $\ldots$ end
class String_Iterator extends Abstract_Iterator; $\ldots$ end
class Iterator extends String_Iterator with Rich_Iterator; $\ldots$ end
\end{lstlisting}
Then the linearization of class \code{Iterator} is
\begin{lstlisting}
{ Iterator, Rich_Iterator, String_Iterator, Abstract_Iterator, 
  Object }
\end{lstlisting}

Note that the linearization of a class refines the inheritance relation: if $C$ is a subclass of $D$, then $C$ precedes $D$ in any linearization where both $C$ and $D$ occur. Also note that whether a trait is included or prepended is irrelevant to linearization, but essential to function applications (\sref{sec:function-applications}).





\subsection{Inheritance Trees \& Include Classes}
\label{sec:inheritance-trees}
\label{sec:include-classes}

\paragraph{\em Include classes}
A mechanism that allows arbitrary including and prepending of trait into classes and inheritance binary trees\footnote{Yes, trees, not chains: prepended traits make the inheritance game stronger by forking the inheritance chain at each class with prepended traits, forming a shape similar to a rake.} uses a transparent structure called {\em include class}. Include classes are always defined indirectly.

Every class has a link to its superclass. In fact, the link is made up of an include class structure, which itself holds an actual link to the superclass. That superclass has its own link to its superclass and this chain goes forever until the \code{Any} class is encountered, which has no superclass. 

\paragraph{\em Included traits}
When a trait $M$ is included into a class, a new include class $Im_i$ is inserted between the target class and the include class $Is$ that holds a link to its superclass (or to a previously included trait $Im_{i+1}$). This include class $Im_i$ then holds a link to the included trait. Every class that includes the trait $M$ is available via the \code{included_in} method of $M$. 

If a trait $M$ is already (included in or prepended to)\footnote{This is important since both included and prepended traits act like superclasses to every subclass.} any of the superclasses, then it is not included again. Included traits act like superclasses of the class they are included in, and they {\em overlay} the superclasses. 

If a trait $M$ is polymorphic, it is only already (included in or prepended to) any of the superclasses, if the same trait's type instantiation is the one in question, and the same applies if the trait's name is overloaded, with the addition that a monomorphic trait is only already (included in or prepended to) any of the superclasses, if the monomorphic trait is. Therefore, a single trait name may be included multiple times, but only different type instantiations, or the monomorphic one. 

\example A sample trait schema:
\begin{lstlisting}
class C extends D with Some_Trait
end

C $\rightarrow$ [Some_Trait] $\rightarrow$ [D]
D $\rightarrow$ [Object]
\end{lstlisting}
Include classes are depicted by the brackets, with their link value inside. Note that include classes only know their super-type (depicted by the arrow ``$\rightarrow$'') and their link value (inside brackets). 

\paragraph{\em Prepended traits}
When a trait $M$ is prepended to a class, a new include class $Im_i$ is inserted between the target class and its last prepended trait, if any. Prepended traits are stored in a secondary inheritance chain just for prepended traits, forming an inheritance tree. Every class that has $M$ prepended is available via the \code{prepended_in} method of $M$. The effect of prepending a trait in a class or a trait is named {\em overlaying}. 

If a trait $M$ is already prepended to any of the superclasses, it has to be prepended again, since the already prepended traits of superclasses are in super-position to the class or trait that gets $M$ prepended. Prepended traits of superclasses do not {\em overlay} child classes. Prepended traits are inserted into the inheritance tree more like subclasses than superclasses. 

\paragraph{\em Nested includes}
% TBD: add the algorithm like with nested prepends, but this one is simpler
When a trait $M$ itself includes one or more traits $M_1 \commadots M_n$, then these included traits are inserted between the included trait $M$ and the superclass, unless they are already respectively included by any of the superclasses. If $M$ with included $M_1 \commadots M_n$ is prepended to $C$, then $M_1 \commadots M_n$ are inserted before the superclass of $C$, if not already included in any of the superclasses. It is an error if nested includes form a dependency cycle: any {\em auto-included} trait must not require to include a trait that triggered the auto-include. The order in which traits are included in another trait may change when included in a class, i.e. if the class includes two traits $A$ and $B$ that themselves include the same two traits $D$ and $E$ in reverse order ($A$ includes $D$, then $E$, but $B$ includes $E$, then $D$): the order is then defined by the first trait that included the two auto-included traits and subsequently included traits can not change this order in any way. 

\example Take the following trait and class definitions, where $S$ is the superclass of the class $C$:
\begin{lstlisting}
trait D end
trait E end

trait A extends D with E; end
trait B extends E with D; end

class C extends S with A with B; end
\end{lstlisting}
Then traits are auto-included in the following order:
\begin{itemize}
\item
\lstinline!C $\rightarrow$ [S]! \\
First, the superclass is added. 

\item
\lstinline!C $\rightarrow$ [A] $\rightarrow$ [S]! \\
Then, trait $A$ is included, unless already included in $S$. 

\item
\lstinline!C $\rightarrow$ [A] $\rightarrow$ [E] $\rightarrow$ [S]! \\
Including of trait $A$ triggers auto-include of traits included in $A$. Start with the first one in chain of $A$: $E$. 

\item
\lstinline!C $\rightarrow$ [A] $\rightarrow$ [E] $\rightarrow$ [D] $\rightarrow$ [S]! \\
Then, $A$ has $D$ in its chain. 

\item
\lstinline!C $\rightarrow$ [B] $\rightarrow$ [A] $\rightarrow$ [E] $\rightarrow$ [D] $\rightarrow$ [S]! \\
Finally include $B$. $B$ triggers auto-include, but both of its included traits are already included in the chain, so nothing more happens. 
\end{itemize}
Note that the order of $E$ and $D$ is reversed, since later includes move the trait closer to the including class or trait, and therefore \code{super} calls go through traits that were included before. Also, if $B$ was included sooner than $A$, then $D$ and $E$ would appear in reverse order in the chain. 

\paragraph{\em Nested prepends}
When a trait $M$ itself prepends one or more traits $M_1 \commadots M_n$, then nothing happens to the class or the trait that $M$ is included in. If $M$ is prepended to $C$, then every trait $M_1 \commadots M_n$ prepended to $M$ is automatically prepended to $C$ in this way:
\begin{enumerate}
\item
Establish a list of traits that triggered auto-prepend, named here $tp$. This list is in ideal case empty, so it's actually ok for the runtime to wait with its creation until needed and only increase its size in very small steps. 

\item
Establish a list of traits that are scheduled to be auto-prepended, named here $sp$. This list is in ideal case empty, again. 

\item
There is a {\em prepend chain} in the class that prepends $M$. If no trait was prepended so far, create it. The chain's head is the element that is the farthest from the class $C$, the chain's tail is right before the class $C$. Traits closer to this chain's head are searched for method overlays sooner in runtime than traits closer to the tail (and the class respectively). 

\item
Insert $M$ at the chain's head, unless $M$ already is in the chain. If it is, then halt. 

\item 
If $M$ has itself prepended traits, insert $M$ into $tp$ (triggered prepend). 

\item
For traits $M_1 \commadots M_n$ that are prepended in $M$, test if each $M_i$ already appears in the chain. If it does, move $M$ up the chain towards the chain's tail, right until $M$ is closer to the chain's tail than $M_i$. If it does not, add $M_i$ to $sp$, unless $M_i$ is in $tp$. If it is, then it is an error\footnote{Trait cycle dependency detected.}. 

\item
If $M$ has included traits, include them in $C$ in the already described way now. 

\item
If $sp$ is not empty, then for each $M_i$ in $sp$, remove $M_i$ from $sp$ and recursively apply steps starting with 4 on it. Keep both $sp$ and $tp$ shared for recursive calls. If $M_i$ moves closer to the chain's tail than $M$ or any other trait prepended in prepending of the original $M$\footnote{This can be achieved by having a third list of traits that were prepended.}, it is an error\footnote{Trait composition design flaw detected.}. 
\end{enumerate}

\paragraph{\em Traits \& Metaclasses}
Since traits may contain ``class'' methods as well as instance methods, all the operations with include classes are mirrored on the respective metaclasses.\footnote{This makes Aml in no need of constructs like \lstinline[language=Ruby]!module ClassMethods!, known from Ruby.}





\subsection{Class Members}
\label{sec:class-members}

A class $C$ defined by a template ~\lstinline!$C_1$ with $\ldots$ with $C_n$ { $\stats$ }!~ can define members in its statement sequence $\stats$ and can inherit members from all parent classes. Aml uses overloading of methods, therefore it is possible for a class to define and/or inherit several methods with the same name. To decide whether a defined member of a class $C$ overrides a member of a parent class, or whether the two co-exist as overloaded alternatives in $C$, Aml uses the following definition of {\em matching} on members:

\begin{definition}
A member definition $M$ {\em matches} a member definition $M'$, if $M$ and $M'$ bind the same name, and one of the following conditions holds.
\begin{enumerate}
\item Neither $M$ nor $M'$ is a method definition.
\item $M$ is override-matching $M'$ (\sref{sec:method-signature}). 
\end{enumerate}
\end{definition}

Member definitions fall into two categories: {\em concrete} and {\em abstract}. Members of class $C$ are either {\em directly defined} (i.e. they appear in $C$'s statement sequence $\stats$), or they are {\em inherited}. There are rules that determine the list of members of a class:

\begin{definition}
A {\em concrete member} of a class $C$ is any concrete definition $M$ in some class $C_i \in \lin{C}$, except if there is a preceding (or even prepended) class $C_j \in \lin{C}$, where $j < i$, which directly defines a concrete member $M'$ matching $M$, where the $M'$ is then the concrete member. 

An {\em abstract member} of a class $C$ is any abstract definition $M$ in some class $C_i \in \lin{C}$, except $C$ already contains a concrete member $M'$ matching $M$, or if there is a preceding (or even prepended) class $C_j \in \lin{C}$, where $j < i$, which directly defines a concrete member $M'$ matching $M$, where the $M'$ is then the concrete member. 
\end{definition}

This definition also determines the overriding relationship between matching members of a class $C$ and its parents (\sref{sec:overriding}). First, a concrete definition always overrides an abstract definition. Second, for definitions $M$ and $M'$, which are both concrete or both abstract, $M$ overrides $M'$ if $M$ appears in a class that precedes (in the linearization of $C$) the class in which $M'$ is defined. 

It is an error if a template directly defines two matching members. 




\subsection{Overriding}
\label{sec:overriding}

A member $M$ of a class $C$ that matches a member $M'$ of a base class of $C$ is said to {\em override} that member. In this case the binding of the overriding member $M$ must conform (\sref{sec:conformance}) to the binding of the overridden member $M'$. Furthermore, the following restrictions on modifiers apply to $M$ and $M'$: 
\begin{itemize}
\item 
$M'$ must not be labeled \lstinline!final!. 

\item 
$M$ must not be \lstinline!private!. 

\item 
If $M$ is labeled \lstinline!private[$C$]! for some enclosing class or module $C$, then $M'$ must be labeled \lstinline!private[$C'$]!, where $C'$ equals $C$ or $C$ is contained in $C'$.

\item 
If $M$ is labeled \lstinline!protected!, then $M'$ must also be labeled \lstinline!protected!. 

\item 
If $M'$ is labeled \lstinline!protected!, then $M'$ must also be labeled \lstinline!protected! or \lstinline!public!. 

\item
If $M'$ is not an abstract member, then $M$ should be labeled \lstinline!override! or annotated \lstinline!@[override]!. Furthermore, one of the possibilities must hold:
\begin{itemize}
\item either $M$ is defined in a subclass of the class where $M'$ is defined,
\item or both $M$ and $M'$ override a third member $M''$, which is defined in a base class of both the classes containing $M$ and $M'$.
\end{itemize}

\item 
If $M'$ is labeled \lstinline!private!, then $M'$ must be labeled \lstinline!private!, \lstinline!protected! or \lstinline!public!. 

\item
If $M'$ is incomplete (\sref{sec:modifiers}) in $C$, then $M$ should be labeled \lstinline!abstract override!. 

\item
If $M$ and $M'$ are both concrete value definitions, then either none of them is marked \lstinline!lazy!, or both must be marked \lstinline!lazy!. 
\end{itemize}

To generalize the conditions, the modifier of $M$ must be the same or less restrictive than the modifier of $M'$. 

An overriding method, unlike in Scala, does not inherit any default arguments from the definition in the superclass, but, as a convenience, if the default argument is specified as ~`\lstinline!_!', then it gets inherited. 





\subsection{Inheritance Closure}
\label{sec:inheritance-closure}

\newcommand{\inheritclosure}{{\cal S}}

Let $C$ be a class type. The {\em inheritance closure} of $C$ is the smallest set $\inheritclosure$ of types such that
\begin{itemize}
\item If $T$ is in $\inheritclosure$, then every type $T'$ which forms syntactically a part of $T$ is also in $\inheritclosure$. 
\item If $T$ is a class type in $\inheritclosure$, then all parents of $T$ (\sref{sec:templates}) are also in $\inheritclosure$. 
\end{itemize}
It is an error if the inheritance closure of a class type consists of an infinite number of types. 






\subsection{Early Definitions}
\label{sec:early-defs}

\syntax\begin{lstlisting}
Early_Defs ::= '{' [Early_Def {semi Early_Def}] '}' 
               'with'
Early_Def  ::= {Annotation} {Modifier} (Var_Def | Val_Def)
\end{lstlisting}

A template may start with an {\em early definition} clause, which serves to define certain field values before the supertype constructor is called. In a template
\begin{lstlisting}
{
  val $p_1$: $T_1$ := $e_1$
  $\ldots$
  val $p_n$: $T_n$ := $e_n$
} with $sc$ with $mt_1$ with $\ldots$ with $mt_n$
\end{lstlisting}
The initial pattern definitions of $p_1 \commadots p_n$ are called {\em early definitions}. They define fields which form part of the template. Every early definition must define at least one field. 

Any reference to \code{self} in the right-hand side of an early definition refers to the identity of \code{self} just outside the template, not inside of it. As a consequence, it is impossible for any early definition to refer to the object being constructed by the template, or refer to any of its fields, except for any other preceding early definition in the same section. 







\section{Modifiers}
\label{sec:modifiers}

\syntax\begin{lstlisting}
Modifier         ::= Local_Modifier
                   | Access_Modifier
                   | 'override' [Class_Qualifier]
Local_Modifier   ::= 'implicit'
                   | 'lazy'
                   | 'final'
                   | 'sealed'
                   | 'abstract'
Access_Modifier  ::= 'public'
                   | ('protected' | 'private') [Access_Qualifier]
Access_Qualifier ::= '[' (id | 'self') ']'
Mutability       ::= 'mutable' | 'immutable'
\end{lstlisting}

Access modifiers may appear in two forms:

\paragraph{\em Accessibility flag modifier}
Such a modifier appears in a template (\sref{sec:templates}) or a module definition (\sref{sec:modules}) alone on a single line. All subsequent members in the same class-level block than have accessibility of this modifier applied to them, if allowed to (does not apply to destructors). Only access modifiers can be used this way. 

\paragraph{\em Directly applied modifier}
Such a modifier appears on a line preceding a member to which the modifier is solely applied, or a list of arguments with symbols that the modifier will be applied to. A directly applied modifier expression has a result type of \code{Symbol}, so that it may be used as a regular function and chained. 

\example An example of an accessibility flag modifier:
\begin{lstlisting}
class C
begin
  public
    def hello; end
  private
    def private_hello; end
end class
\end{lstlisting}

\example An example of directly applied modifier:
\begin{lstlisting}
class C
begin
  def hello; end
  def private_hello; end
  def salute; end
  public :hello
  private :private_hello, :salute
  protected def goodbye; end
end class
\end{lstlisting}

By default\footnote{That is, without any explicit modifier being applied.}, the \code{public} access modifier affects every member of the class type, except for instance variables and class instance variables, which are object-private (\lstinline!private[self]!). 

Modifiers affect the accessibility and usage of the identifiers bound by them. If several modifiers are given, their order does not matter, but the same modifier may not occur more than once and combinations of \code{public}, \code{protected} \& \code{private} are not allowed (using them as accessibility flag modifiers overwrites the previous accessibility, not combines them). If a member declaration has a modifier applied to it, then the subsequent member definition has the same modifier already applied to it as well, without the need to explicitly state that. It is an error if the modifier applied to the member definition would contradict the modifier applied to the member declaration. 

Accessibility modifiers can not be applied to instance variables and class instance variables (both declarations and definitions). These are by default {\em instance-private}. This is a sort of relaxation in access restriction, say, every method that is at least {\em public} and at most {\em object-private} restricted, and that has the instance as a receiver, can access the instance variable or the class instance variable. Any other method that does not have the particular instance as the receiver, does not have any access to the instance variable or the class instance variable, even if the method is a method of the same class as the particular instance. 

The rules governing the validity and meaning of a modifier are as follows: 
\begin{itemize}
  \item The \code{private} access modifier can be used with any declaration or definition in a class. Such members can be accessed only from within the directly enclosing class, the class object (\sref{sec:object-definitions}) and any member of the directly enclosing class, including inner classes. They are not inherited by subclasses and they may not override definitions in parent classes. 

  The modifier may be {\em qualified} with an identifier $C$ (e.g. \lstinline!private[$C$]!) that must denote a class or a module enclosing the declaration or definition. Members labeled with such a modifier are accessible respectively only from code inside the module $C$ or only from code inside the class $C$ and the class object $C$ (\sref{sec:object-definitions}). 

  A different form of qualification is \lstinline!private[self]!. A member $M$ marked with this modifier is called {\em object-private}; it can be accessed only from within the object in which it is defined. That is, a selection \lstinline!$p$.$M$! is only legal if the prefix ends with \code{this} or \code{self} and starts with $O$ for some class $O$ enclosing the reference. . Moreover, the restrictions for unqualified \code{private} apply as well. 

  Members marked \code{private} without any qualifier are called {\em class-private}. A member {\em is private} if it is either class-private or object-private, but not if it is marked \lstinline!private[$C$]!, where $C$ is an identifier, in the latter case the member is called {\em qualified private}. 

  Class-private and object-private members must not be \code{abstract}, since there is no way to provide a concrete implementation for them, as private members are not inherited. Moreover, modifiers \code{protected} \& \code{public} can not be applied to them (that would be a contradiction\footnote{E.g., a member can not be public and private at the same time.}), and the modifier \code{override} can not be applied to them as well\footnote{Otherwise, if a private member could override an inherited member, that would mean there is an inherited member that could be overridden, but private members can not override anything: only protected and public members can be overridden. If a member was overriding an inherited member, the parent class would {\em lose access} to it.}. 

  \item The \code{protected} access modifier can be used with any declaration or definition in a class. Protected members of a class can be accessed from within: 
  \begin{itemize}
    \item the defining class
    \item all classes that have the defining class as a base class
    \item all class objects of any of those classes
  \end{itemize}

  A \code{protected} access modifier can be qualified with an identifier $C$ (e.g. \lstinline!protected[$C$]!) that must denote a class or module enclosing the definition. Members labeled with such a modifier are {\em also}\footnote{In addition to unqualified \code{protected} access.} accessible respectively from all code inside the module $C$ or from all code inside the class $C$ and its class object $C$ (\sref{sec:object-definitions}). 

  A protected identifier $x$ can be used as a member name in a selection \lstinline!$r$.$x$! only if one of the following applies: 
  \begin{itemize}
    \item The access is within the class defining the member, or, if a qualification $C$ is given, inside the module $C$, the class $C$ or the class object $C$, or
    \item $r$ ends with one of the keywords \code{this}, \code{self} or \code{super}, or
    \item $r$'s type conforms to a type-instance of the class which has the access to $x$. 
  \end{itemize}

  A different form of qualification is \lstinline!protected[self]!. A member $M$ marked with this modifier can be accessed only from within the object in which it is defined, including methods from inherited scope. That is, a selection \lstinline!$p$.$M$! is only legal if the prefix ends with \code{this}, \code{self} or \code{super} and starts with $O$ for some class $O$ enclosing the reference. Moreover, the restrictions for unqualified \code{protected} apply. 

  \item The \code{override} modifier applies to class member definitions and declarations. It is never mandatory, unlike in Scala or C\# (in further contrast with C\#, every method in Aml is virtual, so Aml has no need for a keyword ``\code{virtual}''). On the other hand, when the modifier is used, it is mandatory for the superclass to define or declare at least one matching member (either concrete or abstract). If the optional class qualifier is present after the \code{override} modifier, then a supertype of the given simple name or identified by the stable id has to provide a member that this modifier is applied to, either abstract or concrete, and it is an error if it does not. 

  \item The \code{override} modifier has an additional significance when combined with the \code{abstract} local modifier. That modifier combination is only allowed for members of traits. 

  We call a member $M$ of a class or trait {\em incomplete} if it is either abstract (i.e. defined by a declaration), or it is labeled \code{abstract} and \code{override} and every member overridden by $M$ is again incomplete. 

  The \code{abstract override} modifier combination does not influence the concept whether a member is concrete or abstract. A member is {\em abstract} if only a declaration is given for it; it is {\em concrete} if a full definition is given. This behavior can be turned off only in tests, if needed, and is implicitly turned on. 

  The \code{abstract override} modifier combination can be thus used with a full definition in a trait and yet affect the class or trait with which it is used, so that a member access to member \code{abstract override $M$}, such as \lstinline!super.$M$!, is legal. But, the \code{abstract override} modifier combination does not need to be applied to a definition, a declaration is good enough for it. 

  Additionally, an annotation \lstinline!@[Override]! exists for class members that triggers only warnings in case the member has no inherited member to override, but does not prevent the class from being created. Thus, the annotation only signals an intention, the keyword modifier signals a requirement. 

  \item The \code{abstract} local modifier is used in class declarations. It is never mandatory for classes with incomplete members or for declarations and definitions. It is implied (and therefore redundant) for traits. Abstract classes can not be instantiated (an exception is raised if tried to do so), unless provided with traits and/or a refinement which override all incomplete members of the class. Only abstract classes and (all) traits can have abstract term members. This behaviour can be turned off only in tests, if needed, and is implicitly turned on. 

  The \code{abstract} local modifier can be used with conjunction with \code{override} modifier for class member definitions. 

  Additionally, an annotation \lstinline!@[Abstract]! exists for classes and class members that triggers only warnings in case of instantiation, but does not prevent the instantiation. Thus, the annotation only signals an intention, the keyword modifier signals a requirement. 

  \item The \code{final} local modifier applies to class members definitions and to class definitions. Every \code{final} class member can not be overridden in subclasses. Every \code{final} class can not be inherited by a class or trait. Members of final classes are implicitly also final. Note that \code{final} may not be applied to incomplete members, and can not be combined in one modifier list with the \code{sealed} local modifier. 

  Additionally, an annotation \lstinline!@[Final]! exists for classes and class members that triggers only warnings in case of inheriting or overriding respectively, but does not prevent the inheritance or overriding respectively. Thus, the annotation only signals an intention, the keyword modifier signals a requirement. 

  \item The \code{sealed} local modifier applies to class definitions. A \code{sealed} class can not be directly inherited, except if the inheriting class or trait is defined in the same source file as the inherited sealed class. However, subclasses of a sealed class have no restriction in inheritance, unless they are final or sealed again. 

  Additionally, an annotation \lstinline!@[Sealed]! exists for classes and class members that triggers only warnings in case of inheriting outside the same source file, but does not prevent the inheritance. Thus, the annotation only signals an intention, the keyword modifier signals a requirement. 
  
  \item The \code{mutable} mutability modifier guarantees that all member values of the type that it is applied to will not be immutable, hence not frozen. It transitively applies to all subtypes, and is disallowed when any of the parents of the type is declared to be immutable. It is an error to freeze values that are declared mutable. 
  
  \item The \code{immutable} mutability modifier guarantees that all member values of the type that it is applied to will be immutable, hence frozen. It transitively applies to all subtypes, and is disallowed when any of the parents of the type is declared to be mutable. When applied to classes, it does so by implicitly freezing all values right before all their constructors are finished\footnote{Freezing is re-entrant and irreversible. If a constructor freezes a value explicitly, nothing is wrong.}. 

  \item The \code{lazy} local modifier applies to value definitions. A \code{lazy} value is initialized the first time it is accessed (which might eventually never happen). Attempting to access a lazy value during its initialization is a blocking invocation until the value is initialized of failed to initialize. If an exception is thrown during initialization, the value is considered uninitialized and the initialization is restarted on later access, re-evaluating its right hand side. 

\example The following code illustrates the use of qualified and unqualified private: 
\begin{lstlisting}
module Outer_Mod.Inner_Mod
  class Outer
  begin
    class Inner
    begin
      private[self] def e() end def
      private def f() end def
      private[Outer] def g() end def
      private[Inner_Mod] def h() end def
      private[Outer_Mod] def i() end def
    end class
  end class
end module
\end{lstlisting}
Here, accesses to the method \code{e} can appear anywhere within the instance of \code{Inner}, provided that the instance is also the receiver at the same time. Accesses to the method \code{f} can appear anywhere within the class \code{Inner}, including all receivers of the same class. Accesses to the method \code{g} can appear anywhere within the class \code{Outer}, but not outside of it. Accesses to the method \code{h} can appear anywhere within the module \code{Outer_Mod.Inner_Mod}, but not outside of it, similar to package-private methods in Java. Finally, accesses to the method \code{h} can appear anywhere within the module \code{Outer_Mod}, including modules and classes contained in it, but not outside of these.

\end{itemize}

A rule for access modifiers in scope of overriding: Any overriding member may be defined with the same access modifier, or with a less restrictive access modifier. No overriding member can have more restrictive access modifier, since the parent class would {\em lose access} to the member, and that is unacceptable. 
\begin{itemize}
\item Modifier \code{public} is less restrictive than any other access modifier. 
\item Qualified modifier \code{protected} is less restrictive than an unqualified \code{protected}, only if the class that the modifier is qualified with is among base classes of the original class -- the original class must not lose access. 
\item Qualified modifier \code{protected} is less restrictive than object-protected, only if the class that the modifier is qualified with is among base classes of the original class -- the original class must not lose access. 
\item While \code{protected} is certainly less restrictive than \code{private}, private members are not inherited and thus can not be overridden. 
\item While qualified \code{private} is certainly less restrictive than unqualified \code{private}, private members are not inherited and thus can not be overridden. 
\end{itemize}
The relaxations of access modifiers for overriding members are then available as follows: 
\begin{itemize}
\item \lstinline!protected[self] $\rightarrow$ { protected, protected[$C$], public }!
\item \lstinline!protected $\rightarrow$ { protected[$C$], public }!
\item \lstinline!protected[$C$] $\rightarrow$ { protected[$D$], public }!

This is only for the case where $C$ is accessible from within $D$. 
\item \lstinline!protected[$C$] $\rightarrow$ { public }!
\item \lstinline!public $\rightarrow$ { public }!

This is just for the sake of completeness, since change from public to public is not much of a relaxation. 
\end{itemize}






\section{Class Definitions}
\label{sec:class-definitions}

\syntax\begin{lstlisting}
Class_Definition    ::= [Mutability] 'class' Class_Def
Class_Def           ::= id [Type_Param_Clause] 
                        [Class_Param_Clauses] Class_Tmpl_Env
Class_Param_Clauses ::= {Annotation} [Access_Modifier] 
                        {Class_Param_Clause}
                        ['(' 'implicit' Class_Params ')']
Class_Param_Clause  ::= '(' [Class_Params] ')'
Class_Params        ::= Class_Param {',' Class_Param}
Class_Param         ::= Param
Class_Tmpl_Env      ::= Tmpl_Env_With_Pars ['class']
                      | Tmpl_Env_Brackets
                      | Tmpl_Env_No_Pars ['class']
Tmpl_Env_With_Pars  ::= 'extends' [Early_Defs] Class_Parents
                        semi ['begin'] [Template_Body] 'end'
Tmpl_Env_Brackets   ::= ['extends' [Early_Defs]] 
                        '{' [Template_Body] '}'
Tmpl_Env_No_Pars    ::= ['begin' [Template_Body]] 'end'
\end{lstlisting}

A class definition defines the type signature, behavior and initial state of a class of objects (the instances of the defined class) and of the class object, which is the class instance itself, with behavior defined in its metaclass (\sref{sec:metaclasses}). 

The most general form of a class definition is
\begin{lstlisting}
class $c$ [$\tps$]
  $\as$ $m$($\ps_1$)$\ldots$($\ps_n$)
  extends $t$
\end{lstlisting}
for $n \geq 0$. 

Here, 
\begin{itemize}
\item[]
$c$ is the name of the class to be defined. 

\item[]
$\tps$ is a non-empty list of type parameters of the class being defined. The scope of a type parameter is the whole class definition including the type parameter section itself. It is an error to define two type parameters with the same name. The type parameter section \lstinline![$\tps$]! may be omitted. A class with a type parameter section is called {\em polymorphic}, a class without a type parameter section is called otherwise {\em monomorphic}. Type arguments are reified in Aml, i.e. type arguments are preserved in runtime\footnote{Unlike in Java or Scala, which both perform type erasure.}, generating a new concrete subtype of the original generic class. This ensures type safety in a dynamic environment of Aml in runtime. 

\item[]
$\as$ is a possibly empty sequence of annotations (\sref{sec:annotations}). If any annotations are given at this point, they apply to the primary constructor of the class. 

\item[]
$m$ is an access modifier (\sref{sec:modifiers}), such as \code{private} or \code{protected} (\code{public} is implied otherwise), possibly with a qualification. If such an access modifier is given, it applies to the primary constructor of the class. 

\item[]
$(\ps_1)\ldots(\ps_n)$ are formal value parameter clauses for the {\em primary constructor} of the class. The scope of a formal value parameter includes all subsequent parameter sections and the template $t$. However, a formal value parameter may not form part of the types of any of the parent classes or members of the class template $t$ -- only parameters from $\tps$ may form part of the types of any of the parent classes or members of the class template $t$. It is illegal to define two formal value parameters with the same name. If no formal parameter sections are given, an empty parameter section \lstinline!()! is implied. 

\item[]
If a formal parameter declaration ~\lstinline!$x$: $T$!~ is preceded by a \code{val} or \code{var} keyword, an accessor (getter) definition (\sref{sec:value-dcl-def}) for this parameter is implicitly added to the class. The getter introduces a value member $x$ of class $c$ that is defined as an alias of the parameter. Moreover, if the introducing keyword is \code{var}, a setter accessor ~\lstinline!$x$_=($e$)!~ is also implicitly added to the class. The formal parameter declaration may contain modifiers, which then carry over to the accessor definition(s). A formal parameter prefixed by \code{val} or \code{var} may not at the same time be a call-by-name parameter (\sref{sec:by-name-parameters}). 

\item[]
If a formal value parameter is a part of the definition of a property (a property getter and/or a property value), then these accessors are not implicitly added, as the arguments may be traced into the properties. The same applies to instance value definitions that have a formal value parameter forming a part of it. In any case, every formal value parameter is implicitly added as an instance value definition of  a \code{val} or \code{var} type respectively. 

\item[]
$t$ is a template (\sref{sec:templates}) of the form
\begin{lstlisting}
$sc$ with $mt_1$ with $\ldots$ with $mt_n$ { $\stats$ }
\end{lstlisting}
for $(n \geq 0)$, which defines the base classes, behavior and initial state of objects of the class. The extends clause ~\lstinline!extends $sc$ with $mt_1$ with $\ldots$ with $mt_n$!~ can be omitted, in which case ~\lstinline!extends Object!~ is implied. The only class that defines $sc$ as ~\lstinline!()!~ is \code{Object} (meaning that it has no superclass) and it is an error if any other class attempts to do the same. 

\end{itemize}

This class definition defines a type ~\lstinline!$c$[$\tps$]!~ and a primary constructor, which, when applied to arguments conforming to types $\ps$, initializes instances of type ~\lstinline!$c$[$\tps$]!~ by evaluating the primary constructor parts defined in the template $t$. 

\example The following example illustrates \code{val} and \code{var} parameters of a class \code{C}: 
\begin{lstlisting}
class C (x: Integer, val y: String, var z: List[String]) end
val c := C.new(1, "abc", List[String].new)
c.z := c.y ~> c.z
\end{lstlisting}

\example The following class can be created only from its class object. 
\begin{lstlisting}
class Sensitive private () {
  $\ldots$
}
object Sensitive {
  def make_sensitive (credentials: Certificate): Sensitive := {
    if credentials.admin?
      Sensitive.new
    else 
      raise SecurityViolationException
    end
  }
}
\end{lstlisting}





\subsection{Polymorphic \& Monomorphic Class Overloading}
\label{sec:poly-mono-morphic-classes}

As defined earlier, a class with a type parameter section \lstinline![$\tps$]! is called {\em polymorphic}, a class without a type parameter section is called otherwise {\em monomorphic}. Furthermore, classes may be distinguished from each other by the count of their type parameters, in which case overloading resolution on their names apply -- and classes that are monomorphic are ``more specific'' than classes that are polymorphic, in case the class name appears without a type application.

\paragraph{Note}
If full type inference is desired for a polymorphic class $c$, then constructs such as the following can be used:
\begin{lstlisting}
(* for polymorphic class with 1 type parameter *)
$c$[_] 

(* for polymorphic class with 2 type parameters *)
$c$[_, _] 

(* for polymorphic class with 3 type parameters *)
$c$[_, _, _] 

(* for polymorphic class with 1 or more type parameters,
   when there is only one such polymorphic class *)
$c$[*_]
\end{lstlisting}

\paragraph{Note}
Partial type inference is also possible: 
\begin{lstlisting}
(* for polymorphic class with 2 type parameters *)
$c$[_, String] 

(* for polymorphic class with 3 type parameters *)
$c$[_, Number, _] 

(* for polymorphic class with 2 or more type parameters,
   when there is only one such polymorphic class *)
$c$[String, *_]
\end{lstlisting}





\subsection{Constructor \& Destructor Definitions}
\label{sec:constructor-destructor-def}

\paragraph{\em Primary constructor}
The primary constructor is a special function, more special in its syntax than any other function in Aml. Its definition can spread across three syntactically different places inside of a class definition: formal value parameters, explicit field declarations, explicit primary constructor body. Primary constructor without explicitly defined parameters is equivalent to the default constructor. 

\paragraph{\em Primary constructor parameters}
These are described as a part of class definitions (\sref{sec:class-definitions}). Technically, a primary constructor is happy being left with nothing but the parameter definitions, since these are always automatically mapped to instance values\footnote{Making this behavior overrideable may be discussed, but it might interfere with case classes.} and also implicitly adds accessor methods to the class with appropriate visibility, defined explicitly by accessor modifiers (\sref{sec:modifiers}) or implicitly as \code{public}. 

\paragraph{\em Explicit primary constructor fields}
These are expressions inside the class template (\sref{sec:templates}) that refer to the formal value parameters, and they become an implicit part of the primary constructor. The evaluation happens after early definitions are evaluated and before explicit primary constructor body is evaluated, but combinations of the two approaches should be avoided for the sake of readability -- the only expressions that the formal value parameters should appear in are simple instance variable definitions. 

\paragraph{\em Explicit primary constructor body}
If a primary constructor should do something more than simply map parameters to instance values, then its explicit body comes in. It may co-exist with explicit primary constructor fields, which are then executed right after a call to the super-constructor (either in implicit position, or an explicit one). 

\syntax\begin{lstlisting}
Def             ::= PCtor_Def
PCtor_Def       ::= 'constructor' PCtor_Fun_Def
PCtor_Fun_Def   ::= 'do' (Constr_Expr | Constr_Block)
Constr_Expr     ::= Self_Invocation
                  | Constr_Block2
Self_Invocation ::= 'self' Arguments
                  | Sup_Invocation
Sup_Invocation  ::= 'super' [Arguments]
Constr_Block    ::= Constr_Block1 | Constr_Block2
Constr_Block1   ::= [semi Constr_Block3] 'end' ['constructor']
Constr_Block2   ::= '{' [Constr_Block3] '}'
Constr_Block3   ::= [[Block_Stat {semi Block_Stat} semi] 
                    Self_Invocation semi] 
                    Block_Stat {semi Block_Stat}
                  | Self_Invocation
\end{lstlisting}

\paragraph{Auxiliary constructors}
Besides the primary constructor, a class may define additional constructors with different parameter sections, that form together with the primary constructor an overloaded constructor definition. Every auxiliary constructor is constrained in means that it has to either invoke another constructor defined before itself, or any superclass constructor. Therefore classes in Aml have multiple entry points, but with great power comes great responsibility: user must ensure that every constructor path defines all necessary members. It is an error if a constructor invocation leads to an instance with abstract members. If a constructor does not explicitly invoke another constructor, an invocation of the implicit constructor is inserted implicitly as the first invocation in the constructor. 

\syntax\begin{lstlisting}
Ctor_Def     ::= ['convenience'] 'constructor' Ctor_Fun_Def
Ctor_Fun_Def ::= [Param_Clauses] (':=' Constr_Expr | Constr_Block)

Dtor_Def     ::= 'destructor' Dtor_Fun_Def
Dtor_Fun_Def ::= (':=' Dtor_Expr | Dtor_Block)
Dtor_Expr    ::= Sup_Invocation
               | Dtor_Block2
Dtor_Block   ::= Dtor_Block1 | Dtor_Block2
Dtor_Block1  ::= [semi Dtor_Block3] 'end' ['destructor']
Dtor_Block2  ::= '{' [Dtor_Block3] '}'
Dtor_Block3  ::= [[Block_Stat {semi Block_Stat} semi] 
                 Sup_Invocation semi] 
                 Block_Stat {semi Block_Stat}
               | Sup_Invocation
\end{lstlisting}

\paragraph{\em Implicit constructor}
An implicit constructor is an automatically generated constructor. This is what Java and C\# call ``default constructor''. An implicit constructor ``does nothing'' but invokes the super-constructor and initializes all members specific to the constructed object to their default values (either implicit one, which is \code{nil}, or explicit ones used in their definitions), so that an explicit empty constructor would not have to be specified. Implicit constructor can only be generated if all members have a default value and the superclass has a parameterless designated constructor. 

\paragraph{\em Designated constructor}
A designated constructor is such a constructor that initializes all members of the class. The primary constructor always has to be also a designated constructor. A designated constructor can only call a constructor of the immediate superclass\footnote{This is a relaxation from Swift by Apple, which only allows to call a designated constructor of the immediate superclass.}. A single class may have multiple designated constructors, but either way all instance members have to be initialized and at least one designated constructor has to exist. Note that new instance members may be added dynamically in runtime -- but those are also initialized at the time they are added by the dynamic code. Also note that the constructor of the superclass may be dealing with an incomplete object\footnote{As the constructors may further edit the new object later.}, therefore a designated constructor must make sure that all instance members are initialized (either with their default values, or ones set up by the constructor), before it delegates up to the constructor of the superclass. 

\paragraph{\em Convenience constructor}
A convenience constructor is any other constructor than the designated constructors. It can only call a constructor of the same class (either convenience or designated). Convenience constructors are annotated with \code{convenience} keyword. Any convenience constructor must ultimately call a designated constructor of the same class. 

\paragraph{\em Inheritance of constructors}
Constructors are not automatically inherited. Constructors whose signature matches signature of a superclass constructors have to be prefixed with the \code{override} modifier (\sref{sec:modifiers}). The following rules apply to inheritance of constructors:
\begin{enumerate}
  \item[Rule 1] The subclass must define default values for all new introduced instance variables for any constructor inheritance to take place. 
  \item[Rule 2] If the subclass does not define any designated constructors (and does not define primary constructor parameters, including empty parentheses), it automatically inherits all of its superclass designated constructors. 
  \item[Rule 3] If the subclass provides implementation of all of its superclass designated constructors---either by inheriting them as per rule 2, or by providing a custom implementation as a part of its own definition---then it automatically inherits all of the superclass convenience constructors. 
\end{enumerate}

\paragraph{Phases of object construction}
The following lists present the order in which object construction occurs.

{\bfseries Phase 1}
\begin{enumerate}
  \item Somebody calls the \code{new} instance method of \code{Class} with arguments for the desired constructor. 
  \item A constructor is picked up with a 1:1 mapping to the arguments of \code{new}. 
  \item A memory is allocated for the new object. The memory is not yet initialized, and so is not the object. 
  \item Runtime keeps track of all declared instance variables and their defined-ness during object construction.\footnote{This is again relaxation from Swift by Apple. The object might be fully initialized earlier, or later.} 
  \item As soon as every instance variable is properly defined, the \code{self} object becomes available for regular use. 
  \item After this point, the object is considered fully initialized, and the phase is complete. 
\end{enumerate}

{\bfseries Phase 2}
\begin{enumerate}
  \item This phase begins as soon as all declared instance variables are defined.
  \item As the control flows on, either continuing up the inheritance chain, or descending from a parent constructor, other constructors have now the ability to access the new object (as \code{self}). This includes both designated and convenience constructors, whichever gets control back earlier goes first. 
  \item At this phase, instance methods may be also called, because the object is already constructed. Also, modifications of immutable instance variables are still allowed -- up to the point where the bottommost constructor finishes its evaluation. 
\end{enumerate}

\paragraph{\em Accessibility of constructors}
Constructors may have modified accessibility, so that only certain functions can invoke them indirectly. The accessibility is then transitioned from the calling context. 

\example An example of a designated constructor of class $C$.
\begin{lstlisting}
class $C$
  constructor (param)
    val @resource := param
    super()
  end constructor
end class
\end{lstlisting}

\example An example of a pair of constructors of class $C$. 
\begin{lstlisting}
class $C$
  constructor (param)
    val @resource := param
    super()
  end constructor
  convenience constructor := self(42)
end class
\end{lstlisting}

\paragraph{\em Constant instance variables}
Any constructor may modify a constant instance variable during its evaluation, even multiple times. This behavior passes on to any methods that are invoked during the object's construction, but should be used with caution. 

\paragraph{\em Explicit destructor}
An explicit destructor does not have any accessibility. The super-destructor is invoked implicitly at the end of its execution, unless explicitly invoked earlier. Destructors are parameterless and have a further requirement that they can not increment the reference count of the object being destructed -- doing so could result in zombie objects. To further emphasize that, the \code{this} and \code{self} keywords are disallowed in a destructor body, and invoking any method that does use the \code{self}-value is forbidden. The VM is required to raise an error in case \code{self} would be attempted to be retained again, to prevent zombie objects apocalypse. 

\paragraph{\em Implicit destructor}
An implicit destructor is an automatically generated bridge destructor to the parameterless super-destructor. An implicit destructor ``does nothing'' but release all members specific to the destructed object and invoke super-destructor afterwards. The destructor of \code{Object} releases every remaining member of the destructed object. A class can only have a single destructor, either an explicit or an implicit one. 

\paragraph{\em Accessibility of destructors}
Destructors, unlike constructors, can not have any accessibility modifiers. They ignore the current accessibility flag of their class-block and trigger a warning if a modifier is used directly with the destructor. Destructors may be invoked independently on the context in which the object is destructed. 

\example An example of an explicit destructor of class $C$. 
\begin{lstlisting}
class $C$
  destructor
    @resource.close unless @resource.closed?
    (* super is invoked implicitly here *)
  end destructor
end class
\end{lstlisting}






\subsection{Clone Constructor Definitions}
\label{sec:clone-def}

\syntax\begin{lstlisting}
CCtor_Def     ::= ['convenience'] 'clone' CCtor_Fun_Def
CCtor_Fun_Def ::= [Type_Param_Clause] [Param_Clauses] 
                  (':=' Constr_Expr | Clone_Block)
Clone_Block   ::= [semi Constr_Block3] 'end' ['clone']
                | Constr_Block2
\end{lstlisting}

Clone constructors are pretty much like constructor, except for they are not invoked indirectly by \code{allocate} on \code{Class}, but by ~\lstinline[deletekeywords={clone}]!clone!~ on the cloned instance. Regular constructors are not invoked on the cloned objects, since they were already invoked on the original object. 

Clone constructor implicitly returns the new cloned object, unless returning explicitly a different object (which would possibly invoke its regular constructors). The original object is available with the \code{self[origin]}, \code{this[origin]} and \code{super[origin]} constructs (the latter being only useful as prefix in function applications), the new cloned object is available with the \code{self[cloned]}, \code{this[cloned]} and \code{super[cloned]} constructs. The ~\lstinline!self[cloned]!~ construct is only legal in a body of the clone constructor. Clone constructors are invoked in the context of the original object, but the original object still has to be accessed with the defined construct. 

Clone constructors have the ability to modify immutable instance variables, but only of the new cloned object (\code{self[cloned]}) -- the original object is already constructed. 

Clone constructors pass on the eigenclass (if any) of the original object to the cloned object, thus elevating it to an almost regular class -- a prototype class, a class that resides not in a constant, but in a class instance, in an object (but that original object may be still assigned to a constant anyway). 

A different clone constructor of the same class may be invoked by using the \code{self} keyword as a function name. If a clone constructor invokes a different clone constructor of the same class this way, the super-clone-constructor is not implicitly invoked (since it is invoked in the other clone constructors). The same rules for using \code{self[cloned]} (as \code{self}) as in constructors apply. 

The \code{Object} class has a default root clone constructor, which carries the modifier \code{protected} (\sref{sec:modifiers}). Therefore, any custom clone constructor has to be explicitly protected in a less restrictive way, or public, in order to allow direct object cloning from outside of the class that defines it. 

\paragraph{Implicit clone constructor}
An implicit clone constructor is an automatically generated bridge clone constructor to the parameterless default clone constructor. An implicit clone constructor ``does nothing'' but invokes the super-clone-constructor and makes a shallow copy of every member specific to the cloned object. 

\paragraph{Designated clone constructor}
A designated clone constructor can only invoke inherited clone constructors from superclass. 

\paragraph{Convenience clone constructor}
A convenience clone constructor is a clone constructor marked with the keyword \code{convenience}. They can only invoke clone constructors from the same class. 

\paragraph{Accessibility of clone constructors}
Clone constructors may have modified accessibility, so that only certain functions can invoke them indirectly. The accessibility is then transitioned from the calling context. 

\example An example of a default clone constructor of class $C$, performing a deep copy. 
\begin{lstlisting}
class $C$
  clone
    (* super is invoked implicitly here *)
    self[cloned].@resource := self[origin].@resource.clone
  end constructor
end class
\end{lstlisting}





\subsection{Upgrade Constructor Definitions}
\label{sec:upgrade-def}

\syntax\begin{lstlisting}
UCtor_Def     ::= ['convenience'] 'upgrade' 'constructor' 
                  UCtor_Fun_Def
UCtor_Fun_Def ::= '(' id [':' 'self' '.' 'type'] ')'
                  (':=' Constr_Expr | Constr_Block)
\end{lstlisting}







\subsection{Case Classes}
\label{sec:case-classes}

\syntax\begin{lstlisting}
Class_Definition ::= [Mutability] 'case' 'class' Class_Def
\end{lstlisting}

If a class definition is prefixed with \code{case}, the class is said to be a {\em case class}. 

The formal parameters are handled differently from regular classes. The formal parameters in the first parameter section of a case class are called {\em elements} and are treated specially:
\begin{itemize}
\item[] First, the value of such a parameter can be extracted as a field of a constructor pattern. 
\item[] Second, a \code{val} prefix is implicitly added to such a parameter, unless the parameter already carries a \code{val} or \code{var} modifier. Hence, an accessor definition for the parameter is generated (\sref{sec:class-definitions}). 
\end{itemize}

A case class definition of \lstinline!$c$[$\tps$]($\ps_1$)$\ldots$($\ps_n$)! with type parameters $\tps$, and value parameters $\ps$ implicitly adds some methods to the corresponding class object, making it suitable as an extractor object (\sref{sec:case-class-patterns}), and are defined as follows:
\begin{lstlisting}
object $c$ {
  def apply[$\tps$]($\ps_1$)$\ldots$($\ps_n$): $c$[$\tps$] := 
      $c$[$\Ts$].new($xs_1$)$\ldots$($xs_n$)
  def unapply[$\tps$]($x$: $c$[$\tps$]?): Option[$e$] :=
      unless $x$ = nil
        Some($x$.$xs_{11} \commadots x$.$xs_{1k}$)
      else
        None
      end
}
\end{lstlisting}

Here, $\Ts$ stands for the vector of types defined in the type parameter section $\tps$, each $xs_i$ denotes the parameter names of the parameter section $\ps_i$, $xs_{11} \commadots xs_{1k}$ denote the names of all parameters in the first parameter section $xs_1$, and $e$ denotes the type that \code{Option} is parameterized with. If a type parameter section is missing in the class $c$, it is also missing in the \code{apply} and \code{unapply} methods. The definition of \code{apply} is missing also if the class $c$ is marked \code{abstract}.\footnote{Because the implied \code{apply} method creates new objects and abstract classes can't have any instances of themselves.}

If the case class definition contains an empty value parameter list, the \code{unapply} returns a \code{Boolean} instead of an \code{Option} type and is defined as follows:
\begin{lstlisting}
def unapply[$\tps$]($x$: $c$[$\tps$]?): Boolean := $x$ /= nil
\end{lstlisting}

For each case of a value parameter list of $n$ parameters, the \code{unapply} returns these types: 
\begin{itemize}
\item
For $n = 0$, ~\lstinline!Boolean!~ is the result type. 

\item
For $n = 1$, ~\lstinline!Option[$\Tp_1$]!~ is the result type, where $\Tp_1$ is the type of the only parameter in the first parameter section. 

\item
For $n \geq 1$, ~\lstinline!Option[($\Tp_1 \commadots \Tp_n$)]!~ is the result type, where $\Tp_i$ is the type of the $i^{\superth}$ parameter of the first parameter section. Notice that the \code{Option} is parameterized with a tuple type (\sref{sec:tuple-types}). This allows for the \code{apply} method of \code{Some} to accept a tuple of arguments while accepting a single argument only. 
\end{itemize}

A method named \code{copy} is implicitly added to every case class, unless the case class already has a matching one, or the class has a repeated parameter. The method is defined as follows:
\begin{lstlisting}
def copy [$\tps$]($\ps'_1$)$\ldots$($\ps'_n$): $c$[$\tps$] :=
    $c$[$\Ts$].new($xs_1$)$\ldots$($xs_n$)
\end{lstlisting}
$\Ts$ stands for the vector of types defined in the type parameter section $\tps$. Each $xs_i$ denotes the parameter names of the parameter section $\ps'_i$.  Each value parameter of the first parameter list $\ps'_1$ has the form ~\lstinline!:$x_{1,j}$ : $T_{1,j}$ := self.$x_{1,j}$!, and the other parameters $\ps'_{i,j}$ of the clone constructor are defined as ~\lstinline!:$x_{1,j}$ : $T_{1,j}$!. Note that these parameters are defined as named parameters (\sref{sec:named-parameters}), and that the parameters of the first value parameter section have default values using \code{self}, which is available, since the copied object is already ``complete''. 

A clone constructor is also implicitly added to every case class, but limited to the first value parameter section. The following definition of the implicitly added clone constructor shares the definition of parameters: 
\begin{lstlisting}
clone [$\tps$]($\ps'_1$): $c$[$\tps$]
  self[cloned].@$xs_{1,1}$ := $xs_{1,1}$
  $\ldots$
  self[cloned].@$xs_{1,n}$ := $xs_{1,n}$
end clone
\end{lstlisting}
Here, $xs_{1,n}$ denotes the (named) parameter names of the first (and only) parameter section. All instance variables are shallow-copied into the new cloned object. 

Every case class implicitly overrides some method definitions of class \code{Object}, unless a definition of the same method is already given in the case class itself or a concrete definition of the same method is given in some base class (including traits) of the case class, different from \code{Object}. Namely: 
\begin{itemize}
  \item[] Method ~\lstinline!equals: (Object) $\mapsto$ Boolean!~ (equivalent to operator ``\lstinline!=!'') is structural equality, where two instances are equal if they both belong to the case class in question and they have equal (with respect to \code{equals}) elements. 

  \item[] Method ~\lstinline!hash_code: () $\mapsto$ Number.Integer_Unsigned!~ computes a hash code. 

  \item[] Method ~\lstinline!to_string: () $\mapsto$ String!~ returns a string representation which contains the name of the case class and its elements. 
\end{itemize}





\section{Trait Definitions}
\label{sec:traits}

\syntax\begin{lstlisting}
Trait_Definition ::= [Mutability] 'trait' Trait_Def
Trait_Def        ::= id [Type_Param_Clause] 
                     Trait_Tmpl_Env
Trait_Tmpl_Env   ::= Tmpl_Env_With_Pars ['trait']
                   | Tmpl_Env_Brackets
                   | Tmpl_Env_No_Pars ['trait']
\end{lstlisting}

A trait is a class that is meant to be injected into some other class as a mixin (including another traits). Unlike normal classes, traits can not be instantiated alone. 

Assume a trait $D$ defines some aspect of an instance $x$ of type $C$ (i.e. $D$ is a base class of $C$). Then the {\em actual supertype} of $D$ in $x$ is the compound type consisting of all the base classes in $\lin{C}$ that succeed $D$. The actual super type gives the context for resolving a \code{super} reference in a trait (\sref{sec:self-this-super}). Note that the actual supertype depends on the type to which the trait is added in a trait composition; it is not statically known at the time the trait is defined (the trait must exist before being added anywhere). 

If $D$ is not a trait, then its actual supertype is simply its least proper supertype (which is statically known). 

\example The following trait defines the property of being comparable to objects of some type. It contains an abstract operator \lstinline!<! and default implementations of the other comparison operators \lstinline!<=!, \lstinline!>! and \lstinline!>=!. Operators are methods, too. The trait also requires the self-type to be \code{T}. 
\begin{lstlisting}
trait Comparable[T <: Comparable[T]] {
  requires T
  operator < (that: T): Boolean end
  operator <=(that: T): Boolean := self < that or self = that
  operator > (that: T): Boolean := that < self
  operator >=(that: T): Boolean := that <= self
}
\end{lstlisting}






\section{Refinement Definitions}
\label{sec:refinements}

There are two separate branches of refinements in Aml, both are quite similar, but used for different purposes. Refinements are kind of a trait (\sref{sec:traits}). The branches are as follows:
\begin{itemize}
  \item[] First, refinements as part of the type system. Those refinements present only declarations and further type restrictions as part of compound types (\sref{sec:compound-types}).

  \item[] Second, refinements that are basically traits designed to be locally prepended to classes. The second branch is described here. 
\end{itemize}

\syntax\begin{lstlisting}
Refinement_Definition ::= 'refinement' Refinement_Def
Refinement_Def        ::= id 'refine' Type {'and' Type} 
                          Refinement_Tmpl_Env
Refinement_Tmpl_Env   ::= Tmpl_Env_With_Pars ['refinement']
                        | Tmpl_Env_Brackets
\end{lstlisting}

Such a refinement does not declare any type parameters, since those are already declared on the types that it refines. Therefore, the type and units of measure parameters are made visible to the refinement in order to allow it to override the class methods type-correctly. 

If multiple types are refined at once, then special care has to be taken when overriding existing members of the refined types -- those members have to be all present in every refined type, as well as all members of the refined types that are accessed from within the refinement. Then, such a refinement is equivalent to a series of refinements, one per each refined type. 

Multiple refinements bearing the same name may co-exist in any module, as long as each refinement per each refined type does not define multiple members of the same signature. 

Refinements need to be ``activated'' in the scope for it to take effect (\sref{sec:use-expressions}), similar to aspects.

If a refinement refines a parameterized type, then the refinement only activates for this parameterized type (\sref{sec:parameterized-types}). 

A refinement is not allowed to include or prepend any new traits to the type that it refines. It is an error if it attempts to do so. 

A refinement is though allowed to refine classes that are \code{final} or \code{sealed}. 






\section{Protocol Definitions}
\label{sec:protocols}

\syntax\begin{lstlisting}
Protocol_Definition ::= 'protocol' Pro_Def
Pro_Def             ::= id [Type_Param_Clause]
                        Pro_Tmpl_Env
Pro_Tmpl_Env        ::= Tmpl_Env_With_Pars ['protocol']
                      | Tmpl_Env_Brackets
                      | Tmpl_Env_No_Pars ['protocol']
\end{lstlisting}

Protocols express the contracts that other classes have to implement, and are added to classes with the keyword ``\code{implements}'' or as a part of the type's signature. 

Protocols are basically traits (\sref{sec:traits}) that are stripped of some features, namely: 
\begin{itemize}
  \item Only declarations are allowed as the template body. If a method definition is needed, use a trait instead. 

  \item Protocols can't declare anything for the class or metaclass of the class that implements them. If this is needed, use a trait instead. 

  \item Protocols don't have early definitions (\sref{sec:early-defs}). If this is needed, again, use a trait instead. 

  \item Protocols can make use of the \code{optional} and \code{requires} keywords as modifiers in their template (\sref{sec:statements}), as any other traits, but their usage is preferred within protocols. 
\end{itemize}

Protocol references are preferred to traits to be used by library designers to declare contracts for the code that uses them. 





\section{Interface Definitions}
\label{sec:interfaces}

\syntax\begin{lstlisting}
Interface_Definition ::= [Mutability] Ifc_Kind 'interface' Ifc_Def
Ifc_Kind             ::= ['case'] 'class' 
                       | ['case'] 'object'
                       | 'trait'
                       | 'refinement'
Ifc_Def              ::= id [Type_Param_Clause]
                         [Class_Param_Clauses] Ifc_Tmpl_Env
Ifc_Tmpl_Env         ::= Tmpl_Env_With_Pars ['interface']
                       | Tmpl_Env_Brackets
                       | Tmpl_Env_No_Pars ['interface']
\end{lstlisting}

Interfaces are filtered versions of classes and traits with only declarations and without early definitions or any definitions at all, except for auxiliary constructor definitions that become empty constructor declarations (without function bodies). Interfaces can be generated from classes or traits by simple transformations and manually edited as needed. Their only purpose is to be used in {\em module interfaces}, so that implementation is not distributed along, but only declarations in interfaces and protocols are. 





\section{Object Definitions}
\label{sec:object-definitions}

\syntax\begin{lstlisting}
Object_Definition ::= [Mutability] 'object' Object_Def
Object_Def        ::= id Object_Tmpl_Env
Object_Tmpl_Env   ::= Tmpl_Env_With_Pars ['object']
                    | Tmpl_Env_Brackets
                    | Tmpl_Env_No_Pars ['object']
Expr              ::= [Mutability] 'object' Object_Tmpl_Env
\end{lstlisting}

Object definitions define singleton instances. If no superclass is given, \code{Aml/Language.Object} is implied, unless the object definition has the same name as an existing or enclosing class -- then \lstinline!Class[$C$]! is implied and the object definition is called a {\em class object}. If a class of the same name exists defined in source code after the object definition, then the object must explicitly extend \code{Aml/Language.Class[]}, without any type arguments\footnote{This is to prevent the automatic extension of \code{Aml/Language.Object}.} -- it is sufficient to write down \code{Class}, if that name is imported to resolve to \code{Aml/Language.Class}, which it usually is. If the class definition is not connected to a class, then rules from compound types apply (\sref{sec:compound-types}), the object definition is simply called a {\em singleton object definition} and is a single object of a new (anonymous) class. This is unlike in Scala, where objects are defined as terms, in a scope separate from types: Aml has one scope for both types and terms. 

It's most general form is ~\lstinline!object $m$ extends $t$!. Here, $m$ is the name of the object to be defined (or of the class object, which is the same as the related class), and $t$ is a template (\sref{sec:templates}) of one of the following forms:

\paragraph{\em Singleton object form}
This is a form of objects that are not class objects (not instances of ~\lstinline!Metaclass[$C$]!). 
\begin{lstlisting}
$sc$ with $mt_1$ with $\ldots$ with $mt_n$ { $\stats$ }
\end{lstlisting}

\paragraph{\em Class object form}
This is a form of objects that are class objects, therefore instances of ~\lstinline!Metaclass[$C$]!. 
\begin{lstlisting}
$mt_1$ with $\ldots$ with $mt_n$ { $\stats$ }
\end{lstlisting}

Every trait applied to a class object does not affect the associated class itself -- here, the class object is the object that inherits features of the included/prepended traits, not the class instances; and the trait is included/prepended in the metaclass of the class object. This also has an implication on self types of traits (\sref{sec:traits}) that are to be included in a class object of class $C$: the self type would have to be ~\lstinline!Class[$C$]!, not just $C$. 






\subsection{Case Objects}
\label{sec:case-objects}

\syntax\begin{lstlisting}
Object_Definition ::= [Mutability] 'case' 'object' Object_Def
\end{lstlisting}

Case objects are pretty much similar to case classes (\sref{sec:case-classes}). Case objects can not be class objects at the same time. Their template (\sref{sec:templates}) is the singleton object form of an object definition (\sref{sec:object-definitions}). 

A case object definition implicitly adds some methods to the object instance, making it suitable as an extractor object (\sref{sec:case-object-patterns}), and are defined as follows:
\begin{lstlisting}
object $c$ {
  def unapply($x$: $c$.type?): Boolean := ($x$ == self)
}
\end{lstlisting}






