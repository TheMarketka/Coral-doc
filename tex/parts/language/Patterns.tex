%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\chapter{Pattern Matching}
\label{sec:pattern-matching}

\minitoc

\newpage




\section{Patterns}
\label{sec:patterns}

\grammar\begin{lstlisting}
Pattern
    ::= Atomic_Pattern
      | Non_Atomic_Pattern
Atomic_Pattern 
    ::= Var_Pattern
      | Bound_Pattern
      | Typed_Pattern
        (* a portion of Type_Pattern *)
      | ':?' (Simple_Type - Postfix_Parameterized_Type)  
      | Type_Instance_Pattern
      | Wildcard_Pattern
      | Constant_Pattern
      | Grouped_Pattern
        (* a portion of Named_Pattern *)
      | Stable_Id  
      | List_Pattern
      | Array_Pattern
      | Dict_Pattern
      | Multimap_Pattern
      | Bag_Pattern
      | Record_Pattern
      | Struct_Pattern
      | '(' Pattern ')'
Non_Atomic_Pattern 
    ::= Type_Pattern
      | Type_Bound_Pattern
      | Infix_Pattern
      | Or_Pattern
      | And_Pattern
      | Named_Pattern
      | Tag_Pattern
      | Tuple_Pattern
      | Cons_Pattern
      | Annotated_Pattern
      | Lazy_Pattern
Var_Pattern 
    ::= ['implicit'] ['val' | 'var'] var_id
Bound_Pattern 
    ::= Pattern 'as' Var_Pattern
Wildcard_Pattern 
    ::= '_'
Constant_Pattern 
    ::= Constant
Typed_Pattern 
    ::= '(' Type_Bound_Pattern ')'
Type_Pattern 
    ::= ['type' 'is' | ':?'] Type_Expr
Type_Bound_Pattern 
    ::= Pattern ':' Type_Expr
Type_Instance_Pattern 
    ::= Singleton_Type
      | Projected_Type
Grouped_Pattern 
    ::= '(' Pattern ')'
Infix_Pattern 
    ::= Pattern (Infix_Op - ('and also', 'or else')) Pattern
Or_Pattern 
    ::= Pattern '|' Pattern
And_Pattern 
    ::= Pattern '&' Pattern
Named_Pattern 
    ::= Stable_Id {Pattern_Param} [Tuple_Extractions]
Tag_Pattern
    ::= Tag_Name [Tuple_Extractions]
Tuple_Pattern 
    ::= Pattern {',' Pattern}+
      | Tuple_Extractions
List_Pattern
    ::= '%[' [Seq_Extractions] ']'
Array_Pattern
    ::= '%[|' [Seq_Extractions] '|]'
Dict_Pattern 
    ::= '%{' [Dict_Extractions] '}'
Multimap_Pattern 
    ::= '%{{' [Dict_Extractions] '}}'
Bag_Pattern
    ::= '%(' [Seq_Extractions] ')'
Cons_Pattern 
    ::= Pattern '::' Pattern
Annotated_Pattern 
    ::= {Annotation}+ Pattern
Extractions
    ::= Pattern 
      | Positional_Extracts {',' Labelled_Extracts}
      | Labelled_Extracts
Tuple_Extractions 
    ::= Extractions
      | '(' Extractions ')'
Positional_Extracts 
    ::= Pattern {',' Pattern} [',' Rest_Extracts {',' Pattern}]
      | Rest_Extracts {',' Pattern}
Rest_Extracts
    ::= Optional_Extract {',' Optional_Extract} [',' Rest_Extract]
      | Rest_Extract
Optional_Extract 
    ::= '?' Pattern
      | '?' ['val' | 'var'] id [':' Type_Expr]
      | '?' '_' [':' Type_Expr]
      | '?(' Pattern '=' Expr ')'
Rest_Extract 
    ::= '*' ['val' | 'var'] id [':' Type_Expr]
      | '*' '_' [':' Type_Expr]
Labelled_Extracts 
    ::= Labelled_Pattern {',' Labelled_Pattern} [',' Capture_Extract]
      | Capture_Extract
Labelled_Pattern 
    ::= '~'   ['val' | 'var'] id 
      | '~('  ['val' | 'var'] id [':' Type_Expr] ')'
      | '~'   ['val' | 'var'] id ':' Pattern
      | '~'   ['val' | 'var'] id ':' '(' Pattern [':' Type_Expr] ')'
      | '~?'  ['val' | 'var'] id
      | '~?(' ['val' | 'var'] id [':' Type_Expr] ['=' Expr] ')'
      | '~?'  ['val' | 'var'] id ':' Pattern
      | '~?'  ['val' | 'var'] id ':' '(' Pattern [':' Type_Expr] ['=' Expr] ')'
Capture_Extract 
    ::= '**' var_id [':' Type_Expr]
      | '**' '_' [':' Type_Expr]
Seq_Extractions
    ::= Pattern {semi Pattern} [semi Seq_Rest_Extracts] {semi Pattern}
      | Seq_Rest_Extracts {semi Pattern}
Seq_Rest_Extracts 
    ::= Optional_Extract {semi Optional_Extract} [semi Rest_Extract]
      | Rest_Extract
Dict_Extractions 
    ::= Dict_Extraction {semi Dict_Extraction} [semi Capture_Extract]
      | Capture_Extract
      | Seq_Extractions
Dict_Extraction
    ::= Dict_Key '=' Pattern
Dict_Key 
    ::= '_'
      | Expr
Record_Pattern 
    ::= '{' Field_Patterns '}'
Field_Patterns 
    ::= Field_Pattern {semi Field_Pattern} [semi '_']
      | '_'
Field_Pattern 
    ::= Stable_Id '=' Pattern
Struct_Pattern
    ::= '(' 'structure' id ['as' Pkg_Type] ')'
Pattern_Param 
    ::= Expr
\end{lstlisting}

\begin{table}[h!]
  \caption{The relative precedences and associativity of operators and non-closed pattern constructs, in decreasing precedence order.}
\begin{center}
\begin{tabular}{l l}
  Operator or construct & Associativity \\ \hline \hline
  Infix pattern (\sref{sec:infix-patterns}) & operator-based \\ \hline
  Named pattern, tag application\ \  & right \\ \hline
  \code{::} & right \\ \hline
  \code{=>} & - \\ \hline
  \code{,} & left \\ \hline
  \lstinline!&! & left \\ \hline
  \code{|} & left \\ \hline
  \code{as} & - \\ \hline
\end{tabular}
\end{center}
\label{table:pattern-matching-op-precedences}
\end{table}%





\subsection{Atomic \& Non-Atomic Patterns}
\label{sec:atomic-patterns}
\label{sec:non-atomic-patterns}

We call {\em atomic patterns} those of pattern forms that can appear consecutively on a line and still have their boundaries clear and unambiguous. On the other hand, {\em non-atomic patterns} could make such consecutive appearances ambiguous. This distinction is only important in grammar constructs that allow consecutive appearance of patterns, namely function parameters. 





\subsection{Constant Patterns}
\label{sec:constant-patterns}

\grammar\begin{lstlisting}
Constant_Pattern 
    ::= Constant
\end{lstlisting}

A constant pattern $L$ matches any value that is structurally equal (defined by the \code{Equatable} trait, ``\code{=}'' operator returning ``\code{yes}'') to the constant value $L$. The type of $L$ must conform to the expected type of the matched value. 

\example An example of a constant pattern. 
\begin{lstlisting}
let rotate_3 = function
  when 0 then "two"
  when 1 then "zero"
  when 2 then "one"
end function
\end{lstlisting}

A constant pattern contributes the type of the constant to type of parameter, when used in function parameter list. 





\subsubsection{Regular Expression Patterns}
\label{sec:regexp-patterns}

\grammar\begin{lstlisting}
Pattern 
    ::= Constant
\end{lstlisting}

A regular expression pattern $p$ ({\em regexp pattern}) is a variant of constant pattern, designed to match \code{String_Like} values. Literally, the pattern $p$ matches a value $v$, if $v$ is of a type that conforms to \code{String_Like} and its contents match the regular expression. Moreover, sub-patterns bind to variable names of a name of the form ~\lstinline!match_$n$!, where $n$ is either the position of the sub-pattern (unless the sub-pattern is explicitly not captured), or the name of a named sub-pattern. 

Regular expression patterns are not designed to match against algebraic data structures. 

Regular expression patterns contribute the \code{String_Like} type to type of parameter, when used in function parameter list. 






\subsection{Variable Patterns}
\label{sec:variable-patterns}

\grammar\begin{lstlisting}
Var_Pattern 
    ::= ['implicit'] ['val' | 'var'] var_id
\end{lstlisting}

A variable pattern $x$ is a simple identifier which starts with a lower case letter. It matches any value and binds the variable name to that value. The type of $x$ is the expected type of the pattern as given from the outside. 

A variable pattern contributes the implicit type of a variable to type of parameter, when used in function parameter list. It is by default \code{Auto}. 

A variable pattern is implicitly prefixed with \code{val}, and thus the bound variable is immutable, and prefixing it explicitly is redundant. A variable pattern may also be prefixed with \code{var} instead, then the bound variable is mutable. 

A variable pattern prefixed with \code{implicit} is made eligible to be passed as implicit argument (\sref{sec:implicit-parameters}). The value that is eligible is however the current value at the instant of function application with implicit arguments -- therefore if the variable is mutable, it might be a different value than the one bound from the pattern match. 

A variable pattern contributes the type \code{Aml/Language.Any} to type of parameter, when used in function parameter list. 






\subsection{Wildcard Patterns}
\label{sec:wildcard-patterns}

\grammar\begin{lstlisting}
Wildcard_Pattern 
    ::= '_'
\end{lstlisting}

The pattern ``\code{_}'' is a wildcard pattern that matches any input and does not bind any value to any variable. 

A wildcard pattern contributes the type \code{Aml/Language.Any} to type of parameter, when used in function parameter list. 

\example In this example, if \code{x} is 0, the match returns 1, if \code{x} has any other value, the match returns 0. The second definition is equivalent. 
\begin{lstlisting}
let categorize = function
  when 1 then 0
  when 0 then 1
  when _ then 0
end

let categorize_alternative = function
  when 1 then 0
  when 0 then 1
  otherwise 0
end
\end{lstlisting}

Wildcard patterns may also be used in extractions to ignore the input at the given site. 





\subsection{Named Patterns}
\label{sec:named-patterns}

\grammar\begin{lstlisting}
Named_Pattern 
    ::= Stable_Id {Pattern_Param} [Tuple_Extractions]
\end{lstlisting}

In a named pattern, the \code{Stable_Id} part must not start with a lowercase letter as defined in \code{var_id}, otherwise it would be interpreted as a variable pattern. 

Due to the syntactic overlap regarding variable patterns, Aml offers a simple solution to interpret an identifier starting with a lowercase letter as a value instead of a variable pattern, and that is to enclose the identifier in backquotes, so that ``\code{id}'' is ``\code{`id`}''. Such an identifier is never considered to be a variable pattern. 

If that condition is met, then the \code{Stable_Id} part may resolve into the following elements:
\begin{itemize}
  \item An enumeration element (\sref{sec:enumeration-patterns}). 
  \item A variant type case (\sref{sec:variant-patterns}). 
  \item A generalized algebraic datatype (\sref{sec:gadt-patterns}). 
  \item An open variant type case (\sref{sec:open-variant-patterns}). 
  \item A throwable or raiseable type case (\sref{sec:throwable-patterns}). 
  \item A case class or case object (\sref{sec:case-class-patterns}). 
  \item An active pattern case name (\sref{sec:active-patterns}). 
  \item A value implementing \code{Pattern_Matching} (\sref{sec:pattern-matching-values}).
  \item A (likely constant) value implementing \code{Equatable} (\sref{sec:equatable-patterns}).\footnote{The runtime should issue a warning if the value is not constant, since that condition would make the pattern match possibly behave differently at different execution times.}
  \item A class object (\sref{sec:metaclasses}) of a class that defines a primary constructor with one or more parameters (\sref{sec:constructor-patterns}).
\end{itemize}

After the \code{Stable_Id} is resolved, the named pattern is treated according to the following subsections. 





\subsubsection{Enumeration Patterns}
\label{sec:enumeration-patterns}

If \code{Stable_Id} from (\sref{sec:named-patterns}) resolves to an enumeration element, the pattern is an enumeration pattern. Such pattern then matches inputs that are equal to the enumeration element. The form \code{Stable_Id} is used if the corresponding enumeration element takes no arguments or if arguments are to be ignored, and the form \code{Stable_Id Tuple_Extractions} is used if it takes arguments, which are then matched according to the \code{Tuple_Extractions} (\sref{sec:extractions-in-patterns}). 

An enumeration pattern contributes the enumeration type to type of parameter, when used in function parameter list. 

\example An example of an enumeration pattern with extractions:
\begin{lstlisting}
type Data = enum
  case Kind_1 of Number * Number
  case Kind_2 of String * String
end

let some_data = Data.Kind_1(4, 2)

let result = match some_data
  when Kind_1(a, b) then a + b
  when Kind_2(s1, s2) then s1.length + s2.length
end
\end{lstlisting}
Which gives \code{result} a value of \code{6}. 





\subsubsection{Variant Type Case Patterns}
\label{sec:variant-patterns}

If \code{Stable_Id} from (\sref{sec:named-patterns}) resolves to an variant type case, the pattern is a variant type case pattern. Such pattern then matches inputs that are members of the variant type case element. The form \code{Stable_Id} is used if the corresponding variant type case takes no arguments or if arguments are to be ignored, and the form \code{Stable_Id Tuple_Extractions} is used if it takes arguments, which are then matched according to the \code{Tuple_Extractions} (\sref{sec:extractions-in-patterns}). 

A variant type case pattern contributes type of the variant type case to type of parameter, when used in function parameter list. 





\subsubsection{Generalized Algebraic Datatype Patterns}
\label{sec:gadt-patterns}

Generalized algebraic datatype patterns are equivalent to variant type case patterns (\sref{sec:variant-patterns}), only their type inference is a bit more challenging.





\subsubsection{Open Variant Type Case Patterns}
\label{sec:open-variant-patterns}

Open variant type case patterns are by all means equivalent to variant type case patterns (\sref{sec:variant-patterns}), except that they work with open variant types instead of (closed) variant types. 





\subsubsection{Throwable \& Raiseable Type Case Patterns}
\label{sec:throwable-patterns}

Throwable and raiseable type case patterns are equivalent to open variant patterns (\sref{sec:open-variant-patterns}).





\subsubsection{Case Class \& Case Object Patterns}
\label{sec:case-class-patterns}
\label{sec:case-object-patterns}

If \code{Stable_Id} from (\sref{sec:named-patterns}) resolves to a value that is a case class object or a case object, then the pattern is a {\em case class pattern} or a {\em case object pattern} respectively. 

To match a case class/object pattern, the object's \code{unapply} (which is always present, unlike with constructor patterns -- \sref{sec:constructor-patterns}) is applied to the input value:
\begin{itemize}
  \item If the result value is of type \code{Option[$T_1 \commadots T_n$]}, and is not \code{None}, then the pattern matches if the extractions matches the wrapped tuple. 
  \item If the result value is of type \code{Option[$T$]}, and is not \code{None}, then the pattern matches if the extractions matches the wrapped value. 
  \item If the result value is of type \code{Boolean}, then the pattern matches if the value is \code{yes}. 
\end{itemize} 

A case class pattern contributes the class associated with the class object to type of parameter, when used in function parameter list. A case object pattern contributes type of the case object. 





\subsubsection{Active Patterns}
\label{sec:active-patterns}

\grammar\begin{lstlisting}
Active_Pattern_Ids 
    ::= '(|' id {'|' id} ['|' '_'] '|)'
\end{lstlisting}

If \code{Stable_Id} from (\sref{sec:named-patterns}) resolves to an {\em active pattern case name} $C_i$, then the pattern is an active pattern. $C_i$ is associated with an {\em active pattern function} $f$ in one of the following forms:
\begin{itemize}
  \item \lstinline!(|$C$|) input! \\
    Single case. The function accepts one argument (the value being matched) and can return any type. 
  \item \lstinline!(|$C$|_|) input! \\
    Partial. The function accepts one argument and must return a value of type \code{Option[$T$]}, where $T$ is any type. 
  \item \lstinline!(|$C_1$|$\ldots$|$C_n$|) input! \\
    Multi-case. The function accepts one argument and must return a value of type ~\lstinline!Choice[$T_1\commadots T_n$]!. 
  \item \lstinline!(|$C_1$|$\ldots$|$C_n$|_|) input! \\
    Multi-case partial. The function accepts one argument and must return a value of type ~\lstinline!Option[Choice[$T_1\commadots T_n$]]!. 
  \item \lstinline!(|$C_1$|) arg$_1 \ldots$ arg$_n$ input! \\
    Single case with parameters. The function accepts $n+1$ arguments, where the last argument (\code{input}) is the value to match, and can return any type. 
  \item \lstinline!(|$C_1$|_|) arg$_1 \ldots$ arg$_n$ input! \\
    Partial with parameters. The function accepts $n+1$ arguments, where the last argument (\code{input}) is the value to match, and must return a value of type \code{Option[$T$]}. 
  \item \lstinline!(|$C_1$|$\ldots$|$C_n$|_|) input! \\
    Multi-case partial with parameters. The function accepts $n+1$ arguments, where the last argument (\code{input}) is the value to match, and must return a value of type ~\lstinline!Option[Choice[$T_1\commadots T_n$]]!.
\end{itemize}

When an active pattern function accepts more than 1 argument, the \code{Pattern_Param}s are interpreted as expressions that are passed to the active pattern function. 

The active pattern function $f$ is applied at runtime to the pattern input, along with any arguments. The pattern matches if the active pattern function returns $v$, ~\lstinline!Choice_$k$_of_$n$($v$)!, \code{Some($v$)}, or ~\lstinline!Some(Choice_$k$_of_$n$ $v$)! when applied to the pattern input. If the pattern argument \code{Tuple_Extractions} is present, then it is matched against $v$. If this does not match, the whole active pattern does not match. 

\example This example shows how to define and use a partial active pattern function:
\begin{lstlisting}
let (|Positive|_|) input = if input > 0 then Some input else None end
let (|Negative|_|) input = if input < 0 then Some -input else None end

match 3
when Positive n then "positive, n = #{n}"
when Negative n then "negative, n = #{n}"
otherwise "zero"
end match
\end{lstlisting}

\example This example then shows how to define and use a multi-case active pattern function:
\begin{lstlisting}
let (|A|B|C|) input = 
  if input < 0 then A
  else if input = 0 then B
  else C
  end if
  
match 3
  when A then "negative"
  when B then "zero"
  when C then "positive"
end match
\end{lstlisting}
Notice in this example that the expressions like \code{A} are elaborated to \code{A(())}, and as the non-constant constructor of \code{Choice} types accepts one argument, the type of that argument is \code{Unit}, as well as the corresponding type argument. 

\example An example of a parameterized active pattern function:
\begin{lstlisting}[deletekeywords={not,of}]
let (|Is_Multiple_Of|_|) n input = 
  if input mod n = 0
  then Some input / n
  else None
  end if
  
match 16
when Is_Multiple_Of 4 m then printfn "x = 4 * %d" % n
else printfn "not a multiple of 4"
end match
\end{lstlisting}

An active pattern function may be executed multiple times against the same pattern input during resolution of a single complete pattern match. The precise number is left to implementations, but it should be as close as possible to 1. Implementations of active pattern functions should be referentially transparent. 

An active pattern contributes the type of \code{input} to type of parameter, when used in function parameter list. 





\subsubsection{Pattern Matching Values}
\label{sec:pattern-matching-values}

If \code{Stable_Id} from (\sref{sec:named-patterns}) resolves to a value that is not a class object or otherwise special for pattern matching, and the value is of a class that implements \code{Pattern_Matching[$T$]}, the pattern matches its input, if the result of applying ~\lstinline!=~!~ to the input value with the resolved value as receiver is \code{yes}.

It is highly suspicious if the resolved value is not a constant value, and a warning should be issued. 

A pattern matching value pattern contributes the type $T$ of the implemented \code{Pattern_Matching[$T$]}. If the value implements \code{Pattern_Matching[$T_i$]} multiple times with different type arguments $T_i$, then the contributed type is union of all $T_i$. 





\subsubsection{Equatable Patterns}
\label{sec:equatable-patterns}

If \code{Stable_Id} from (\sref{sec:named-patterns}) resolves to a value that is not a class object or otherwise special for pattern matching, and the value is of a class that implements \code{Equatable}, the pattern matches its input, if the two values are structurally equal as defined by \code{Equatable} (not necessarily physically equal).

It is highly suspicious if the resolved value is not a constant value, and a warning should be issued. 

An equatable pattern contributes the type \code{Equatable} to type of parameter, when used in function parameter list. Note however that the value has to pre-exist, so the only possible sources are constant values defined in outer scopes, or one of the parameters.





\subsubsection{Constructor Patterns}
\label{sec:constructor-patterns}

If \code{Stable_Id} from (\sref{sec:named-patterns}) resolves to a value that is a class object, then the pattern is a {\em constructor pattern}. 

To match a constructor pattern, the class object's \code{unapply} is applied to the input value:
\begin{itemize}
  \item If the result value is of type \code{Option[$T_1 \commadots T_n$]}, and is not \code{None}, then the pattern matches if the extractions matches the wrapped tuple. 
  \item If the result value is of type \code{Option[$T$]}, and is not \code{None}, then the pattern matches if the extractions matches the wrapped value. 
  \item If the result value is of type \code{Boolean}, then the pattern matches if the value is \code{yes}. 
  \item If the class object does not respond to \code{unapply}, but the associated class has a primary constructor with one or more parameters, the argument that is used for the first parameter is used as result of \code{unapply} instead, unwrapped from \code{Option[$T$]} (and it may be a tuple) -- as if the class was a case class. 
\end{itemize} 

A constructor pattern contributes the class associated with the class object to type of parameter, when used in function parameter list. 





\subsection{Polymorphic Variant Patterns}
\label{sec:polymorphic-variant-patterns}

\grammar\begin{lstlisting}
Tag_Pattern 
    ::= Tag_Name [Tuple_Extractions]
\end{lstlisting}

Polymorphic variant type case patterns ~\lstinline!`$t$ $p$! matches all polymorphic variants whose tag is equal to $t$, and whose arguments can be extracted by tuple extractions $p$, if $p$ is present. 





\subsection{Pattern Binders}
\label{sec:pattern-binders}

\grammar\begin{lstlisting}
Bound_Pattern 
    ::= Pattern 'as' Var_Pattern
\end{lstlisting}

A pattern binder ~\lstinline!$p$ as $x$!~ consists of a variable pattern $x$ (\sref{sec:variable-patterns}) and a pattern $p$. The type of the variable $x$ is the type $T$ resulting from the pattern $p$. This pattern matches any value $v$ matched by the pattern $p$, provided the type of $v$ is also an instance of $T$, and it binds the variable name to that value. 

A pattern binder contributes the type contributed by the pattern $p$ to type of parameter, when used in function parameter list. 

\example In the following example, \code{person} binds to the whole \code{Person} object. 
\begin{lstlisting}
let f (someone: Person) = match someone
  when Person("John Galt", _, _) as person then $\ldots$
end match
\end{lstlisting}





\subsection{Disjunctive ``Or'' Patterns}
\label{sec:disjunctive-patterns}

\grammar\begin{lstlisting}
Or_Pattern 
    ::= Pattern '|' Pattern
\end{lstlisting}

A disjunctive pattern matches an input value against one of two patterns: ~\lstinline!pattern1 | pattern2!. 

At runtime, the pattern input is matched against the first pattern, and if that fails, the pattern input is matched against the second pattern. 

If any of the sub-patterns binds variables (\sref{sec:pattern-binders}), then both sub-patterns must bind the same set of variables of the same types, but variables are only bound by the pattern that did not fail the match (if any). 

As a convenience, a variable binding that is present in any of the two patterns with a defined type (\sref{sec:typed-patterns}) does not need to repeat the same defined type in its second occurrence, it is automatically inferred. If that is not the case, the inferred type for both binding occurrences\footnote{For the same bound name.} must be the same, as defined earlier. 

Matching this pattern is short-circuited -- if the first sub-pattern matches the input, then the second sub-pattern is not matched at all. 

Disjunctive patterns contribute union of types contributed by both sub-patterns to type of parameter, when used in function parameter list. 





\subsection{Conjunctive ``And'' Patterns}
\label{sec:conjunctive-patterns}

\grammar\begin{lstlisting}
And_Pattern 
    ::= Pattern '&' Pattern
\end{lstlisting}

A conjunctive pattern matches an input value against two patterns sequentially: ~\lstinline!pattern1 & pattern2!. 

At runtime, the pattern input is matched against the first pattern. If that does not fail, then the input is matched against the second pattern in environment enriched by variables bound by the first pattern (if such bindings were defined in the first pattern, obviously). If the input matches the second pattern, the pattern matches the input. 

Matching this pattern is short-circuited -- if the first sub-pattern does not match the input, then the second sub-pattern is not matched at all. 

Conjunctive patterns contribute intersection of types contributed by both sub-patterns to type of parameter, when used in function parameter list. 





\subsection{Typed Patterns}
\label{sec:typed-patterns}

\grammar\begin{lstlisting}
Typed_Pattern 
    ::= '(' Type_Bound_Pattern ')'
Type_Bound_Pattern 
    ::= Pattern ':' Type
Type_Pattern 
    ::= ['type' 'is' | ':?'] Type
\end{lstlisting}

A typed pattern of the form ~\lstinline!($p$: $T$)!~ consists of a pattern $p$ and a type pattern $T$. A typed pattern may also be of the forms ~\lstinline!$T$!, ~\lstinline!type is $T$!~ and
~\lstinline!:? $T$!, all of which are equivalent. 

Aml does not distinguish type-annotated patterns from dynamic type-test patterns -- all such patterns are dynamic type-test patterns, with implications from a type-annotated pattern. 

At runtime, the pattern input is matched, if the input value's type is known to be a subtype (or equivalent) to the type $T$, or if it dynamically is of such a subtype (the input is evaluated either way). 

If a pattern $p$ is present in the pattern's form, then the pattern matches the input if it matches $p$, where $p$ is typed with $T$. If $p$ is a variable pattern (\sref{sec:variable-patterns}) or a wildcard pattern (\sref{sec:wildcard-patterns}), then $p$ matches only if the input value's type is a subtype of $T$, as otherwise, the binding would not type-check (in case of variable pattern), or the pattern would be rendered useless (in case of wildcard pattern). 

As a special case, if the pattern $p$ is a variable pattern, then the bound variable is typed with $T$. 

A typed pattern contributes the type $T$ to type of parameter, when used in function parameter list. 





\subsection{List Patterns}
\label{sec:list-patterns}

\grammar\begin{lstlisting}
List_Pattern 
    ::= '%[' [Seq_Extractions] ']'
\end{lstlisting}

List patterns use \code{Seq_Extractions}, shared among multiple pattern kinds, but described in this section. 

The simplest list pattern is the {\em empty list pattern}, which is of the form ~\lstinline!%[]!, and matches empty lists (or sequences -- will be using that from now on), including the constant empty list \code{List.Nil}. 

More elaborate forms of list patterns include sequential extractions (\code{Seq_Extractions}), which are sub-patterns. There are three principal kinds of extractions:
\begin{enumerate}
  \item {\em Mandatory extractions}. These render the minimal length of a sequence - the count of mandatory extractions is the minimal length of a sequence. Mandatory extractions are any patterns. 
  \item {\em Optional extractions}. These add to the maximal length of a sequence - the count of optional extractions added to the count of mandatory extractions is the maximal length of a sequence. Optional extractions (\code{Optional_Extract}) come in 4 forms:
    \begin{enumerate}
      \item ~\lstinline!?$p$!, which may bind variables only if there is a variable pattern bound to the matched value. The type of such variable pattern is \code{Option[$T$]}, and if a value $v$ is present for the extraction, \code{Some($v$)} is bound to the variable, \code{None} otherwise. 
      \item ~\lstinline!?$x$: $T$!, ~\lstinline!? val $x$: $T$!, ~\lstinline!? var $x$: $T$!, which are specific forms of the first form, where the variable pattern is $x$, combined with a typed pattern (\sref{sec:typed-patterns}). 
      \item ~\lstinline!?_: $T$!, which is a specific form of the first form, where the variable pattern is a wildcard pattern, combined with a typed pattern (\sref{sec:typed-patterns}). 
      \item ~\lstinline!?($p$ = $e$)!, which is different from the previous forms. Moreover, $p$ is required to bind the input value to a variable, but when there is no value to match it with, the expression $e$ is evaluated and bound to the variable pattern from $p$. Thus, \code{None} would never be bound, and the type of the bound variable is not wrapped in \code{Option[$T$]}.\footnote{If $p$ uses wildcard pattern instead of variable pattern to bind the input value to a variable, $e$ might be evaluated for side-effects.} 
    \end{enumerate}
  \item {\em Rest extraction}. There may be only up to one rest extraction. When a rest extraction is present, the maximal length of a sequence is virtually infinite, overriding any other finite maximal length. Rest extractions come in just 2 forms:
    \begin{enumerate}
      \item ~\lstinline!*_!~ \& ~\lstinline!*_: $T$!, which do not bind any elements, but optionally require the elements to be of the given type $T$. This form is only useful to match lists whose elements that are matched by this form are of no importance, and also to generally match lists of length $n$ and more without binding the extra elements. 
      \item ~\lstinline!*$x$!, ~\lstinline!*$x$: $T$!, ~\lstinline!*var $x$!, ~\lstinline!*var $x$: $T$!, ~\lstinline!*val $x$!~ \& ~\lstinline!*val $x$: $T$!, which bind the matched elements into a new sublist\footnote{Using a \code{slice} operation on the full list.}, which is bound to the variable $x$. 
    \end{enumerate}
\end{enumerate}

These extractions may appear only in the following order:
\begin{enumerate}
  \item Any number of mandatory extractions. Those are matched to elements from the beginning of a sequence. 
  \item Any number of optional extractions. Those are matched from unmatched elements following the previous. 
  \item Zero or one rest extraction. This matches all unmatched elements. 
  \item Any number of mandatory extractions. Those are matched to elements from the end of a sequence and must not overlap with already matched elements. After these mandatory extractions are matched, the previous two kinds of extractions may be matched. 
\end{enumerate}

A list pattern contributes \code{Sequence[$T$]}\footnote{Usually \code{Linear_Sequence[$T$]}, but in fact is abstract over any sequence, including indexed sequences like arrays.} to type of parameter, when used in function parameter list, where $T$ is inferred from its sub-patterns. 

\example An example of a list pattern.
\begin{lstlisting}
let list_size list = 
  match list 
  when %[] then 0
  when %[_] then 1
  when %[_; _] then 2
  when %[_; _; _] then 3
  otherwise list.size  (* duh *)
  end match
\end{lstlisting}
Note that in the example, the type that would be inferred for \code{list} is \code{Sequence[Any]}. 





\subsection{``Cons'' Patterns}
\label{sec:cons-patterns}

\grammar\begin{lstlisting}
Cons_Pattern 
    ::= Pattern '::' Pattern
\end{lstlisting}

A {\em ``cons'' pattern} is a different form of a list pattern (\sref{sec:list-patterns}), matching sequence's ``head'' (first element) by the first pattern and sequence's ``tail'' (all elements but the first one) by the second pattern. 

The pattern ~\lstinline!%[$p_1$; $\ldots$; $p_n$]! can be seen as a shorthand for a series of ``\code{::}'' and empty list patterns: ~\lstinline!$p_1$ :: $\ldots$ :: $p_n$ :: %[]!. 

If $p_2$ is a variable pattern, then ~\lstinline!$p_1$ :: $p_2$!~ is equivalent to ~\lstinline!%[$p_1$; *$p_2$]!. 

A single cons pattern ~\lstinline!$p_1$ :: $p_2$!~ matches non-empty sequences, whose heads match $p_1$, and whose tail matches $p_2$. 

Cons patterns contribute the same type as list patterns to parameters. 





\subsection{Array Patterns}
\label{sec:array-patterns}

\grammar\begin{lstlisting}
Array_Pattern 
    ::= '%[|' [Seq_Extractions] '|]'
\end{lstlisting}

Array pattern is very much like a list pattern (\sref{sec:list-patterns}), except that it matches only indexed sequences. 

An array pattern contributes \code{Indexed_Sequence[$T$]} to type of parameter, when used in function parameter list, where $T$ is inferred from its sub-patterns. 

\example An example of an array pattern.
\begin{lstlisting}[deletekeywords={of}]
let vector_length vector = 
  match vector 
  when %[| v1 |] then v1
  when %[| v1; v2 |] then Math.sqrt (v1^2 + v2^2)
  when %[| v1; v2; v3 |] then Math.sqrt (v1^2 + v2^2 + v3^2)
  otherwise raise "Unsupported size of %d." % vector.size
  end match
\end{lstlisting}
Note that in the example, the type that would be inferred for \code{vector} is \code{Array_Like[Number_Like]}, but it could go even further: 
\begin{lstlisting}
Array_Like[Number_Like] with constraint { 1 <= size <= 3 }
\end{lstlisting}





\subsection{Dictionary Patterns}
\label{sec:dict-patterns}

\grammar\begin{lstlisting}
Dict_Pattern 
    ::= '%{' [Dict_Extractions] '}'
\end{lstlisting}

Dictionary patterns use \code{Dict_Extractions}, shared with multimap patterns (\sref{sec:multimap-patterns}), but described only here. 

The simplest dictionary pattern is the {\em empty dictionary pattern}, which is of the form ~\lstinline!%{}!, and matches empty dictionaries. 

More elaborate forms include dictionary extractions (\code{Dict_Extractions}), which are sub-patterns. There are two principal kinds of dictionary extractions:
\begin{enumerate}
  \item Key-based extractions (using \code{Dict_Extraction} \& optionally followed by or solely a \code{Capture_Extract}). 
  \item Sequence-based extractions (reusing \code{Seq_Extractions}). 
\end{enumerate}

Key-based extractions are of these forms:
\begin{enumerate}
  \item Specific key extraction: \lstinline!$k$ => $p$!, where $k$ is either a literal value, or a value expression. Such a sub-pattern retrieves an element from the input dictionary that is mapped by the given key, and matches it against the pattern $p$. 
  \item Key-wildcard extraction: \lstinline!_ => $p$!, where such sub-pattern matches the first not yet matched value from the dictionary, which matches $p$ at the same time (thus values that do not match the pattern are ignored and matched in the following sub-patterns, if any). If the input dictionary preserves some ordering of elements, then this kind of sub-pattern match is also deterministic. 
  \item Capturing extraction: \lstinline!**$v$!, ~\lstinline!**$v$: $T$!, ~\lstinline!**_!~ \& ~\lstinline!**_: $T$!. Such sub-pattern matches all remaining elements from the input dictionary, and if $v$ is present in it, binds a sub-dictionary to the variable $v$. If the type $T$ is also given, all remaining elements in the input dictionary have to conform to that type. Such sub-pattern may only be present once in a dictionary pattern, and allows input dictionaries to contain more keys than just the explicitly required (or wildcarded) ones. 
\end{enumerate}

Dictionaries may also be matched as sequences with sequential extractions, where input dictionaries should preserve some ordering of elements. Dictionary patterns may also be used to match sequences, provided that all keys of the pattern are integral numbers. 

A dictionary pattern contributes \code{Dictionary[$K$, $T$]} to type of parameter, when used in function parameter list, where $K$ and $T$ are inferred from its sub-patterns automatically, or \code{Any}. 





\subsection{Multimap Patterns}
\label{sec:multimap-patterns}

\grammar\begin{lstlisting}
Multimap_Pattern 
    ::= '%{{' [Dict_Extractions] '}}'
\end{lstlisting}

Multimap patterns are very much like dictionary patterns (\sref{sec:dict-patterns}), but the elements that are mapped to keys are always sequences and not (almost arbitrary) values. 





\subsection{Bag Patterns}
\label{sec:bag-patterns}

\grammar\begin{lstlisting}
Bag_Pattern 
    ::= '%(' [Seq_Extractions] ')'
\end{lstlisting}

A bag pattern is similar to list patterns (\sref{sec:list-patterns}), except that it matches elements of the input bag in non-deterministic order, unless the input bag actually preserves some ordering of elements. 

A bag pattern does not distinguish between its two major forms, bags and sets. Each element's tally can still be obtained from the input bag. 

A bag pattern contributes \code{Bag[$T$]} to type of parameter, when used in function parameter list, where $T$ is inferred from its sub-patterns automatically, or \code{Any}. 





\subsection{Record Patterns}
\label{sec:record-patterns}

\grammar\begin{lstlisting}
Record_Pattern 
    ::= 'record' '{' Field_Patterns '}'
\end{lstlisting}

A record pattern enables values of record types to be decomposed into a number of record fields. 

The record pattern ~\lstinline!record { $f_1$ => $p_1$; $\ldots$; $f_1$ => $p_n$ }!~ matches records that define exactly the fields $f_1$ to $f_n$, and such that the value associated with $f_i$ matches the pattern $p_i$, for $i = 1 \commadots n$. If there are multiple record types that have the same fields, then at least one of $f_i$ have to specify the field with a path to the intended type\footnote{The first field should be used for this.}: \code{$T$.$f$}, where $T$ is a path to the record type, and $f$ is the field. 

The record pattern ~\lstinline!record { $f_1$ => $p_1$; $\ldots$; $f_1$ => $p_n$; _ }!~ matches records that define at least the fields $f_1$ to $f_n$, with the same rules as the previous record pattern, where the extra fields, if any, are simply discarded.\footnote{Such a pattern is more prone to ambiguous record types. In such a case, the record type has to be resolved by specifying the path to it in at least one of the fields.}





\subsection{Lazy Patterns}
\label{sec:lazy-patterns}

\grammar\begin{lstlisting}
Lazy_Pattern 
    ::= 'lazy' Pattern
\end{lstlisting}





\subsection{Structure Patterns}
\label{sec:structure-patterns}

\grammar\begin{lstlisting}
Struct_Pattern 
    ::= '(' 'structure' id [':' Pkg_Type] ')'
\end{lstlisting}

A structure pattern ~\lstinline!(structure $n$: $T$)!~ matches a structure with type $T$ and binds it to the value name $n$. The type $T$ may be omitted, if it can be inferred from the enclosing pattern. 

% Currently, no decomposing of structures is possible. Could be added later, if it would make sense. 









\subsection{Tuple Patterns}
\label{sec:tuple-patterns}

\grammar\begin{lstlisting}
Tuple_Pattern 
    ::= Pattern {',' Pattern}+
      | Tuple_Extractions
\end{lstlisting}

A {\em tuple pattern} has multiple forms, simplest of which is a sequence of 2 or more sub-patterns, which directly influence the required parity of any input tuple, not allowing any optional elements. Elements of the tuple are matched by their position in the tuple, which corresponds to position of each sub-pattern. 

More elaborate form uses tuple extractions (\code{Tuple_Extractions}), described in (\sref{sec:extractions-in-patterns}). Input tuples for such patterns may be of multiple parities, and also those tuples can have their elements extracted by the elements' labels, instead of position, as in the first form. 

A tuple pattern contributes a tuple type to type of parameter, when used in function parameter list. The concrete tuple type uses annotations to mark all optional elements of the required argument as well as labels of those elements, as per sub-patterns. 





\subsection{Extractions in Patterns}
\label{sec:extractions-in-patterns}

Extractions are of the syntactic form \code{Tuple_Extractions}, as they are primarily designed to extract data from tuples and reused by other kinds of patterns. 

Tuple extractions combine two approaches to extractions: positional and labelled. 

Positional extractions are very much like sequential extractions, delimited by a comma ``\code{,}'' instead of a newline or semicolon. After all positional extractions are evaluated against the input tuple, labelled extractions are used to extract any remaining elements, by their given labels. 

Positional extractions are used to extract elements from the sequence of all non-labelled elements of the matched tuple, and then separately labelled extractions are used to extract elements from the map (from labels to elements) of all labelled elements of that tuple. Both extractions must succeed in order for the pattern that uses tuple extractions to match. In some cases, positional and labelled elements of the matched tuple may overlap -- that has only one consequence: the overlapping elements may be matched more than once. 

Labelled extractions (\code{Labelled_Pattern}) are similar to dictionary extractions, where the keys are of type \code{Symbol} and represented in the syntactic form with the \code{id} element. Capture extraction is shared with dictionary patterns (\sref{sec:dict-patterns}), where the type of keys in the sub-dictionary is \code{Symbol}, and all remaining elements are bound into it, preserving their labels in the keys. There are multiple kinds of labelled extractions: 
\begin{enumerate}
  \item The forms ~\lstinline!~$v$!~ and ~\lstinline!~($v$ $[$: $T$$]$)!~ are shorthands for respectively ~\lstinline!~$v$: val $v$!~ and ~\lstinline!~$v$: (val $v$ $[$: $T$$]$)!. 
  \item The form ~\lstinline!~$v$: $p$!, which matches an input value labelled $v$, and matches the value against the pattern $p$. This form subsumes the form ~\lstinline!~$v$: val $v$!, which is using a variable pattern $v$ to bind the input value, and also the form ~\lstinline!~$v$: (val $v$ $[$: $T$$]$)!, which uses a typed pattern instead of a simple variable pattern, but needs grouping parentheses. 
  \item The form ~\lstinline!~$v$: ($p$ $[$: $T$$]$)!~ is extension to the previous form and restricts inputs for the sub-pattern $p$ to conform to $T$, if $T$ is present. 
  \item The form ~\lstinline!~?$v$!~ is a shorthand for the form ~\lstinline!~?$v$: val $v$!. 
  \item The form ~\lstinline!~?($v$ $[$: $T$$]$ $[$:= $e$$]$)!~ is a shorthand for the form ~\lstinline!~?$v$: (val $v$ $[$: $T$$]$ $[$:= $e$$]$)!. 
  \item The form ~\lstinline!~?$v$: ($p$ $[$: $T$$]$ $[$:= $e$$]$)!, which subsumes the form ~\lstinline!~?($v$ $[$: $T$$]$ $[$:= $e$$]$)!, matches an input value labelled $v$, and if such value is not present in the input tuple, then the result bound to a variable by $p$ depends on whether $e$ is present: if it is, the result of its evaluation is bound directly, otherwise \code{Option[$T$]} wrapper is used instead, very much like with optional extractions in sequence extractions. 
  \item The forms ~\lstinline!**$v$!~ and ~\lstinline!**$v$: $T$!, which match all remaining unmatched input values, into a variable $v$ typed \code{Dictionary[Symbol, $T$]}, where $T$ is \code{Any}, if $T$ is not given.
  \item The forms ~\lstinline!**_!~ and ~\lstinline!**_: $T$!, which match all remaining unmatched input values, discarding those values. The values must be of the type $T$, if given. 
\end{enumerate}

The sequence of matched elements depends on which kinds of extractions are present:
\begin{itemize}
  \item If only positional extractions are present, all elements are matched, stripped of their labels. 
  \item If only labelled extractions are present, then elements without labels are not matched. If a capture extraction is present, then its value contains all elements, where the key is the element's position for elements without label, and the label for the rest that has a label. 
  \item If both extractions are present, then both are performed. Positional extractions are performed only on elements without any label and labelled extractions are similarly only performed on labelled elements. 
\end{itemize}





\subsection{Infix Operation Patterns}
\label{sec:infix-patterns}

\grammar\begin{lstlisting}
Infix_Pattern 
    ::= Pattern (Infix_Op - ('and also', 'or else')) Pattern
\end{lstlisting}

An infix operation pattern ~\lstinline!$p_1$ $\op$ $p_2$!~ is a syntax sugar for the named pattern (\sref{sec:named-patterns}) ~\lstinline!$\op$($p_1$, $p_2$)!. The precedence, associativity and binding direction of operators in patterns is the same as in expressions (\sref{sec:prefix-infix-ops}).

An infix operation pattern ~\lstinline!$p$ $\op$ ($q_1 \commadots q_n$)!~ is a shorthand for the named pattern ~\lstinline!$\op$($p,\,q_1 \commadots q_n$)!.





\subsection{Grouped Patterns}
\label{sec:grouped-patterns}

\grammar\begin{lstlisting}
Grouped_Pattern 
    ::= '(' Pattern ')'
\end{lstlisting}

Patterns can be grouped together to achieve the desired associativity. 

Grouped patterns contribute the least upper bound of all types contributed by the grouped patterns to type of parameter, when used in function parameter list. 





\subsection{Annotated Patterns}
\label{sec:annotated-patterns}

\grammar\begin{lstlisting}
Annotated_Pattern 
    ::= {Annotation}+ Pattern
\end{lstlisting}

Annotated patterns do not generally have any special matching rules, unless their annotations specify a different behaviour. 





\section{Irrefutable Patterns}
\label{sec:irrefutable-patterns}

A pattern $p$ is {\em irrefutable} for input value of type $T$, if one of the following applies: 
\begin{enumerate}
  \item $p$ is a variable pattern (\sref{sec:variable-patterns}),
  \item $p$ is a typed pattern ~\lstinline!$x$: $T'$! (\sref{sec:typed-patterns}), and ~\lstinline!$T$ <: $T'$!,
  \item $p$ is a named pattern ~\lstinline!$c$($p_1 \ldots p_n$)! (\sref{sec:named-patterns}), the type $T$ is an instance of a class $c$, the primary constructor (\sref{sec:class-definitions}) of type $T$ has argument types $T_1 \commadots T_n$, and each $p_i$ is irrefutable for type $T_i$. 
\end{enumerate}

An irrefutable pattern is a pattern that always matches its input (hence irrefutable). 





\section{Pattern Matching Expressions}

For grammar, refer to (\sref{sec:case-exprs}).

A pattern matching expression 
\begin{lstlisting}
match $e$ { when $p_1$ then $b_1\ \ldots$ when $p_n$ then $b_n$ else $b_{n+1}$ }
\end{lstlisting}
consists of a selector expression $e$ and a number $n > 0$ of cases. Each case consists of a (possibly guarded) pattern $p_i$, a block $b_i$ and optionally the default block $b_{n+1}$, if none of the patterns matched. Each $p_i$ might be complemented by a guard \code{if e} or \code{unless e}, where $e$ is a guarding expression, that is typed as \code{Boolean}. The scope of the pattern variables in $p_i$ comprises the pattern's guard and the corresponding block $b_i$. If the following when clause ~\lstinline!when $p_{i+1}$ then $b_{i+1}$! is preceded by the keyword \code{next}, then the pattern variables in $p_i$ do not comprise the block $b_{i+1}$ and neither the pattern $p_{i+1}$. 

Let $T$ be the type of the selector expression $e$. Every pattern $e \in \{ p_1 \ldots p_n \}$ is typed with $T$ as its expected type. 

The expected type of every block $b_i$ is the expected type of the whole pattern matching expression. The type of the pattern matching expression is then the weak least upper bound (\sref{sec:weak-conformance}) of the types of all blocks $b_i$. 

When applying a pattern matching expression to a selector value, patterns are tried in given order, until one is found that matches the selector value. Say this \code{when} clause is ~\lstinline!when $p_i$ then $b_i$!. The result of the whole expression is then the result of evaluating $b_i$, where all pattern variables of $p_i$ are bound to the corresponding parts of the selector value. If no matching pattern is found, a \code{No_Match} is raised. 

The pattern in a \code{when} clause may also be followed by a guard suffix ~\lstinline!if $e$! with a boolean expression $e$. The guard expression is evaluated if the preceding pattern in the case matches. If the guard expression evaluates to \code{yes}, the pattern match succeeds as normal. If the guard expression evaluates to \code{yes}, the pattern in the case is considered not to match and the search for a matching pattern continues. 

The pattern in a case may also be followed by a guard suffix ~\lstinline!unless $e$! with a boolean expression $e$. The guard expression is evaluated as if it was ~\lstinline!if not $e$!. 

In the interest of efficiency the evaluation of a pattern matching expression may try patterns in some other order than the textual sequence, even parallelized (indeed, compiler would not decide this on its own -- it has to be specified with an annotation or a pragma (\sref{sec:annotations}) applied to the pattern matching expression). This might affect evaluation through side effects in guards. However, it is guaranteed that a guard expression is evaluated only if the pattern it guards matches.

If the selector of a pattern match is an instance of a \code{sealed} class (\sref{sec:modifiers}), the compilation of the pattern matching expression can emit warnings, which diagnose that a given set of patterns is not exhaustive, i.e. there is a possibility of a \code{No_Match} being raised at runtime. 

A when clause that is not the first appearing may be prefixed with \code{next} on the preceding line, in which case control falls through to its code from the previous when clause, but only if the prefixed when clause does not bind any variables that are not present in the preceding when clause. A bound variable is present in the preceding when clause if its inferred or bound type is equivalent to the inferred or bound type of a bound variable in the prefixed clause with the same name. The variables in the prefixed when clause are persisted from the preceding when clause. 






\section{Pattern Matching Anonymous Functions}
\label{sec:pattern-matching-anon-fun}

For grammar, refer to (\sref{sec:anonymous-functions}).

An anonymous pattern matching function can be defined by the form
\begin{lstlisting}
function 
  when $p_1$ then $b_1$ 
  $\ldots$ 
  when $p_k$ then $b_k$ 
  else $b_{k+1}$
end
\end{lstlisting}

The expression is taken to be equivalent to the anonymous function:
\begin{lstlisting}
fun ($x_1$: $S_1 \commadots x_j$: $S_j$) ->
  match ($x_1 \commadots x_j$) {
    when $p_1$ then $b_1$
    $\ldots$
    when $p_k$ then $b_k$
    else $b_{k+1}$
  }
\end{lstlisting}

Here, each $x_i$ is a fresh name. As was shown in (\sref{sec:anonymous-functions}), this anonymous function is in turn equivalent to the following instance creation expression, where $T$ is the weak least upper bound of the types of all $b_i$. 

\begin{lstlisting}
(Function[$S_1 \commadots S_j$, $T$] with {
  method apply ($x_1$: $S_1 \commadots x_j$: $S_j$): $T$ = match ($x_1 \commadots x_j$)
    when $p_1$ then $b_1$
    $\ldots$
    when $p_k$ then $b_k$
    else $b_{k+1}$
  end match
}).new
\end{lstlisting}

\example Here is a method which uses a fold-left operation ~\lstinline!/:!~ to compute the scalar product of two vectors:
\begin{lstlisting}
let scalar_product (xs: List[Double], ys: List[Double]) = 
  (0.0 /: xs.zip(ys)) {
    when (a, (b, c)) then a + b * c
  }
\end{lstlisting}
The when clauses in this code are equivalent to the following anonymous function:
\begin{lstlisting}
(x, y) -> { 
  match (x, y)
    when (a, (b, c)) then a + b * c
  end match
}
\end{lstlisting}

An anonymous pattern matching function can also be defined with a single atomic pattern and more simple syntax. 










